{"meta":{"title":"Jojo's Blog","subtitle":"","description":"","author":"Jojo Yang","url":"https://jojoyang666.github.io","root":"/"},"pages":[{"title":"Leetcode","date":"2020-07-16T05:13:59.000Z","updated":"2020-07-16T05:13:59.728Z","comments":true,"path":"Leetcode/index.html","permalink":"https://jojoyang666.github.io/Leetcode/index.html","excerpt":"","text":""},{"title":"Algorithms","date":"2020-06-23T06:11:50.000Z","updated":"2020-06-23T06:11:50.975Z","comments":true,"path":"Algorithms/index.html","permalink":"https://jojoyang666.github.io/Algorithms/index.html","excerpt":"","text":""},{"title":"Binary Indexed Tree","date":"2020-07-01T18:27:22.000Z","updated":"2020-07-01T18:27:22.044Z","comments":true,"path":"Binary-Indexed-Tree/index.html","permalink":"https://jojoyang666.github.io/Binary-Indexed-Tree/index.html","excerpt":"","text":""},{"title":"JavaScript","date":"2020-06-22T18:47:05.000Z","updated":"2020-06-22T18:47:05.243Z","comments":true,"path":"JavaScript/index.html","permalink":"https://jojoyang666.github.io/JavaScript/index.html","excerpt":"","text":""},{"title":"React","date":"2020-06-25T16:52:57.000Z","updated":"2020-06-25T16:52:57.456Z","comments":true,"path":"React/index.html","permalink":"https://jojoyang666.github.io/React/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-22T01:51:07.000Z","updated":"2020-06-22T01:52:06.868Z","comments":true,"path":"categories/index.html","permalink":"https://jojoyang666.github.io/categories/index.html","excerpt":"","text":""},{"title":"python","date":"2020-07-02T19:07:50.000Z","updated":"2020-07-02T19:07:50.445Z","comments":true,"path":"python/index.html","permalink":"https://jojoyang666.github.io/python/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-22T01:50:56.000Z","updated":"2020-06-22T01:51:38.044Z","comments":true,"path":"tags/index.html","permalink":"https://jojoyang666.github.io/tags/index.html","excerpt":"","text":""},{"title":"tools","date":"2020-06-22T22:34:37.000Z","updated":"2020-06-22T22:34:37.999Z","comments":true,"path":"tools/index.html","permalink":"https://jojoyang666.github.io/tools/index.html","excerpt":"","text":""},{"title":"读书","date":"2020-07-20T00:59:21.000Z","updated":"2020-07-20T00:59:21.372Z","comments":true,"path":"读书/index.html","permalink":"https://jojoyang666.github.io/%E8%AF%BB%E4%B9%A6/index.html","excerpt":"","text":""}],"posts":[{"title":"320. Generalized Abbreviation","slug":"320-Generalized-Abbreviation","date":"2020-09-18T16:25:34.000Z","updated":"2020-09-18T18:28:28.446Z","comments":true,"path":"2020/09/18/320-Generalized-Abbreviation/","link":"","permalink":"https://jojoyang666.github.io/2020/09/18/320-Generalized-Abbreviation/","excerpt":"","text":"Iterative wayusing bit to represent word123456789101112131415161718192021222324252627/** * @param &#123;string&#125; word * @return &#123;string[]&#125; */var generateAbbreviations = function(word) &#123; const res = [] for (let i = 0; i &lt; Math.pow(2, word.length); i++) &#123; let out = \"\", cnt = 0 for (let j = 0; j &lt; word.length; j++) &#123; if ((i &gt;&gt; j) &amp; 1) cnt++; else &#123; if (cnt !== 0) &#123; out += cnt + ''; cnt = 0; &#125; out += word.charAt(j) &#125; &#125; if (cnt &gt; 0) out += cnt + '' res.push(out) &#125; return res&#125;; 12345678910111213141516171819202122class Solution(object): def generateAbbreviations(self, word): \"\"\" :type word: str :rtype: List[str] \"\"\" res = [] for i in xrange(pow(2, len(word))): cnt, out = 0, \"\" for j in xrange(len(word)): if (i &gt;&gt; j) &amp; 1: cnt+=1 else: if cnt != 0: out += str(cnt) cnt = 0 out += word[j] if cnt &gt; 0: out += str(cnt) res.append(out) return res Recursive way — backtrackiing1234567891011121314151617181920/** * @param &#123;string&#125; word * @return &#123;string[]&#125; */var generateAbbreviations = function(word) &#123; const res = [] helper(word, 0, res) res.push(word) return res&#125;;const helper = (word, pos, res) =&gt; &#123; for (let i = pos; i &lt; word.length; i++) &#123; for (let j = 1; i + j &lt;= word.length; j++) &#123; const t = word.substring(0, i) + j + word.substring(i + j) res.push(t) helper(t, i + 1 + j.toString().length, res) &#125; &#125;&#125; 12345678910111213141516class Solution(object): def generateAbbreviations(self, word): \"\"\" :type word: str :rtype: List[str] \"\"\" res = [] res.append(word) def helper(w, pos): for i in xrange(pos, len(w)): for j in xrange(1, len(w) - i + 1): t = w[0:i] + str(j) + w[i + j:] res.append(t) helper(t, i + 1 + len(str(j))) helper(word, 0) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"406. Queue Reconstruction by Height","slug":"406-Queue-Reconstruction-by-Height","date":"2020-09-17T16:40:09.000Z","updated":"2020-09-17T16:52:17.083Z","comments":true,"path":"2020/09/17/406-Queue-Reconstruction-by-Height/","link":"","permalink":"https://jojoyang666.github.io/2020/09/17/406-Queue-Reconstruction-by-Height/","excerpt":"","text":"sort by the hight(reversed), insert by the index1234567891011class Solution(object): def reconstructQueue(self, people): \"\"\" :type people: List[List[int]] :rtype: List[List[int]] \"\"\" people.sort(key=lambda x: (-x[0], x[1])) output = [] for p in people: output.insert(p[1], p) return output 123456789101112131415161718192021/** * @param &#123;number[][]&#125; people * @return &#123;number[][]&#125; */var reconstructQueue = function(people) &#123; people.sort((a, b) =&gt; &#123; if (a[0] !== b[0]) &#123; return b[0] - a[0] &#125; else &#123; return a[1] - b[1] &#125; &#125;) let res = [] for (const person of people) &#123; // or right in this way: res.splice(person[1], 0, person) res = [...res.slice(0, person[1]), person, ...res.slice(person[1])] &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"362. Design Hit Counter","slug":"362-Design-Hit-Counter","date":"2020-09-17T04:57:32.000Z","updated":"2020-09-17T05:20:40.274Z","comments":true,"path":"2020/09/16/362-Design-Hit-Counter/","link":"","permalink":"https://jojoyang666.github.io/2020/09/16/362-Design-Hit-Counter/","excerpt":"","text":"选择合适的数据结构12345678910111213141516171819202122232425262728293031323334353637/** * Initialize your data structure here. */var HitCounter = function() &#123; this.queue = []&#125;;/** * Record a hit. @param timestamp - The current timestamp (in seconds granularity). * @param &#123;number&#125; timestamp * @return &#123;void&#125; */HitCounter.prototype.hit = function(timestamp) &#123; this.queue.push(timestamp)&#125;;/** * Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). * @param &#123;number&#125; timestamp * @return &#123;number&#125; */HitCounter.prototype.getHits = function(timestamp) &#123; while(this.queue.length &amp;&amp; (timestamp - this.queue[0] &gt;= 300)) &#123; this.queue.shift() &#125; return this.queue.length&#125;;/** * Your HitCounter object will be instantiated and called as such: * var obj = new HitCounter() * obj.hit(timestamp) * var param_2 = obj.getHits(timestamp) */ Follow UpWhat if the number of hits per second could be very large? Does your design scale? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Initialize your data structure here. */var HitCounter = function() &#123; this.times = new Array(300) this.hits = new Array(300)&#125;;/** * Record a hit. @param timestamp - The current timestamp (in seconds granularity). * @param &#123;number&#125; timestamp * @return &#123;void&#125; */HitCounter.prototype.hit = function(timestamp) &#123; let idx = timestamp%300; if (this.times[idx] !== timestamp) &#123; this.times[idx] = timestamp this.hits[idx] = 1 &#125; else &#123; this.hits[idx]++; &#125;&#125;;/** * Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). * @param &#123;number&#125; timestamp * @return &#123;number&#125; */HitCounter.prototype.getHits = function(timestamp) &#123; let res = 0 for (let i = 0; i &lt; 300; i++) &#123; if (timestamp - this.times[i] &lt; 300) &#123; res += this.hits[i] &#125; &#125; return res&#125;;/** * Your HitCounter object will be instantiated and called as such: * var obj = new HitCounter() * obj.hit(timestamp) * var param_2 = obj.getHits(timestamp) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"bfs, dfs, backtracking, Dijkstra","slug":"bfs-dfs-backtracking-Dijkstra","date":"2020-09-16T19:11:13.000Z","updated":"2020-09-16T20:11:24.802Z","comments":true,"path":"2020/09/16/bfs-dfs-backtracking-Dijkstra/","link":"","permalink":"https://jojoyang666.github.io/2020/09/16/bfs-dfs-backtracking-Dijkstra/","excerpt":"","text":"General 可以用掩码token &amp; (1 &lt;&lt; i)和token | (1 &lt;&lt; i)来看这个ith item是否用过， 并且更新他的状态 BFS + DFS add visited set Backtracking find all the possible solutions used-thing —-&gt; 123used(flag -&gt; true)recursivefuncition()used(flag -&gt; false -&gt; reset to initial funtion) In recursive function: 明确触底条件 Dijkstra 算法特点 bfs解决赋权有向图或者无向图的单源最短路径问题 算法的思路 dis保存源点（s）到各个顶点的最短路径 T: 已经找到了最短路径顶点的集合 初始赋值： dis[s] = 0 s顶点能直接到达的边(s, m) —&gt; dis[m] = w(s, m) s不能到达的点设置为无穷大 从dis中选择最小值， 将该点加入T中 从T中新加入的点来看是否可以到达其他顶点v 并且 看看通过该顶点到其他点v的路径长度， 是否比dis[v]小， 如果是， update dis[v], 然后从dis中选择最小值， 将该点加入T中， 重复改操作， 直到T中包含了图中的所有顶点","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1066. Campus Bikes II","slug":"1066-Campus-Bikes-II","date":"2020-09-16T18:24:26.000Z","updated":"2020-09-16T20:02:39.436Z","comments":true,"path":"2020/09/16/1066-Campus-Bikes-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/16/1066-Campus-Bikes-II/","excerpt":"","text":"bfs + pq 12345678910111213141516171819202122232425class Solution(object): def assignBikes(self, workers, bikes): \"\"\" :type workers: List[List[int]] :type bikes: List[List[int]] :rtype: int \"\"\" def dis(i, j): return abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]) h = [[0, 0, 0]] seen = set() while True: cost, i, taken = heapq.heappop(h) if (i, taken) in seen: continue seen.add((i, taken)) if i == len(workers): return cost for j in xrange(len(bikes)): if taken &amp; (1 &lt;&lt; j) == 0: heapq.heappush(h, [cost + dis(i, j), i + 1, taken | (1 &lt;&lt; j)]) backtracking 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[][]&#125; workers * @param &#123;number[][]&#125; bikes * @return &#123;number&#125; */var assignBikes = function(workers, bikes) &#123; const used = new Set() let res = Infinity; const calDist = (i, j) =&gt; &#123; return Math.abs(workers[i][0] - bikes[j][0]) + Math.abs(workers[i][1] - bikes[j][1]) &#125; const go = (i, dis) =&gt; &#123; if (i === workers.length) &#123; res = Math.min(res, dis) return; &#125; bikes.forEach((bike, idx) =&gt; &#123; if (!used.has(bike)) &#123; const dist = calDist(i, idx) used.add(bike) go(i + 1, dis + dist) used.delete(bike) &#125; &#125;) &#125; go(0, 0) return res&#125;; Dijistra 12345678910111213141516171819202122232425262728class Solution(object): def assignBikes(self, workers, bikes): \"\"\" :type workers: List[List[int]] :type bikes: List[List[int]] :rtype: int \"\"\" def dist(i, j): return abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]) h = [[0, 0, 0]] optimal = defaultdict(lambda: float('inf')) while True: cost, i, taken = heapq.heappop(h) if i == len(workers): return cost for j, bike in enumerate(bikes): if taken &amp; (1 &lt;&lt; j) == 0: new_cost = cost + dist(i, j) new_taken = taken | (1 &lt;&lt; j) if new_cost &lt; optimal[(i+1, new_taken)]: optimal[(i+1, new_taken)] = new_cost heapq.heappush(h, [new_cost, i + 1, new_taken])","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"833. Find And Replace in String","slug":"833-Find-And-Replace-in-String","date":"2020-09-16T03:21:10.000Z","updated":"2020-09-16T05:17:18.345Z","comments":true,"path":"2020/09/15/833-Find-And-Replace-in-String/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/833-Find-And-Replace-in-String/","excerpt":"","text":"reverse sort: 因为一旦replace， 会影响后面的结果所以要reverse sorted 123456789101112131415class Solution(object): def findReplaceString(self, S, indexes, sources, targets): \"\"\" :type S: str :type indexes: List[int] :type sources: List[str] :type targets: List[str] :rtype: str \"\"\" S = list(S) for i, x, y in sorted(zip(indexes, sources, targets), reverse = True): if all(i + k &lt; len(S) and S[i + k] == x[k] for k in xrange(len(x))): S[i:i+len(x)] = list(y) return \"\".join(S) 1234567891011121314151617181920/** * @param &#123;string&#125; S * @param &#123;number[]&#125; indexes * @param &#123;string[]&#125; sources * @param &#123;string[]&#125; targets * @return &#123;string&#125; */var findReplaceString = function(S, indexes, sources, targets) &#123; const array = indexes.map((item, idex) =&gt; [item, idex]) array.sort((a, b) =&gt; b[0] - a[0]) for (const [index, i] of array) &#123; const source = sources[i] if (S.substring(index, index + source.length) === source) &#123; S = S.substring(0, index) + targets[i] + S.substring(index + source.length) &#125; &#125; return S&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"731. My Calendar II","slug":"731-My-Calendar-II","date":"2020-09-16T02:57:02.000Z","updated":"2020-09-16T03:04:31.589Z","comments":true,"path":"2020/09/15/731-My-Calendar-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/731-My-Calendar-II/","excerpt":"","text":"filtered by overlaps list add overlap list contents12345678910111213141516171819202122232425262728class MyCalendarTwo(object): def __init__(self): self.overlaps = [] self.calender = [] def book(self, start, end): \"\"\" :type start: int :type end: int :rtype: bool \"\"\" for i, j in self.overlaps: if start &lt; j and end &gt; i: return False for i, j in self.calender: if start &lt; j and end &gt; i: self.overlaps.append((max(start, i), min(end, j))) self.calender.append((start, end)) return True # Your MyCalendarTwo object will be instantiated and called as such:# obj = MyCalendarTwo()# param_1 = obj.book(start,end) 12345678910111213141516171819202122232425262728293031323334var MyCalendarTwo = function() &#123; this.overlaps = [] this.calender = []&#125;;/** * @param &#123;number&#125; start * @param &#123;number&#125; end * @return &#123;boolean&#125; */MyCalendarTwo.prototype.book = function(start, end) &#123; for (const [i, j] of this.overlaps) &#123; if (start &lt; j &amp;&amp; end &gt; i) &#123; return false; &#125; &#125; for (const [i, j] of this.calender) &#123; if (start &lt; j &amp;&amp; end &gt; i) &#123; this.overlaps.push([Math.max(start, i), Math.min(j, end)]) &#125; &#125; this.calender.push([start, end]) return true&#125;;/** * Your MyCalendarTwo object will be instantiated and called as such: * var obj = new MyCalendarTwo() * var param_1 = obj.book(start,end) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"274. H-Index","slug":"274-H-Index","date":"2020-09-15T23:02:41.000Z","updated":"2020-09-15T23:03:07.253Z","comments":true,"path":"2020/09/15/274-H-Index/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/274-H-Index/","excerpt":"","text":"12345678910111213/** * @param &#123;number[]&#125; citations * @return &#123;number&#125; */var hIndex = function(citations) &#123; citations.sort((a, b) =&gt; b - a) for (let i = 0; i &lt; citations.length; i++) &#123; if (citations[i] &lt;= i) return i; &#125; return citations.length&#125;","categories":[],"tags":[]},{"title":"837. New 21 Game","slug":"837-New-21-Game","date":"2020-09-15T20:54:36.000Z","updated":"2020-09-15T21:13:21.288Z","comments":true,"path":"2020/09/15/837-New-21-Game/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/837-New-21-Game/","excerpt":"","text":"Thinking: 12345678910111213141516171819class Solution(object): def new21Game(self, N, K, W): \"\"\" :type N: int :type K: int :type W: int :rtype: float \"\"\" dp = [0.0] * (N + W + 1) for k in xrange(K, N + 1): dp[k] = 1.0 S = min(N - K + 1, W) for k in xrange(K - 1, -1, -1): dp[k] = S/float(W) S += dp[k] - dp[k + W] return dp[0] 1234567891011121314151617181920212223/** * @param &#123;number&#125; N * @param &#123;number&#125; K * @param &#123;number&#125; W * @return &#123;number&#125; */var new21Game = function(N, K, W) &#123; const dp = new Array(N + W + 1).fill(0.0) for (let i = K; i &lt; N + 1; i++) &#123; dp[i] = 1 &#125; let S = Math.min(N - K + 1, W); for (let i = K - 1; i &gt;= 0; i--) &#123; dp[i] = S/W S += dp[i] - dp[i+W] &#125; return dp[0]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"911. Online Election","slug":"911-Online-Election","date":"2020-09-15T14:40:02.000Z","updated":"2020-09-15T15:31:56.674Z","comments":true,"path":"2020/09/15/911-Online-Election/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/911-Online-Election/","excerpt":"","text":"Counter + Binary Search 1234567891011121314151617181920212223242526272829303132class TopVotedCandidate(object): def __init__(self, persons, times): \"\"\" :type persons: List[int] :type times: List[int] \"\"\" self.A = [] count = collections.Counter() leader, m = None, 0 for p, t in itertools.izip(persons, times): count[p] += 1 c = count[p] if c &gt;= m: if p != leader: leader = p self.A.append((t, leader)) if c &gt; m: m = c def q(self, t): \"\"\" :type t: int :rtype: int \"\"\" i = bisect.bisect(self.A, (t, float('inf'))) return self.A[i-1][1]# Your TopVotedCandidate object will be instantiated and called as such:# obj = TopVotedCandidate(persons, times)# param_1 = obj.q(t) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;number[]&#125; persons * @param &#123;number[]&#125; times */var TopVotedCandidate = function(persons, times) &#123; const map = &#123;&#125; this.A = [] let m = 0, leader = null;//must set to null, not 0 for (let i = 0; i &lt; persons.length; i++) &#123; const person = persons[i] if (map[person] === undefined) &#123; map[person] = 0 &#125; map[person] = map[person] + 1; if (map[person] &gt;= m) &#123; if (person !== leader) &#123; leader = person this.A.push([times[i], leader]) &#125; if (map[person] &gt; m) &#123; m = map[person] &#125; &#125; &#125;&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */TopVotedCandidate.prototype.q = function(t) &#123; let idx = binarySearch(this.A, t) - 1 return this.A[idx][1]&#125;;//find num &gt; targetconst binarySearch = (nums, target) =&gt; &#123; let left = 0, right = nums.length; while (left &lt; right) &#123; let mid = (right + left) &gt;&gt; 1 if (nums[mid][0] &lt;= target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return right&#125;/** * Your TopVotedCandidate object will be instantiated and called as such: * var obj = new TopVotedCandidate(persons, times) * var param_1 = obj.q(t) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"259. 3Sum Smaller","slug":"259-3Sum-Smaller","date":"2020-09-15T03:11:54.000Z","updated":"2020-09-15T03:12:39.068Z","comments":true,"path":"2020/09/14/259-3Sum-Smaller/","link":"","permalink":"https://jojoyang666.github.io/2020/09/14/259-3Sum-Smaller/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var threeSumSmaller = function(nums, target) &#123; nums.sort((a, b) =&gt; a - b); let sum = 0; for (let i = 0; i &lt; nums.length - 2; i++) &#123; sum += twoSumSmaller(nums, i + 1, target - nums[i]) &#125; return sum&#125;;const twoSumSmaller = (nums, startIndex, target) =&gt; &#123; let sum = 0, left = startIndex, right = nums.length - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] &lt; target) &#123; sum += right - left left++; &#125; else &#123; right--; &#125; &#125; return sum;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"846. Hand of Straights","slug":"846-Hand-of-Straights","date":"2020-09-14T17:08:24.000Z","updated":"2020-09-15T02:28:47.802Z","comments":true,"path":"2020/09/14/846-Hand-of-Straights/","link":"","permalink":"https://jojoyang666.github.io/2020/09/14/846-Hand-of-Straights/","excerpt":"","text":"Greedy 1234567891011121314151617181920class Solution(object): def isNStraightHand(self, hand, W): \"\"\" :type hand: List[int] :type W: int :rtype: bool \"\"\" count = collections.Counter(hand) while count: m = min(count) for k in xrange(m, m + W): v = count[k] if not v: return False if v == 1: del count[k] else: count[k] = v - 1 return True 123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; hand * @param &#123;number&#125; W * @return &#123;boolean&#125; */var isNStraightHand = function(hand, W) &#123; if (hand.length%W) return false hand.sort((a, b) =&gt; a - b) const map = new Map(); for (let card of hand) &#123; if (!map.has(card)) &#123; map.set(card, 0) &#125; map.set(card, map.get(card) + 1) &#125; for (let [key, value] of map) &#123; if (value &gt; 0) &#123; for (let i = key; i &lt; key + W; i++) &#123; if ((map.get(i) || 0) &lt; value) &#123; return false &#125; map.set(i, map.get(i) - value) &#125; &#125; &#125; return true&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1146. Snapshot Array","slug":"1146-Snapshot-Array","date":"2020-09-13T21:35:43.000Z","updated":"2020-09-13T22:23:58.855Z","comments":true,"path":"2020/09/13/1146-Snapshot-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/09/13/1146-Snapshot-Array/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839class SnapshotArray(object): def __init__(self, length): \"\"\" :type length: int \"\"\" self.A = [[[-1, 0]] for _ in xrange(length)] self.snap_id = 0 def set(self, index, val): \"\"\" :type index: int :type val: int :rtype: None \"\"\" self.A[index].append([self.snap_id, val]) def snap(self): \"\"\" :rtype: int \"\"\" self.snap_id += 1 return self.snap_id - 1 def get(self, index, snap_id): \"\"\" :type index: int :type snap_id: int :rtype: int \"\"\" i = bisect.bisect(self.A[index], [snap_id+1])-1 return self.A[index][i][1]# Your SnapshotArray object will be instantiated and called as such:# obj = SnapshotArray(length)# obj.set(index,val)# param_2 = obj.snap()# param_3 = obj.get(index,snap_id) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @param &#123;number&#125; length */var SnapshotArray = function(length) &#123; this.snap_id = 0 this.A = [...new Array(length)].map(() =&gt; [[-1, 0]]) &#125;;/** * @param &#123;number&#125; index * @param &#123;number&#125; val * @return &#123;void&#125; */SnapshotArray.prototype.set = function(index, val) &#123; this.A[index].push([this.snap_id, val])&#125;;/** * @return &#123;number&#125; */SnapshotArray.prototype.snap = function() &#123; this.snap_id += 1 return this.snap_id - 1&#125;;/** * @param &#123;number&#125; index * @param &#123;number&#125; snap_id * @return &#123;number&#125; */SnapshotArray.prototype.get = function(index, snap_id) &#123; let idx = binarySearch(this.A[index], snap_id + 1) - 1// this is becasue there may be multiple times set the value at the same index and snap_id,we need latest one return this.A[index][idx][1]&#125;;/** * Your SnapshotArray object will be instantiated and called as such: * var obj = new SnapshotArray(length) * obj.set(index,val) * var param_2 = obj.snap() * var param_3 = obj.get(index,snap_id) */const binarySearch = (A, value) =&gt; &#123; let left = 0, right = A.length while (left &lt; right) &#123; let mid = (left + right) &gt;&gt; 1; if (A[mid][0] &lt; value) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right&#125;","categories":[],"tags":[]},{"title":"221. Maximal Square","slug":"221-Maximal-Square","date":"2020-09-12T00:33:54.000Z","updated":"2020-09-12T00:34:52.919Z","comments":true,"path":"2020/09/11/221-Maximal-Square/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/221-Maximal-Square/","excerpt":"","text":"Solution 1这种方法的机理就是就是把数组中每一个点都当成正方形的左顶点来向右下方扫描，来寻找最大正方形。具体的扫描方法是，确定了左顶点后，再往下扫的时候，正方形的竖边长度就确定了，只需要找到横边即可，这时候我们使用直方图的原理，从其累加值能反映出上面的值是否全为1 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;character[][]&#125; matrix * @return &#123;number&#125; */var maximalSquare = function(matrix) &#123; let res = 0; for (let i = 0; i &lt; matrix.length; i++) &#123; const v = new Array(matrix[i].length).fill(0) for (let j = i; j &lt; matrix.length; j++) &#123; for (let k = 0; k &lt; matrix[i].length; k++) &#123; if (matrix[j][k] === '1') v[k]++; &#125; res = Math.max(res, getSquareArea(v, j - i + 1)) &#125; &#125; return res;&#125;;const getSquareArea = (v, k) =&gt; &#123; if (v.length &lt; k) return 0; let count = 0; for (let i = 0; i &lt; v.length; i++) &#123; if (v[i] !== k) count = 0 else count++ if (count === k) return k * k &#125; return 0&#125;","categories":[],"tags":[]},{"title":"279. Perfect Squares","slug":"279-Perfect-Squares","date":"2020-09-11T21:54:05.000Z","updated":"2020-09-11T23:44:02.179Z","comments":true,"path":"2020/09/11/279-Perfect-Squares/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/279-Perfect-Squares/","excerpt":"","text":"Solution 1dp 123456789101112131415/** * @param &#123;number&#125; n * @return &#123;number&#125; */var numSquares = function(n) &#123; const dp = new Array(n+1).fill(Number.MAX_VALUE) dp[0] = 0 for (let i = 0; i &lt;= n; i++) &#123; for (let j = 1; j * j + i &lt;= n; j++) &#123; dp[i + j * j] = Math.min(dp[i + j * j], dp[i] + 1) &#125; &#125; return dp[n]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"562. Longest Line of Consecutive One in Matrix","slug":"562-Longest-Line-of-Consecutive-One-in-Matrix","date":"2020-09-11T21:12:53.000Z","updated":"2020-09-11T21:44:33.587Z","comments":true,"path":"2020/09/11/562-Longest-Line-of-Consecutive-One-in-Matrix/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/562-Longest-Line-of-Consecutive-One-in-Matrix/","excerpt":"","text":"Solution 1DP SolutionThree Dimensional dp Array 1234567891011121314151617181920212223242526272829/** * @param &#123;number[][]&#125; M * @return &#123;number&#125; */var longestLine = function(M) &#123; if (!M.length || !M[0].length) return 0; const m = M.length, n = M[0].length const dp = [...new Array(m)].map(item =&gt; [...new Array(n)].map(() =&gt; new Array(4).fill(0))) let res = 0 for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (!M[i][j]) continue; for (let k = 0; k &lt; 4; k++) &#123; dp[i][j][k] = 1 &#125; if (j &gt; 0) dp[i][j][0] += dp[i][j-1][0]//horizontal if (i &gt; 0) dp[i][j][1] += dp[i-1][j][1]//vertical if (i &gt; 0 &amp;&amp; j &lt; n - 1) dp[i][j][2] += dp[i - 1][j + 1][2]; // diagonal if (i &gt; 0 &amp;&amp; j &gt; 0) dp[i][j][3] += dp[i - 1][j - 1][3]; // anti-diagonal res = Math.max(res, Math.max(dp[i][j][0], dp[i][j][1])) res = Math.max(res, Math.max(dp[i][j][2], dp[i][j][3])) &#125; &#125; return res&#125;; Solution2dfs 1234567891011121314151617181920212223242526272829/** * @param &#123;number[][]&#125; M * @return &#123;number&#125; */var longestLine = function(M) &#123; const dirs = [[1, 0], [0, 1], [-1, 1], [-1, -1]] let res = 0; if (!M.length || !M[0].length) return 0; const m = M.length, n = M[0].length for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (M[i][j] == 0) continue; for (const dir of dirs) &#123; let x = i, y = j, cnt = 0; while (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; M[x][y] ===1) &#123; cnt++; x += dir[0] y += dir[1] &#125; res = Math.max(res, cnt) &#125; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"544. Output Contest Matches","slug":"544-Output-Contest-Matches","date":"2020-09-11T20:45:07.000Z","updated":"2020-09-11T20:53:19.313Z","comments":true,"path":"2020/09/11/544-Output-Contest-Matches/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/544-Output-Contest-Matches/","excerpt":"","text":"Solution 1dfs 1234567891011121314151617181920/** * @param &#123;number&#125; n * @return &#123;string&#125; */var findContestMatch = function(n) &#123; const res = [...new Array(n)].map((item, idx) =&gt; idx+1) helper(n, res) return res[0]&#125;;const helper = (n, res) =&gt; &#123; if (n === 1) return; for (let i = 0; i &lt; n; i++) &#123; res[i] = `($&#123;res[i]&#125;,$&#123;res[n-i-1]&#125;)` &#125; return helper(n&gt;&gt;1, res)&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"294. Flip Game II","slug":"294-Flip-Game-II","date":"2020-09-11T19:58:30.000Z","updated":"2020-09-11T20:00:41.444Z","comments":true,"path":"2020/09/11/294-Flip-Game-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/294-Flip-Game-II/","excerpt":"","text":"Solution 112345678910111213/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var canWin = function(s) &#123; for(let i = 1; i &lt; s.length; i++) &#123; if (s.charAt(i) === '+' &amp;&amp; s.charAt(i-1) === '+' &amp;&amp; !canWin(s.substring(0, i-1) + '--' + s.substring(i+1))) &#123; return true; &#125; &#125; return false&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"280. Wiggle Sort","slug":"280-Wiggle-Sort","date":"2020-09-11T16:32:04.000Z","updated":"2020-09-11T16:39:36.875Z","comments":true,"path":"2020/09/11/280-Wiggle-Sort/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/280-Wiggle-Sort/","excerpt":"","text":"Solution 1 Sort + swamp 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var wiggleSort = function(nums) &#123; nums.sort((a, b) =&gt; a - b) const swap = (nums, i, j) =&gt; &#123; let tmp = nums[i] nums[i] = nums[j] nums[j] = tmp &#125; for (let i = 2; i &lt; nums.length; i += 2) &#123; swap(nums, i, i - 1) &#125;&#125;; Solution 2当i为奇数时，nums[i] &gt;= nums[i - 1]当i为偶数时，nums[i] &lt;= nums[i - 1] 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var wiggleSort = function(nums) &#123; const swap = (nums, i, j) =&gt; &#123; let tmp = nums[i] nums[i] = nums[j] nums[j] = tmp &#125; for (let i = 1; i &lt; nums.length; i++) &#123; if((i%2 === 1 &amp;&amp; nums[i] &lt; nums[i-1]) || (i%2 === 0 &amp;&amp; nums[i] &gt; nums[i-1])) &#123; swap(nums, i, i-1) &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1087. Brace Expansion","slug":"1087-Brace-Expansion","date":"2020-09-10T21:03:39.000Z","updated":"2020-09-15T02:28:45.061Z","comments":true,"path":"2020/09/10/1087-Brace-Expansion/","link":"","permalink":"https://jojoyang666.github.io/2020/09/10/1087-Brace-Expansion/","excerpt":"","text":"Solution 1Backtracking 123456789101112131415161718192021class Solution(object): def expand(self, S): \"\"\" :type S: str :rtype: List[str] \"\"\" self.res = [] def helper(s, word): if not s: self.res.append(word) else: if s[0] == '&#123;': i = s.find('&#125;') for letter in s[1:i].split(','): helper(s[i+1:], word + letter) else: helper(s[1:], word + s[0]) helper(S, \"\") self.res.sort() return self.res 1234567891011121314151617181920212223242526/** * @param &#123;string&#125; S * @return &#123;string[]&#125; */var expand = function(S) &#123; const res = [] helper(S, \"\", res) res.sort() return res&#125;;const helper = (s, word, res) =&gt; &#123; if (!s) &#123; res.push(word) return; &#125; if (s.charAt(0) === '&#123;') &#123; let idx = s.indexOf('&#125;') for (let letter of s.substring(1, idx).split(',')) &#123; helper(s.substring(idx + 1), word + letter, res) &#125; &#125; else &#123; helper(s.substring(1), word + s.charAt(0), res) &#125;&#125; Solution 2Python built in method 123456789class Solution(object): def expand(self, S): \"\"\" :type S: str :rtype: List[str] \"\"\" A = S.replace('&#123;', ' ').replace('&#125;', ' ').strip().split(' ') B = [sorted(a.split(',')) for a in A] return [''.join(c) for c in itertools.product(*B)]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"524. Longest Word in Dictionary through Deleting","slug":"524-Longest-Word-in-Dictionary-through-Deleting","date":"2020-09-10T06:05:45.000Z","updated":"2020-09-10T19:50:34.331Z","comments":true,"path":"2020/09/09/524-Longest-Word-in-Dictionary-through-Deleting/","link":"","permalink":"https://jojoyang666.github.io/2020/09/09/524-Longest-Word-in-Dictionary-through-Deleting/","excerpt":"","text":"Solution 1123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @param &#123;string[]&#125; d * @return &#123;string&#125; */var findLongestWord = function(s, d) &#123; let res = \"\" for (let str of d) &#123; let i = 0; for (let c of [...s]) &#123; if (i &lt; str.length &amp;&amp; c === str.charAt(i)) i++; &#125; if (i === str.length &amp;&amp; str.length &gt;= res.length) &#123; if (str.length &gt; res.length || str &lt; res) &#123; res = str &#125; &#125; &#125; return res&#125;; Solution 21234567891011121314151617class Solution(object): def findLongestWord(self, s, d): \"\"\" :type s: str :type d: List[str] :rtype: str \"\"\" heap = [(-len(word), word) for word in d] heapq.heapify(heap) while heap: word = heapq.heappop(heap)[1] it = iter(s) if all(c in it for c in word): return word return '' Solution 3123456789101112class Solution(object): def findLongestWord(self, s, d): \"\"\" :type s: str :type d: List[str] :rtype: str \"\"\" for x in sorted(d, key=lambda x: (-len(x), x)): it = iter(s) if all(c in it for c in x): return x return '' Solution 412345678910111213class Solution(object): def findLongestWord(self, s, d): \"\"\" :type s: str :type d: List[str] :rtype: str \"\"\" def isSubsequence(x): it = iter(s) return all(c in it for c in x) d.sort(key=lambda x : (-len(x), x)) return next(itertools.ifilter(isSubsequence, d), '')","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"777. Swap Adjacent in LR String","slug":"777-Swap-Adjacent-in-LR-String","date":"2020-09-10T03:50:48.000Z","updated":"2020-09-10T05:36:14.938Z","comments":true,"path":"2020/09/09/777-Swap-Adjacent-in-LR-String/","link":"","permalink":"https://jojoyang666.github.io/2020/09/09/777-Swap-Adjacent-in-LR-String/","excerpt":"","text":"Solution 1 一种是把 “XL” 变成 “LX”，另一种是把 “RX” 变成 “XR”。 每次分别找到 start 和 end 中非X的字符，如果二者不相同的话，直接返回 false，想想问什么？这是因为不论是L还是R，其只能跟X交换位置，L和R之间是不能改变相对顺序的，所以如果分别将 start 和 end 中所有的X去掉后的字符串不相等的话，那么就永远无法让 start 和 end 相等了。 这个判断完之后，就来验证L只能前移，R只能后移这个限制条件吧，当i指向 start 中的L时，那么j指向 end 中的L必须要在前面，所以如果i小于j的话，就不对了，同理，当i指向 start 中的R，那么j指向 end 中的R必须在后面，所以i大于j就是错的123456789101112131415161718192021222324252627282930/** * @param &#123;string&#125; start * @param &#123;string&#125; end * @return &#123;boolean&#125; */var canTransform = function(start, end) &#123; let n = start.length, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; while (i &lt; n &amp;&amp; start.charAt(i) === 'X') i++; while (j &lt; n &amp;&amp; end.charAt(j) === 'X') j++; if (start.charAt(i) !== end.charAt(j)) return false; if ((start.charAt(i) === 'L' &amp;&amp; i &lt; j) || (start.charAt(i) === 'R' &amp;&amp; i &gt; j)) return false; i++; j++; &#125; while (i &lt; n) &#123; if (start.charAt(i) !== 'X') return false; i++; &#125; while (j &lt; n) &#123; if (end.charAt(j) !== 'X') return false j++ &#125; return true&#125;; Solution 2 ，这里使用两个计数器 cntL 和 cntR，分别来统计L和R出现的次数，统计方法时，start 中出现了L或R，计数器自增1，end 中出现了L或R，计数器自减1。 注意检测的顺序很重要，由于 start 中的R必须在 end 中的R前面，所以要先检测 start 中的R，同理，由于 end 中的L必须要在 start 中的L前面，所以要先检测 end 中的L，那么四个 if 写完后，如果 cntL 或者 cntR 中有任何一个小于0了，说明限制条件被打破了，返回 false，或者当二者都大于0的时候，说明此时不匹配了，参见上面解法中对于去掉所有的X的解释，一个道理，说明L和R的相对顺序不同了，那么也是 false。最终 for 循环退出后，如果 cntL 和 cntR 均为0的时候，才返回 true，否则就是 false，参见代码如下：1234567891011121314151617181920212223/** * @param &#123;string&#125; start * @param &#123;string&#125; end * @return &#123;boolean&#125; */var canTransform = function(start, end) &#123; let len = start.length, cntL = 0, cntR = 0; for (let i = 0; i &lt; len; i++) &#123; if (start.charAt(i) === 'R') cntR++; if (end.charAt(i) === 'L') cntL++; if (cntL * cntR !== 0) return false if (end.charAt(i) === 'R') cntR--; if (start.charAt(i) === 'L') cntL--; if (cntL &lt; 0 || cntR &lt; 0) return false &#125; return cntL === 0 &amp;&amp; cntR === 0&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1055. Shortest Way to Form String","slug":"1055-Shortest-Way-to-Form-String","date":"2020-09-07T00:21:20.000Z","updated":"2020-09-09T04:27:14.281Z","comments":true,"path":"2020/09/06/1055-Shortest-Way-to-Form-String/","link":"","permalink":"https://jojoyang666.github.io/2020/09/06/1055-Shortest-Way-to-Form-String/","excerpt":"","text":"Solution 1 Greedy123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; const map = new Array(26).fill(false) for (let i = 0; i &lt; source.length; i++) &#123; map[source.charCodeAt(i) - 97] = true; &#125; let j = 0, res = 1 for (let i = 0; i &lt; target.length; i++, j++) &#123; if (!map[target.charCodeAt(i) - 97]) &#123; return -1; &#125; while (j &lt; source.length &amp;&amp; target.charAt(i) !== source.charAt(j)) &#123; j++ &#125; if (j &gt;= source.length) &#123; j = -1 res++; i-- &#125; &#125; return res&#125;; Solution2/Follow up1 Can you implement it with O(1) space, which means whithout set –&gt; iterate src completely, it j not move, then we can return -1 12345678910111213141516171819202122232425/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; let res = 0; for (let i = 0; i &lt; target.length; ) &#123; let OriI = i; for (let j = 0; j &lt; source.length; j++) &#123; if (source.charAt(j) === target.charAt(i)) &#123; i++; &#125; &#125; if (i === OriI) &#123; return -1; &#125; res++; &#125; return res;&#125;; Solution 3/Follow up2 what’s the time complexity for above solutions. O(MN). could u make it better?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; const idx = [...new Array(26)].map(item =&gt; []) let res = 1; for (let i = 0; i &lt; source.length; i++) &#123; idx[source.charCodeAt(i) - 97].push(i) &#125; let j = 0 for (let i = 0; i &lt; target.length; ) &#123; const tar = idx[target.charCodeAt(i) - 97] if (!tar.length) return -1; let k = find(tar, j) if (k === tar.length) &#123; res++; j = 0; &#125; else &#123; j = tar[k] + 1 i++ &#125; &#125; return res;&#125;;const find = (nums, target) =&gt; &#123; let left = 0, right = nums.length; while (left &lt; right) &#123; let mid = (left + right) &gt;&gt; 1; if(nums[mid] &lt; target ) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return right;&#125; Solution 4 / Follow Up 3 could u improve it more?in binary search solution we will have a map like a -&gt;{1,3,7,16} (total src length is 20), so we need binary search.if we can flatten them, i mean for each pos in 20 length, we just save the next idx, we can use O 1 to find the next J.a -&gt; {1,1,3,3,7,7,7,7,16,16,16,16,16,16,16,16,16,0,0,0} 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; const len = source.length; const idx = [...new Array(26)].map(() =&gt; new Array(len).fill(0)) //idx[i][j]: i所代表的char, 在source的j位置， 他的下一个位置是j+1 for (let i = 0; i &lt; len; i++) &#123; idx[source.charCodeAt(i) - 97][i] = i + 1 &#125; for (let i = 0; i &lt; 26; i++) &#123; for (let j = source.length - 1, pre = 0; j &gt;= 0; j--) &#123; if (!idx[i][j]) &#123; idx[i][j] = pre; // source 在 j-1位置， 没有i所代表的字符 &#125; else &#123; pre = idx[i][j] &#125; &#125; &#125; let res = 1, j = 0; for (let i = 0; i &lt; target.length; i++) &#123; if (j === len) &#123; j = 0; res++; &#125; if (!idx[target.charCodeAt(i) - 97][0]) return -1; j = idx[target.charCodeAt(i) - 97][j] if (j === 0) &#123; res++; //在这个位置找不到next pos which &gt; j所以source++ i--; &#125; &#125; return res&#125;; Solution 5 / Follow Up 4 could u improve it more? if we assume which can copy a array to another array with 26 length in constant time. could u implement it with O(M + N)12345678910111213141516171819202122232425262728293031323334/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; const len = source.length; const idx = [...new Array(len)].map(() =&gt; new Array(26).fill(0)) idx[len-1][source.charCodeAt(len-1) - 97] = len for (let i = len - 2; i &gt;= 0; i--) &#123; idx[i] = [...idx[i+1]] idx[i][source.charCodeAt(i) - 97] = i + 1 &#125; let j = 0, res = 1 for (let i = 0; i &lt; target.length; i++) &#123; if (j === len) &#123; j = 0; res++; &#125; j = idx[j][target.charCodeAt(i) - 97] if (!idx[0][target.charCodeAt(i) - 97]) return -1; if (!j) &#123; res++; i--; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"289. Game of Life","slug":"289-Game-of-Life","date":"2020-09-04T17:14:42.000Z","updated":"2020-09-04T18:45:36.500Z","comments":true,"path":"2020/09/04/289-Game-of-Life/","link":"","permalink":"https://jojoyang666.github.io/2020/09/04/289-Game-of-Life/","excerpt":"","text":"Solution 1 -&gt; constant space 状态机 Code12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;number[][]&#125; board * @return &#123;void&#125; Do not return anything, modify board in-place instead. */var gameOfLife = function(board) &#123; const neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]] for (let row = 0; row &lt; board.length; row++) &#123; for (let col = 0; col &lt; board[row].length; col++) &#123; let live_count = 0 for (let nei of neighbors) &#123; const r = row + nei[0] const c = col + nei[1] if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; board.length &amp;&amp; c &lt; board[row].length &amp;&amp; (board[r][c] === 1 || board[r][c] === 2)) &#123; live_count++; &#125; &#125; if (board[row][col] === 1 &amp;&amp; (live_count &lt; 2 || live_count &gt; 3)) &#123; board[row][col] = 2 &#125; else if (board[row][col] === 0 &amp;&amp; (live_count === 3)) &#123; board[row][col] = 3 &#125; &#125; &#125; for (let row = 0; row &lt; board.length; row++) &#123; for (let col = 0; col &lt; board[row].length; col++) &#123; board[row][col] %= 2 &#125; &#125; return board&#125;; Solution 2Infinite Board 1234567891011121314151617class Solution(object): def gameOfLifeInfinite(self, live): ctr = collections.Counter((I, J) for i, j in live for I in range(i-1, i+2) for J in range(j-1, j+2) if I != i or J != j) return &#123;ij for ij in ctr if ctr[ij] == 3 or ctr[ij] == 2 and ij in live&#125; def gameOfLife(self, board): \"\"\" :type board: List[List[int]] :rtype: None Do not return anything, modify board in-place instead. \"\"\" live = &#123;(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live&#125; live = self.gameOfLifeInfinite(live) for i, row in enumerate(board): for j in range(len(row)): row[j] = int((i, j) in live)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1110. Delete Nodes And Return Forest","slug":"1110-Delete-Nodes-And-Return-Forest","date":"2020-09-03T22:06:01.000Z","updated":"2020-09-03T22:16:51.257Z","comments":true,"path":"2020/09/03/1110-Delete-Nodes-And-Return-Forest/","link":"","permalink":"https://jojoyang666.github.io/2020/09/03/1110-Delete-Nodes-And-Return-Forest/","excerpt":"","text":"123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def delNodes(self, root, to_delete): \"\"\" :type root: TreeNode :type to_delete: List[int] :rtype: List[TreeNode] \"\"\" to_delete_set = set(to_delete) res = [] def helper(root, is_root): if not root: return None root_deleted = root.val in to_delete_set if is_root and not root_deleted: res.append(root) root.left = helper(root.left, root_deleted) root.right = helper(root.right, root_deleted) return root if not root_deleted else None helper(root, True) return res 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number[]&#125; to_delete * @return &#123;TreeNode[]&#125; */var delNodes = function(root, to_delete) &#123; const res = [] helper(root, true, new Set(to_delete), res) return res&#125;;const helper = (root, is_root, to_delete, res) =&gt; &#123; if (!root) &#123; return null; &#125; const if_deleted = to_delete.has(root.val) if (is_root &amp;&amp; !if_deleted) &#123; res.push(root) &#125; root.left = helper(root.left, if_deleted, to_delete, res) root.right = helper(root.right, if_deleted, to_delete, res) return if_deleted ? null : root;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"809. Expressive Words","slug":"809-Expressive-Words","date":"2020-09-03T21:10:22.000Z","updated":"2020-09-03T21:44:11.508Z","comments":true,"path":"2020/09/03/809-Expressive-Words/","link":"","permalink":"https://jojoyang666.github.io/2020/09/03/809-Expressive-Words/","excerpt":"","text":"Solution 112345678910111213141516class Solution(object): def expressiveWords(self, S, words): def RLE(S): return zip(*[(k, len(list(grp))) for k, grp in itertools.groupby(S)]) if not S: return 0 R, count = RLE(S) ans = 0 for word in words: R2, count2 = RLE(word) if R2 != R: continue ans += all(c1 &gt;= max(c2, 3) or c1 == c2 for c1, c2 in zip(count, count2)) return ans explain: 12zip(*[(k, len(list(grp))) for k, grp in itertools.groupby(S)]) S = “heeellooo” result: [(‘h’, ‘e’, ‘l’, ‘o’), (1, 3, 2, 3)] Solution21234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; S * @param &#123;string[]&#125; words * @return &#123;number&#125; */var expressiveWords = function(S, words) &#123; const m = S.length let res = 0 for (const word of words) &#123; let i = 0, j = 0; for (; i &lt; m; i++) &#123; if (j &lt; word.length &amp;&amp; S.charAt(i) === word.charAt(j)) &#123; j++ &#125; else if (i &gt; 0 &amp;&amp; i + 1 &lt; m &amp;&amp; S.charAt(i-1) === S.charAt(i) &amp;&amp; S.charAt(i) === S.charAt(i+1)) &#123; i++; &#125; else if ( !(i &gt; 1 &amp;&amp; S.charAt(i-2) === S.charAt(i) &amp;&amp; S.charAt(i-1) === S.charAt(i))) &#123; break &#125; &#125; if (i === m &amp;&amp; j === word.length) &#123; res++; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Graph","slug":"Graph","date":"2020-09-03T19:51:10.000Z","updated":"2020-09-03T19:52:10.252Z","comments":true,"path":"2020/09/03/Graph/","link":"","permalink":"https://jojoyang666.github.io/2020/09/03/Graph/","excerpt":"","text":"Coming from 737. Sentence Similarity II123456789101112131415161718192021222324252627282930class Solution(object): def areSentencesSimilarTwo(self, words1, words2, pairs): \"\"\" :type words1: List[str] :type words2: List[str] :type pairs: List[List[str]] :rtype: bool \"\"\" if len(words1) != len(words2): return False graph = collections.defaultdict(list) for w1, w2 in pairs: graph[w1].append(w2) graph[w2].append(w1) for w1, w2 in zip(words1, words2): stack, seen = [w1], &#123;w1&#125; while stack: word = stack.pop() if word == w2: break for nei in graph[word]: if nei not in seen: seen.add(nei) stack.append(nei) else: return False return True","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"UNION FIND","slug":"UNION-FIND","date":"2020-09-03T18:38:26.000Z","updated":"2020-09-03T19:30:49.800Z","comments":true,"path":"2020/09/03/UNION-FIND/","link":"","permalink":"https://jojoyang666.github.io/2020/09/03/UNION-FIND/","excerpt":"","text":"1234567891011class DSU: def __init__(self, N): self.parent = range(N) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): self.parent[self.find(x)] = self.find(y) 1234567891011121314151617181920212223242526272829303132const UnionFind = (N) =&gt; &#123; const parent = [...new Array(N)].map((ele, index) =&gt; index) const find = (x) =&gt; &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]) &#125; return parent[x]; &#125; const union = (x, y) =&gt; &#123; parent[find(x)] = find(y) &#125; const unionWithRank = (x, y) =&gt; &#123; let xr = find(x), yr = find(y) if (xr !== yr) &#123; if (rank[xr] &lt; rank[yr]) &#123; parent[xr] = yr &#125; else if (rank[xr] &gt; rank[yr]) &#123; parent[yr] = xr &#125; else &#123; parent[yr] = xr rank[xr]++ &#125; &#125; &#125; return &#123;find, union&#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"737. Sentence Similarity II","slug":"737-Sentence-Similarity-II","date":"2020-09-03T03:27:11.000Z","updated":"2020-09-03T20:05:09.641Z","comments":true,"path":"2020/09/02/737-Sentence-Similarity-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/02/737-Sentence-Similarity-II/","excerpt":"","text":"Solution 1Union Find 12345678910111213141516171819202122232425262728293031323334class Solution(object): def areSentencesSimilarTwo(self, words1, words2, pairs): \"\"\" :type words1: List[str] :type words2: List[str] :type pairs: List[List[str]] :rtype: bool \"\"\" if len(words1) != len(words2): return False index = &#123;&#125; count = itertools.count() dsu = DSU(2 * len(pairs)) for pair in pairs: for p in pair: if p not in index: index[p] = next(count) dsu.union(index[pair[0]], index[pair[1]]) return all(w1 == w2 or w1 in index and w2 in index and dsu.find(index[w1]) == dsu.find(index[w2]) for w1, w2 in zip(words1, words2)) class DSU: def __init__(self, N): self.parent = range(N) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): self.parent[self.find(x)] = self.find(y) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @param &#123;string[]&#125; words1 * @param &#123;string[]&#125; words2 * @param &#123;string[][]&#125; pairs * @return &#123;boolean&#125; */var areSentencesSimilarTwo = function(words1, words2, pairs) &#123; if (words1.length !== words2.length) return false; const UF = UnionFind(2 * pairs.length) const map = &#123;&#125; let idx = 0 for (let pair of pairs) &#123; for (let p of pair) &#123; if (map[p] === undefined) map[p] = idx++; &#125; UF.union(map[pair[0]], map[pair[1]]) &#125; for (let i = 0; i &lt; words1.length; i++) &#123; const w1 = words1[i], w2 = words2[i] if (w1 !== w2) &#123; if (map[w1] === undefined || map[w2] === undefined || UF.find(map[w1]) !== UF.find(map[w2])) &#123; return false; &#125; &#125; &#125; return true&#125;; const UnionFind = (N) =&gt; &#123; const parent = [...new Array(N)].map((ele, index) =&gt; index) const rank = new Array(N).fill(0) const find = (x) =&gt; &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]) &#125; return parent[x]; &#125; const union = (x, y) =&gt; &#123; let xr = find(x), yr = find(y) if (xr !== yr) &#123; if (rank[xr] &lt; rank[yr]) &#123; parent[xr] = yr &#125; else if (rank[xr] &gt; rank[yr]) &#123; parent[yr] = xr &#125; else &#123; parent[yr] = xr rank[xr]++ &#125; &#125; &#125; return &#123;find, union&#125;&#125; Solution 2DFS/graph 123456789101112131415161718192021222324252627282930class Solution(object): def areSentencesSimilarTwo(self, words1, words2, pairs): \"\"\" :type words1: List[str] :type words2: List[str] :type pairs: List[List[str]] :rtype: bool \"\"\" if len(words1) != len(words2): return False graph = collections.defaultdict(list) for w1, w2 in pairs: graph[w1].append(w2) graph[w2].append(w1) for w1, w2 in zip(words1, words2): stack, seen = [w1], &#123;w1&#125; while stack: word = stack.pop() if word == w2: break for nei in graph[word]: if nei not in seen: seen.add(nei) stack.append(nei) else: return False return True 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @param &#123;string[]&#125; words1 * @param &#123;string[]&#125; words2 * @param &#123;string[][]&#125; pairs * @return &#123;boolean&#125; */var areSentencesSimilarTwo = function(words1, words2, pairs) &#123; if (words1.length !== words2.length) return false; const graph = &#123;&#125; for (const [w1, w2] of pairs) &#123; if (graph[w1] === undefined) graph[w1] = [] if (graph[w2] === undefined) graph[w2] = [] graph[w1].push(w2) graph[w2].push(w1) &#125; for (let i = 0; i &lt; words1.length; i++) &#123; const w1 = words1[i], w2 = words2[i] const stack = [w1], seen = new Set([w1]) let find = false while (stack.length &gt; 0) &#123; const word = stack.pop() if (word === w2) &#123; find = true break &#125; if (graph[word]) &#123;// checking if existence for(const nei of graph[word]) &#123; if (!seen.has(nei)) &#123; seen.add(nei) stack.push(nei) &#125; &#125; &#125; &#125; if (!find) &#123; return false &#125; &#125; return true&#125;;","categories":[],"tags":[]},{"title":"351. Android Unlock Patterns","slug":"351-Android-Unlock-Patterns","date":"2020-09-02T15:36:10.000Z","updated":"2020-09-02T19:38:28.651Z","comments":true,"path":"2020/09/02/351-Android-Unlock-Patterns/","link":"","permalink":"https://jojoyang666.github.io/2020/09/02/351-Android-Unlock-Patterns/","excerpt":"","text":"Solution 112345678910111213141516171819202122232425262728293031323334class Solution(object): def numberOfPatterns(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" skip = &#123;&#125; skip[(1,7)] = 4 skip[(1,3)] = 2 skip[(1,9)] = 5 skip[(2,8)] = 5 skip[(3,7)] = 5 skip[(3,9)] = 6 skip[(4,6)] = 5 skip[(7,9)] = 8 self.res = 0 def dfs(used, last): if len(used) &gt;= m: self.res += 1 if len(used) &gt;= n: return for j in range(1, 10): if j not in used: edge = (min(j, last), max(j, last)) if edge not in skip or skip[edge] in used: dfs(used + [j], j) for i in range(1, 10): dfs([i], i) return self.res 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var numberOfPatterns = function(m, n) &#123; let res = 0 const skip = &#123;&#125; skip[\"1 -&gt; 7\"] = 4 skip[\"1 -&gt; 3\"] = 2 skip[\"1 -&gt; 9\"] = 5 skip[\"2 -&gt; 8\"] = 5 skip[\"3 -&gt; 7\"] = 5 skip[\"3 -&gt; 9\"] = 6 skip[\"4 -&gt; 6\"] = 5 skip[\"7 -&gt; 9\"] = 8 const dfs = (used, last) =&gt; &#123; if (used.size &gt;= m) &#123; res += 1 &#125; if (used.size &gt;= n) &#123; return &#125; for (let i = 1; i &lt;= 9; i++) &#123; if (!used.has(i)) &#123; edge = Math.min(i, last) + \" -&gt; \" + Math.max(i, last) if (!skip[edge] || used.has(skip[edge])) &#123; used.add(i) dfs(used, i) used.delete(i) &#125; &#125; &#125; &#125; for (let i = 1; i &lt;= 9; i++) &#123; const used = new Set() used.add(i) dfs(used, i) &#125; return res&#125;; Notes: Backtrack after comeback from the dfs, never forget to remove value from the set Solution 2 Idea: used 是一个9位的 mask，每位对应一个数字，如果为1表示存在，0表示不存在 (i1, j1) 是之前的位置，(i, j) 是当前的位置，所以滑动是从 (i1, j1) 到 (i, j) 中间点为 ((i1+i)/2, (j1+j)/2)，这里的I和J分别为 i1+i 和 j1+j，还没有除以2，所以I和J都是整数 如果 I%2 或者 J%2 不为0，说明中间点的坐标不是整数，即中间点不存在，如果中间点存在，如果中间点被使用了，则这条线也是成立的，可以调用递归1234567891011121314151617181920212223class Solution(object): def numberOfPatterns(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" return self.count(m, n, 0, 1, 1) def count(self, m, n, used, i1, j1): res = int(m &lt;= 0) if n &lt;= 0: return 1; for i in range(3): for j in range(3): I, J, used2 = i1 + i, j1 + j, used | (1 &lt;&lt; (i * 3 + j)) if used2 &gt; used and (I%2 == 1 or J%2 == 1 or used2 &amp; (1 &lt;&lt; (I/2 * 3 + J/2))): res += self.count(m - 1, n - 1, used2, i, j) return res *Notes: There is no logical operator(|| / ! / &amp;&amp;) in python, using (or / not / and) instead * 1234567891011121314151617181920212223242526272829/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var numberOfPatterns = function(m, n) &#123; return count(m, n, 0, 1, 1)&#125;;const count = (m, n, used, i1, j1) =&gt; &#123; let res = m &lt;= 0 ? 1 : 0; if (n &lt;= 0) &#123; return 1; &#125; for (let i = 0; i &lt; 3; i++) &#123; for (let j = 0; j &lt; 3; j++) &#123; const I = i1 + i, J = j1 + j, used2 = used | (1 &lt;&lt; (i * 3 + j)) if (used2 &gt; used &amp;&amp; (I % 2 || J % 2 || used2 &amp; (1 &lt;&lt; Math.floor((I/2) * 3 + Math.floor(J/2))))) &#123; res += count(m-1, n-1, used2, i, j) &#125; &#125; &#125; return res&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"686. Repeated String Match","slug":"686-Repeated-String-Match","date":"2020-09-01T22:49:44.000Z","updated":"2020-09-01T22:50:33.802Z","comments":true,"path":"2020/09/01/686-Repeated-String-Match/","link":"","permalink":"https://jojoyang666.github.io/2020/09/01/686-Repeated-String-Match/","excerpt":"","text":"12345const repeatedStringMatch = (A, B) =&gt; &#123; const count = Math.ceil(B.length / A.length) const str = A.repeat(count) return str.includes(B) ? count : (str + A).includes(B) ? count + 1 : -1 &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"947. Most Stones Removed with Same Row or Column","slug":"947-Most-Stones-Removed-with-Same-Row-or-Column","date":"2020-09-01T22:02:02.000Z","updated":"2020-09-01T22:03:15.342Z","comments":true,"path":"2020/09/01/947-Most-Stones-Removed-with-Same-Row-or-Column/","link":"","permalink":"https://jojoyang666.github.io/2020/09/01/947-Most-Stones-Removed-with-Same-Row-or-Column/","excerpt":"","text":"Solution 112345678910111213141516171819202122232425262728293031323334class Solution(object): def removeStones(self, stones): \"\"\" :type stones: List[List[int]] :rtype: int \"\"\" graph = collections.defaultdict(list) for i, x in enumerate(stones): for j in xrange(i): y = stones[j] if x[0] == y[0] or x[1] == y[1]: graph[i].append(j) graph[j].append(i) N = len(stones) ans = 0 seen = [False] * N for i in xrange(N): if not seen[i]: stack = [i] seen[i] = True while stack: ans += 1 node = stack.pop() for nei in graph[node]: if not seen[nei]: stack.append(nei) seen[nei] = True ans -= 1 return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"228. Summary Ranges","slug":"228-Summary-Ranges","date":"2020-09-01T21:51:35.000Z","updated":"2020-09-01T21:59:49.255Z","comments":true,"path":"2020/09/01/228-Summary-Ranges/","link":"","permalink":"https://jojoyang666.github.io/2020/09/01/228-Summary-Ranges/","excerpt":"","text":"Solution123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums * @return &#123;string[]&#125; */var summaryRanges = function(nums) &#123; let i = 0; const res = [] while (i &lt; nums.length) &#123; let diff = 0; while (i + diff &lt; nums.length &amp;&amp; nums[i+diff] - nums[i] === diff) diff++; if (diff &lt;= 1) &#123; res.push(nums[i]+\"\") &#125; else &#123; res.push(`$&#123;nums[i]&#125;-&gt;$&#123;nums[i+diff-1]&#125;`) &#125; i += diff; &#125; return res;&#125;; 对于连续/sorted的问题： 可以考虑用diff","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"904. Fruit Into Baskets","slug":"904-Fruit-Into-Baskets","date":"2020-09-01T17:48:14.000Z","updated":"2020-09-01T21:50:03.863Z","comments":true,"path":"2020/09/01/904-Fruit-Into-Baskets/","link":"","permalink":"https://jojoyang666.github.io/2020/09/01/904-Fruit-Into-Baskets/","excerpt":"","text":"Solution 11234567891011121314151617class Solution(object): def totalFruit(self, tree): \"\"\" :type tree: List[int] :rtype: int \"\"\" ans = i = 0 count = collections.Counter() for j, x in enumerate(tree): count[x] += 1 while len(count) &gt;= 3: count[tree[i]] -= 1 if count[tree[i]] == 0: del count[tree[i]] i += 1 ans = max(ans, j - i + 1) return ans collections.Counter(): dict subclass for counting hashable objects123456789101112131415161718var totalFruit = function(tree) &#123; let ans = 0, left = 0; let map = &#123;&#125; for (let i = 0; i &lt; tree.length; i++) &#123; map[tree[i]] = map[tree[i]] === undefined ? 1 : map[tree[i]] + 1 while (Object.keys(map).length &gt;= 3) &#123; map[tree[left]] -= 1 if (map[tree[left]] === 0) &#123; delete map[tree[left]] &#125; left++; &#125; ans = Math.max(i-left+1, ans) &#125; return ans&#125;; Javascript: undefined + ==&gt; NAN","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"939. Minimum Area Rectangle","slug":"939-Minimum-Area-Rectangle","date":"2020-08-28T22:39:09.000Z","updated":"2020-09-14T17:09:36.583Z","comments":true,"path":"2020/08/28/939-Minimum-Area-Rectangle/","link":"","permalink":"https://jojoyang666.github.io/2020/08/28/939-Minimum-Area-Rectangle/","excerpt":"","text":"Solution 1 Sorted by column12345678910111213141516171819202122class Solution(object): def minAreaRect(self, points): \"\"\" :type points: List[List[int]] :rtype: int \"\"\" columns = collections.defaultdict(list) for x, y in points: columns[x].append(y) lastx = &#123;&#125; ans = float('inf') for x in sorted(columns): column = columns[x] column.sort() for j, y2 in enumerate(column): for i in xrange(j): y1 = column[i] if (y1, y2) in lastx: ans = min(ans, (x - lastx[y1, y2]) * (y2 - y1)) lastx[y1, y2] = x return ans if ans &lt; float('inf') else 0 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;number[][]&#125; points * @return &#123;number&#125; */var minAreaRect = function(points) &#123; const columns = &#123;&#125; for (let [x,y] of points) &#123; if (!columns.hasOwnProperty(x)) &#123; columns[x] = [] &#125; columns[x].push(y) &#125; const keys = Object.keys(columns).sort((x, y) =&gt; x - y) let ans = Number.MAX_VALUE let lastx = &#123;&#125; for (let x of keys) &#123; const column = columns[x] column.sort((x, y) =&gt; x-y) for (let i = 0; i &lt; column.length; i++) &#123; let y2 = column[i]; for (let j = 0; j &lt; i; j++) &#123; let y1 = column[j]; const pair = `$&#123;y1&#125;#$&#123;y2&#125;` if (lastx.hasOwnProperty(pair)) &#123; ans = Math.min(ans, (x - lastx[pair]) * (y2 - y1)) &#125; lastx[pair] = x &#125; &#125; &#125; return ans === Number.MAX_VALUE ? 0 : ans&#125;; Note: In javascript, if want to sort a number array, it must be array.sort((x, y) =&gt; x - y), it must have function Solution 2 Sort by diagonal if the points are (1, 1) and (5, 5), we check if we also have (1, 5) and (5, 1). If we do, we have a candidate rectangle.123456789101112131415class Solution(object): def minAreaRect(self, points): \"\"\" :type points: List[List[int]] :rtype: int \"\"\" S = set(map(tuple, points)) ans = float('inf') for j, p2 in enumerate(points): for i in xrange(j): p1 = points[i] if (p1[0] != p2[0] and p1[1] != p2[1] and (p1[0], p2[1]) in S and (p2[0], p1[1]) in S): ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1])) return ans if ans &lt; float('inf') else 0 1234567891011121314151617181920const minAreaRect = (points) =&gt; &#123; const map = new Map(); for (const [x, y] of points) &#123; if (!map.has(x)) map.set(x, new Set()); map.get(x).add(y); &#125; let min = Infinity; for (const [x1, y1] of points) &#123; for (const [x2, y2] of points) &#123; if (x1 === x2 || y1 === y2) continue; // Find other two diagonal points if (map.get(x1).has(y2) &amp;&amp; map.get(x2).has(y1)) &#123; min = Math.min(min, Math.abs(x1 - x2) * Math.abs(y1 - y2)); &#125; &#125; &#125; return min === Infinity ? 0 : min;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"288. Unique Word Abbreviation","slug":"288-Unique-Word-Abbreviation-exiyexit","date":"2020-08-19T23:43:36.000Z","updated":"2020-08-19T23:44:50.859Z","comments":true,"path":"2020/08/19/288-Unique-Word-Abbreviation-exiyexit/","link":"","permalink":"https://jojoyang666.github.io/2020/08/19/288-Unique-Word-Abbreviation-exiyexit/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;string[]&#125; dictionary */var ValidWordAbbr = function(dictionary) &#123; this.map = &#123;&#125; this.set = new Set(dictionary) for (let word of this.set) &#123; let abbr = toAbbr(word) this.map[abbr] = this.map[abbr] === undefined ? true : false &#125;&#125;;/** * @param &#123;string&#125; word * @return &#123;boolean&#125; */ValidWordAbbr.prototype.isUnique = function(word) &#123; let abbr = toAbbr(word) let hasAbbr = this.map[abbr] return hasAbbr === undefined || (hasAbbr &amp;&amp; this.set.has(word))&#125;;/** * Your ValidWordAbbr object will be instantiated and called as such: * var obj = new ValidWordAbbr(dictionary) * var param_1 = obj.isUnique(word) */const toAbbr = (s) =&gt; &#123; if ( !s || s.length &lt;= 2) &#123; return s; &#125; return s.charAt(0) + (s.length - 2) + s.charAt(s.length - 1);&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Difference Among Unicode, ASCII, and UTF-8","slug":"Difference-Among-Unicode-ASCII-and-UTF-8","date":"2020-08-19T17:24:06.000Z","updated":"2020-08-19T19:00:58.458Z","comments":true,"path":"2020/08/19/Difference-Among-Unicode-ASCII-and-UTF-8/","link":"","permalink":"https://jojoyang666.github.io/2020/08/19/Difference-Among-Unicode-ASCII-and-UTF-8/","excerpt":"","text":"ASCII ASCII码使用指定的7位或8位二进制数组合来表示128/256种可能的字符 ASCII是单字节编码（1 byte = 8 bits）， 无法用来表示中文（中文编码至少需要2个字节） Unicode ASCII编码 是1个字节， 而Unicode编码通常是2个字节 UTF8 把Unicode编码转化为可变长编码的UTF-8编码 UTF-8把一个Unicode字符根据不同的数字大小编码成1-6个字节， 常用的英文字母被编码成一个字节， 汉字通常是3个字节。 如果要传输的文本包含大量的英文字符， 用UTF-8就能节省空间 ASCII编码实际上可以被看作是UTF-8的一部分， 所以大量支持ASCII编码的历史遗留软件可以再UTF-8编码下继续工作 计算机中通用的字符编码的工作方式 在计算机内存中， 统一使用Unicode编码， 当需要保存到硬盘或者需要传输的时候， 就转换为UTF-8编码 在用记事本编辑的时候， 从文本读取的UTF-8字符被转换为Unicode字符的内存里，编辑完成后， 保存的时候再把Unicode转换为UTF-8保存带文件里 浏览网页的时候， 服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器","categories":[],"tags":[]},{"title":"271. Encode and Decode Strings","slug":"271-Encode-and-Decode-Strings","date":"2020-08-19T05:10:30.000Z","updated":"2020-08-19T22:11:38.613Z","comments":true,"path":"2020/08/18/271-Encode-and-Decode-Strings/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/271-Encode-and-Decode-Strings/","excerpt":"","text":"Solution 1123456789101112131415161718192021222324252627class Codec: def encode(self, strs): \"\"\"Encodes a list of strings to a single string. :type strs: List[str] :rtype: str \"\"\" if len(strs) == 0: return unichr(258) return unichr(257).join(x.encode('utf-8') for x in strs) def decode(self, s): \"\"\"Decodes a single string to a list of strings. :type s: str :rtype: List[str] \"\"\" if s == unichr(258): return [] return s.split(unichr(257)) # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(strs)) 123456789101112131415161718192021222324252627282930/** * Encodes a list of strings to a single string. * * @param &#123;string[]&#125; strs * @return &#123;string&#125; */var encode = function(strs) &#123; if (!strs || !strs.length) return String.fromCharCode(258) return strs.join(String.fromCharCode(257))&#125;;/** * Decodes a single string to a list of strings. * * @param &#123;string&#125; s * @return &#123;string[]&#125; */var decode = function(s) &#123; if (s === String.fromCharCode(258)) return [] return s.split(String.fromCharCode(257))&#125;;/** * Your functions will be called as such: * decode(encode(strs)); */ Solution 2 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Codec: def len_to_str(self, x): \"\"\" Encode length of string to bytes string \"\"\" x = len(x) bytes = [chr(x &gt;&gt; (i * 8) &amp; 0xff) for i in range(4)] bytes.reverse() bytes_str = ''.join(bytes) return bytes_str def encode(self, strs): \"\"\"Encodes a list of strings to a single string. :type strs: List[str] :rtype: str \"\"\" return ''.join(self.len_to_str(x) + x.encode('utf-8') for x in strs) def str_to_int(self, bytes_str): result = 0 for ch in bytes_str: result = result * 256 + ord(ch) return result def decode(self, s): \"\"\"Decodes a single string to a list of strings. :type s: str :rtype: List[str] \"\"\" i, n = 0, len(s) output = [] while i &lt; n: length = self.str_to_int(s[i: i + 4]) i += 4 output.append(s[i: i + length]) i += length return output# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(strs)) TroubleShooting Understanding bytes = [chr(x &gt;&gt; (i * 8) &amp; 0xff) for i in range(4)] need to do is encode the length of x into 4 bytes(why 4 bytes - integer size - 4 bytes = [8bits, 8 bits, 8bits, 8bits]) if &amp; any number with 0xff, will give the right most 8 bits of the number example","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"298. Binary Tree Longest Consecutive Sequence","slug":"298-Binary-Tree-Longest-Consecutive-Sequence","date":"2020-08-18T23:11:47.000Z","updated":"2020-08-18T23:45:24.666Z","comments":true,"path":"2020/08/18/298-Binary-Tree-Longest-Consecutive-Sequence/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/298-Binary-Tree-Longest-Consecutive-Sequence/","excerpt":"","text":"Solution 1Recursion one 12345678910111213141516171819202122/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var longestConsecutive = function(root) &#123; return helper(root, null, 0)&#125;;const helper = (root, p, res) =&gt; &#123; if (!root) return res; res = (p &amp;&amp; root.val === p.val + 1) ? res + 1 : 1; return Math.max(res, Math.max(helper(root.left, root, res), helper(root.right, root, res)))&#125; Solution 2Iterative one 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var longestConsecutive = function(root) &#123; if (!root) return 0; let res = 0; const q = [] q.push(root) while (q.length) &#123; let len = 1; let node = q.shift(); while ((node.left &amp;&amp; node.left.val === node.val + 1) || (node.right &amp;&amp; node.right.val === node.val + 1)) &#123; if (node.left &amp;&amp; node.left.val === node.val + 1) &#123; if (node.right) &#123; q.push(node.right) &#125; node = node.left &#125; else if (node.right &amp;&amp; node.right.val === node.val + 1) &#123; if (node.left) &#123; q.push(node.left) &#125; node = node.right &#125; len++; &#125; if (node.left) q.push(node.left) if (node.right) q.push(node.right) res = Math.max(res, len) &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"281. Zigzag Iterator","slug":"281-Zigzag-Iterator","date":"2020-08-18T18:35:40.000Z","updated":"2020-08-18T23:12:59.751Z","comments":true,"path":"2020/08/18/281-Zigzag-Iterator/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/281-Zigzag-Iterator/","excerpt":"","text":"Solution1用i, j的大小关系来判断， 打印哪个数组， diff不能小于1， 到头的话赋最大值 12345678910111213141516171819202122232425262728293031323334353637/** * @constructor * @param &#123;Integer[]&#125; v1 * @param &#123;Integer[]&#125; v1 */var ZigzagIterator = function ZigzagIterator(v1, v2) &#123; this.v = [v1, v2] this.i = 0 this.j = 0&#125;;/** * @this ZigzagIterator * @returns &#123;boolean&#125; */ZigzagIterator.prototype.hasNext = function hasNext() &#123; if (this.i &gt;= this.v[0].length) this.i = Number.MAX_VALUE if (this.j &gt;= this.v[1].length) this.j = Number.MAX_VALUE return this.i &lt; this.v[0].length || this.j &lt; this.v[1].length&#125;;/** * @this ZigzagIterator * @returns &#123;integer&#125; */ZigzagIterator.prototype.next = function next() &#123; return this.i &lt;= this.j ? this.v[0][this.i++] : this.v[1][this.j++]&#125;;/** * Your ZigzagIterator will be called like this: * var i = new ZigzagIterator(v1, v2), a = []; * while (i.hasNext()) a.push(i.next());*/ Solution 2一开始就存入正确的zigzag顺序， 然后进行读取 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @constructor * @param &#123;Integer[]&#125; v1 * @param &#123;Integer[]&#125; v1 */var ZigzagIterator = function ZigzagIterator(v1, v2) &#123; this.v = [] this.n = Math.max(v1.length, v2.length) this.i = 0 for (let i = 0; i &lt; this.n; i++) &#123; if (i &lt; v1.length) this.v.push(v1[i]); if (i &lt; v2.length) this.v.push(v2[i]) &#125; this.n = v1.length + v2.length&#125;;/** * @this ZigzagIterator * @returns &#123;boolean&#125; */ZigzagIterator.prototype.hasNext = function hasNext() &#123; return this.i &lt; this.n&#125;;/** * @this ZigzagIterator * @returns &#123;integer&#125; */ZigzagIterator.prototype.next = function next() &#123; return this.v[this.i++]&#125;;/** * Your ZigzagIterator will be called like this: * var i = new ZigzagIterator(v1, v2), a = []; * while (i.hasNext()) a.push(i.next());*/ Solution 3Follow up using iterator 123456789101112131415161718class ZigzagIterator(object): def __init__(self, v1, v2): self.data = [(len(v), iter(v)) for v in (v1, v2) if v] def next(self): len, iter = self.data.pop(0) if len &gt; 1: self.data.append((len-1, iter)) return next(iter) def hasNext(self): return bool(self.data) # Your ZigzagIterator object will be instantiated and called as such:# i, v = ZigzagIterator(v1, v2), []# while i.hasNext(): v.append(i.next())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"163. Missing Ranges","slug":"163-Missing-Ranges","date":"2020-08-18T17:55:42.000Z","updated":"2020-08-18T17:58:52.480Z","comments":true,"path":"2020/08/18/163-Missing-Ranges/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/163-Missing-Ranges/","excerpt":"","text":"SolutionCornor Case:整形溢出， 当数组中有整形最大值时， 此时lower更新为num+1时就会溢出， 所以再更新前要判断一下， 若num已经时整形最大值了 直接返回结果 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; lower * @param &#123;number&#125; upper * @return &#123;string[]&#125; */var findMissingRanges = function(nums, lower, upper) &#123; const res = [] for (let num of nums) &#123; if (num &gt; lower) &#123; const suffix = (num-1) &gt; lower ? '-&gt;' + (num-1) : \"\" res.push(`$&#123;lower&#125;$&#123;suffix&#125;`) &#125; if (num === upper) return res; lower = num + 1 &#125; if (lower &lt;= upper) &#123; const suffix = upper &gt; lower ? `-&gt;$&#123;upper&#125;` : \"\" res.push(`$&#123;lower&#125;$&#123;suffix&#125;`) &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1057. Campus Bikes","slug":"1057-Campus-Bikes","date":"2020-08-18T02:55:33.000Z","updated":"2020-08-18T02:56:24.016Z","comments":true,"path":"2020/08/17/1057-Campus-Bikes/","link":"","permalink":"https://jojoyang666.github.io/2020/08/17/1057-Campus-Bikes/","excerpt":"","text":"Solution123456789101112131415161718192021222324class Solution(object): def assignBikes(self, workers, bikes): distances = [] # distances[worker] is tuple of (distance, worker, bike) for each bike for i, (x, y) in enumerate(workers): distances.append([]) for j, (x_b, y_b) in enumerate(bikes): distance = abs(x - x_b) + abs(y - y_b) distances[-1].append((distance, i, j)) distances[-1].sort(reverse = True) # reverse so we can pop the smallest distance result = [None] * len(workers) used_bikes = set() queue = [distances[i].pop() for i in range(len(workers))] # smallest distance for each worker heapq.heapify(queue) while len(used_bikes) &lt; len(workers): _, worker, bike = heapq.heappop(queue) if bike not in used_bikes: result[worker] = bike used_bikes.add(bike) else: heapq.heappush(queue, distances[worker].pop()) # bike used, add next closest bike return result","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Common Python Methods","slug":"Python","date":"2020-08-18T02:09:04.000Z","updated":"2020-09-18T17:44:38.076Z","comments":true,"path":"2020/08/17/Python/","link":"","permalink":"https://jojoyang666.github.io/2020/08/17/Python/","excerpt":"","text":"Base Data Type heapq heapq.heapify(x): transform list x into a heap, in-place, in linear time. heapq.heappop(heap): pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0] heapq.heappush(heap, item): Push the value item onto the heap, , maintaining the heap invariant Other Common Functions ord(c): Given a string representing one Unicode character, return an integer represeting the Unicode code point of that character. chr(i): return the string representing a character whose Unicode code point is the integer i. For example, chr(97) returns the string ‘a’ itertools count(start = 0, step = 1) make an interator that returns evenly spaced values starting with n. groupby(iterable, key) make an iterator that returns consecutive keys and gtroups from the iterable ifilter(predicate, iterable) make an iterator that filters elements from iterable returning only those for which the predicate is True. product Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). zip(): make an iterator that aggregates slements from each of the iterables. Returns an itrator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. izip make an iterator that aggregates elements from each of the iterables. Like zip() except that it returns an iterator instead of a list next(): retrieve the next item from the iterator all(iterable): return True if all elements of the iterable are true (or if the iterable is empty) while, else *: unpack the arguments out of a list or tuple collections Counter: A counter is a dict subclass for counting hashable objects. it is an unordered collection wherer elements are stored as disctionary keys and their counts are stored as disctionary values Binary Search bisect.bisect(a, x, lo=0, hi=len(a)) returns an insertion point which comes after (to the right of) any existing entries of x in a Common Problem What’s the difference between xrange and range? xrange: return an xrange object better to use when have a really gigantic range to generate a list for: dat one billion range: return a python list object better to use when iterate over the list multiple times there is no increment++ and decrement-- operators in python","categories":[{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"}],"tags":[]},{"title":"97. Interleaving String","slug":"97-Interleaving-String","date":"2020-08-13T05:06:10.000Z","updated":"2020-08-18T02:09:32.131Z","comments":true,"path":"2020/08/12/97-Interleaving-String/","link":"","permalink":"https://jojoyang666.github.io/2020/08/12/97-Interleaving-String/","excerpt":"","text":"Solution 1 只要是遇到字符串的子序列或是匹配问题， 直接上动态规划 Code –&gt; O(m*n)123456789101112131415161718192021222324class Solution(object): def isInterleave(self, s1, s2, s3): \"\"\" :type s1: str :type s2: str :type s3: str :rtype: bool \"\"\" r, c, l = len(s1), len(s2), len(s3) if r + c != l: return False dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)] for i in xrange(1, r+1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in xrange(1, c+1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): for j in xrange(1, c+1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or (dp[i][j-1] and s2[j-1] == s3[i-1+j]) return dp[-1][-1] 1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const len1 = s1.length, len2 = s2.length, len3 = s3.length; if (len1 + len2 !== len3) return false; const dp = [...new Array(len1+1)].map(item =&gt; new Array(len2+1).fill(true)) for (let i = 1; i &lt;= len1; i++) &#123; dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1] === s3[i-1] &#125; for (let i = 1; i &lt;= len2; i++) &#123; dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1] === s3[i-1] &#125; for (let i = 1; i &lt;= len1; i++) &#123; for (let j = 1; j &lt;= len2; j++) &#123; dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1] === s3[i+j-1]) || (dp[i][j-1] &amp;&amp; s2[j-1] === s3[i+j-1]) &#125; &#125; return dp[len1][len2]&#125;; Code –&gt; O(n) space123456789101112def isInterleave3(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [True for _ in xrange(c+1)] for j in xrange(1, c+1): dp[j] = dp[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): dp[0] = (dp[0] and s1[i-1] == s3[i-1]) for j in xrange(1, c+1): dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j]) return dp[-1] Solution DFS Code123456789101112131415class Solution(object): def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False stack, visited = [(0, 0)], set((0, 0)) while stack: x, y = stack.pop() if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: stack.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: stack.append((x, y+1)); visited.add((x, y+1)) return False 12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const l1 = s1.length, l2 = s2.length, l3 = s3.length if (l1 + l2 !== l3) return false; const stack = [[0, 0]], visited = new Set() while (stack.length &gt; 0) &#123; const [x, y] = stack.pop() if (x + y === l3) return true; if (x+1 &lt;= l1 &amp;&amp; s1[x] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x+1&#125;-$&#123;y&#125;`)) &#123; stack.push([x+1, y]); visited.add(`$&#123;x+1&#125;-$&#123;y&#125;`) &#125; if (y+1 &lt;= l2 &amp;&amp; s2[y] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x&#125;-$&#123;y+1&#125;`)) &#123; stack.push([x, y+1]); visited.add(`$&#123;x&#125;-$&#123;y+1&#125;`) &#125; &#125; return false&#125;; Solution BFS123456789101112131415class Solution(object): def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False queue, visited = [(0, 0)], set((0, 0)) while queue: x, y = queue.pop(0) if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: queue.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: queue.append((x, y+1)); visited.add((x, y+1)) return False 12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const l1 = s1.length, l2 = s2.length, l3 = s3.length if (l1 + l2 !== l3) return false; const stack = [[0, 0]], visited = new Set() while (stack.length &gt; 0) &#123; const [x, y] = stack.shift() if (x + y === l3) return true; if (x+1 &lt;= l1 &amp;&amp; s1[x] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x+1&#125;-$&#123;y&#125;`)) &#123; stack.push([x+1, y]); visited.add(`$&#123;x+1&#125;-$&#123;y&#125;`) &#125; if (y+1 &lt;= l2 &amp;&amp; s2[y] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x&#125;-$&#123;y+1&#125;`)) &#123; stack.push([x, y+1]); visited.add(`$&#123;x&#125;-$&#123;y+1&#125;`) &#125; &#125; return false&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"391. Perfect Rectangle","slug":"391-Perfect-Rectangle","date":"2020-08-11T18:12:17.000Z","updated":"2020-08-13T01:13:24.097Z","comments":true,"path":"2020/08/11/391-Perfect-Rectangle/","link":"","permalink":"https://jojoyang666.github.io/2020/08/11/391-Perfect-Rectangle/","excerpt":"","text":"Solution 1 所有矩形的4个顶点只会有蓝， 绿， 红三种情况 蓝表示该顶点周围没有其他矩形 绿点表示两个矩形并排相邻 红点表示四个矩形相邻 在一个完美矩形中， 蓝色的点只能有四个 矩形的四个顶点： 左下， 左上， 右上， 右下的顺序来给顶点标号为1， 2， 4， 8 —》 考虑二进制表示 当一个点是某一个矩形的左下顶点时，这个点就不能是其他矩形的左下顶点了, 这个条件对于这四种顶点都要成立，那么对于每一个点，如果它是某个矩形的四个顶点之一. 我们记录下来，如果在别的矩形中它又是相同的顶点，那么直接返回false即可 体现了我们标记为1，2，4，8的好处 如果每个点的属性没有冲突， 那么我们来验证每个点的mask是否合理 蓝点：mask的四位只有一个1， 分别就是1(0001), 2(0010), 4(0100), 8(1000) 绿点：mask的四位有两个1, 12(1100), 10(1010), 9(1001), 6(0110), 5(0101), 3(0011)； 红点：mask的四位都是1，只有一种情况15(1111) 判定条件 mask是1， 2， 4， 8的个数， 是否是4个 每个矩形的面积累加和要等于最后的大矩形的面积， 大矩形的面积就是通过计算最小左下点和最大右上点计算得出. 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def isRectangleCover(self, rectangles): def update_counts(x, y, bit): mask, nums = counts[x, y] if mask &amp; bit: return False //因为我们规定了四个左上是1， 右上是2， 左下是4， 右下是8。 所以如果有重叠的话一定返回false（4个角重叠）， 在可以重叠的地方digit 会给合适的值 counts[x, y] = [mask | bit, nums + 1] return True counts, area = collections.defaultdict(lambda: [0, 0]), 0 minx, maxx, miny, maxy = float('inf'), float('-inf'), float('inf'), float('-inf') for blx, bly, trx, _try in rectangles: tlx, tly = blx, _try brx, bry = trx, bly minx, miny, maxx, maxy = min(minx, blx), min(miny, bly), max(maxx, trx), max(maxy, _try) if not update_counts(tlx, tly, 1): return False if not update_counts(trx, _try, 2): return False if not update_counts(blx, bly, 4): return False if not update_counts(brx, bry, 8): return False area += (trx - blx) * (_try - bly) if area != (maxx - minx) * (maxy - miny): return False for x, y in counts: nums = counts[x, y][1] if (x == minx or x == maxx) and (y == miny or y == maxy): if nums != 1: return False else: if nums != 2 and nums != 4: return False return True Solution 2 Base Idea is same with above 所有矩形的4个顶点只会有蓝， 绿， 红三种情况 蓝表示该顶点周围没有其他矩形 绿点表示两个矩形并排相邻 红点表示四个矩形相邻 不用去判断每个点最多只能是一个矩形的左下，左上，右上，或右下顶点 我们直接用一个set，对于遍历到的任意一个顶点 如果set中已经存在了，则删去这个点，如果没有就加上，这样最后会把绿点和红点都滤去 剩下的都是蓝点，我们只要看蓝点的个数是否为四个，再加上检测每个矩形面积累加和要等于最后的大矩形的面积即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @param &#123;number[][]&#125; rectangles * @return &#123;boolean&#125; */var isRectangleCover = function(rectangles) &#123; let minx = Number.POSITIVE_INFINITY, maxx = Number.NEGATIVE_INFINITY, miny = Number.POSITIVE_INFINITY, maxy = Number.NEGATIVE_INFINITY const set = new Set() let area = 0 for (let rect of rectangles) &#123; minx = Math.min(minx, rect[0]) miny = Math.min(rect[1], miny) maxx = Math.max(maxx, rect[2]) maxy = Math.max(maxy, rect[3]) area += (rect[2] - rect[0]) * (rect[3] - rect[1]); let bl = coordinate(rect[0], rect[1]) let tl = coordinate(rect[0], rect[3]) let tr = coordinate(rect[2], rect[3]) let br = coordinate(rect[2], rect[1]) if(set.has(tl)) &#123; set.delete(tl) &#125; else &#123; set.add(tl) &#125; if(set.has(tr)) &#123; set.delete(tr) &#125; else &#123; set.add(tr) &#125; if(set.has(bl)) &#123; set.delete(bl) &#125; else &#123; set.add(bl) &#125; if(set.has(br)) &#123; set.delete(br) &#125; else &#123; set.add(br) &#125; &#125; let t1 = coordinate(minx, miny) let t2 = coordinate(maxx, maxy) let t3 = coordinate(minx, maxy) let t4 = coordinate(maxx, miny) if (!set.has(t1) || !set.has(t2) || !set.has(t3) || !set.has(t4) || set.size !== 4) return false return area === (maxx - minx) * (maxy - miny)&#125;;const coordinate = (x, y) =&gt; `$&#123;x&#125;-$&#123;y&#125;` Solution 3 We keep four sets that collectively act like a difference set – one for each type (direction) of corner.For every corner that we consider, we check to see if another corner has the same coordinates. If a same-position corner of the same type exists, there is an overlap, and we produce an error.If a same-position corner that shares exactly one face exists, we can delete the corner (rectangle merge).If a same-position corner shares the coordinates but neither face, we can add our corner, increasing the number of corners required to clear those coordinates to 2.If no corner is in the same position, we add the corner.After all corners have been considered, we have a rectangle cover if each set contains exactly one corner. 123456789101112131415161718192021222324252627282930let corner = (x, y) =&gt; `$&#123; x &#125; $&#123; y &#125;`let isRectangleCover = rectangles =&gt; &#123; let tls = new Set let trs = new Set let bls = new Set let brs = new Set for (let [l, b, r, t] of rectangles) &#123; let tl = corner(t, l) let tr = corner(t, r) let bl = corner(b, l) let br = corner(b, r) if (tls.has(tl) || trs.has(tr) || bls.has(bl) || brs.has(br)) return false if (!bls.delete(tl) &amp;&amp; !trs.delete(tl)) tls.add(tl) if (!brs.delete(tr) &amp;&amp; !tls.delete(tr)) trs.add(tr) if (!brs.delete(bl) &amp;&amp; !tls.delete(bl)) bls.add(bl) if (!bls.delete(br) &amp;&amp; !trs.delete(br)) brs.add(br) &#125; return tls.size === 1 &amp;&amp; trs.size === 1 &amp;&amp; bls.size === 1 &amp;&amp; brs.size === 1&#125;;if (!bls.delete(tl) &amp;&amp; !trs.delete(tl)) tls.add(tl) ===&gt; if (trs.has(tl)) trs.delete(tl);else if (bls.has(tl)) bls.delete(tl);else tls.add(tl);","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Binary Search","slug":"Binary-Search","date":"2020-08-11T04:26:32.000Z","updated":"2020-08-11T17:01:18.263Z","comments":true,"path":"2020/08/10/Binary-Search/","link":"","permalink":"https://jojoyang666.github.io/2020/08/10/Binary-Search/","excerpt":"","text":"需要找和目标值完全相等的数 code 1234567891011const find = (nums, target) =&gt; &#123; let left = 0, right = nums.length while (left &lt; right) &#123; let mid = left + (right - left)&gt;&gt;1 if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1 else right = mid; &#125; return -1;&#125; 二分查找法的写法并不惟一， 主要可以变动的地方有四处 right初始化， 可以写成nums.length/nums.length - 1 left和right关系， 可以写成left &lt; right / left &lt;= right 更新right的赋值，可以写成 right = mid / right = mid - 1 返回值可以返回left, right, right - 1 但是这些不同的写法并不能随机组合 如果right初始化为nums.length, 那么就必须用left &lt; right, 最后的right赋值必须用right = mid 如果right初始化为nums.length-1, 那么就必须用left &lt;= right, right的赋值写成right=mid-1 查找第一个不小于目标值的数， 可变形为查找最后一个小于目标值的数 Code -&gt; 查找第一个不小于目标的数 12345678910111213const find = (nums, target) =&gt; &#123; let left = 0, right = nums.lenth; while (left &lt; right) &#123; let mid = left + (right - left)&gt;&gt;1 if (nums[mid] &lt; target) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right;&#125; 可以变形为查找最后一个小于目标值的数， 如果已经找到了第一个不小于目标值的数， 那么再往前退一位， 返回right-1， 就是最后一个小于目标值的数 注意nums[mid] &lt; target, 没有等于 查找第一个大于目标值的数， 可变形为查找最后一个不大于目标值的数 code –&gt; 查找第一个大于目标值的数 1234567891011121314const find = (nums, target) =&gt; &#123; let left = 0, right = nums.length; while (left &lt; right) &#123; let mid = left + (right - left) &gt;&gt; 1 if (nums[mid] &lt;= target) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right;&#125; 可变形为查找最后一个不大于目标值的数， 如果已经找到了第一个大于目标值的数， 那么再往前退一位， 返回right - 1, 就是最后一个不大于目标值的数 用子函数当作判断关系因为这里在二分查找法重要的比较大小的地方使用到了子函数， 来确定下一步的搜索范围， 并不是之前三类的数字大小比较 其他（通常target值不固定）比如Find Peak ELement， 求的是数组的局部峰值， 由于求的是峰值， 需要跟相邻的数字比较， 那么target就不是一个固定的值， 而且这道题一定要注意的是right的初始化， 一定要是nums.legth -1. 这是由于算出了mid后， nums[mid]要和nums[mid+1]比较， 如果right初始化为nums.length的话, mid+1可能会越界， 从而不能找到正确的值， 同时while循环的终止条件必须是 left &lt; right， 不能有等号 类似的还有一道 H-Index II，这道题的 target 也不是一个固定值，而是 len-mid，这就很意思了，跟上面的 nums[mid+1] 有异曲同工之妙，target 值都随着 mid 值的变化而变化，这里的right的初始化，一定要是 nums.size() - 1，而 while 循环的终止条件必须是 left &lt;= right，这里又必须要有等号 第四类中虽然是用子函数来判断关系，但大部分时候 mid 也会作为一个参数带入子函数进行计算，这样实际上最终算出的值还是受 mid 的影响，但是 right 却可以初始化为数组长度，循环条件也可以不带等号 https://www.cnblogs.com/grandyang/p/6854825.html","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1095. Find in Mountain Array","slug":"1095-Find-in-Mountain-Array","date":"2020-08-11T03:28:18.000Z","updated":"2020-08-11T17:01:21.898Z","comments":true,"path":"2020/08/10/1095-Find-in-Mountain-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/08/10/1095-Find-in-Mountain-Array/","excerpt":"","text":"SolutionBinary Search 的判定条件， 不一定还可以和mid附近的值比较 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# \"\"\"# This is MountainArray's API interface.# You should not implement it, or speculate about its implementation# \"\"\"#class MountainArray(object):# def get(self, index):# \"\"\"# :type index: int# :rtype int# \"\"\"## def length(self):# \"\"\"# :rtype int# \"\"\"class Solution(object): def findInMountainArray(self, target, mountain_arr): \"\"\" :type target: integer :type mountain_arr: MountainArray :rtype: integer \"\"\" A = mountain_arr n = A.length() # find index of peak l, r = 0, n - 1 while l &lt; r://不能有等号 m = (l + r)/2 if A.get(m) &lt; A.get(m + 1): l = peak = m + 1 else: r = m # find target in the left of peak l, r = 0, peak while l &lt;= r: m = (l + r) / 2 if A.get(m) &lt; target: l = m + 1 elif A.get(m) &gt; target: r = m - 1 else: return m # find target in the right of peak l, r = peak, n - 1 while l &lt;= r: m = (l + r) / 2 if A.get(m) &gt; target: l = m + 1 elif A.get(m) &lt; target: r = m - 1 else: return m return -1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * // This is the MountainArray's API interface. * // You should not implement it, or speculate about its implementation * function MountainArray() &#123; * @param &#123;number&#125; index * @return &#123;number&#125; * this.get = function(index) &#123; * ... * &#125;; * * @return &#123;number&#125; * this.length = function() &#123; * ... * &#125;; * &#125;; *//** * @param &#123;number&#125; target * @param &#123;MountainArray&#125; mountainArr * @return &#123;number&#125; */var findInMountainArray = function(target, mountainArr) &#123; const n = mountainArr.length() // Find the index of the peak let l = 0, r = n - 1 let peak = 0 while (l &lt; r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) &#123; l = mid + 1 peak = l &#125; else &#123; r = mid &#125; &#125; // Find the target in the left of peak l = 0, r = peak while (l &lt;= r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &lt; target) &#123; l = mid + 1 &#125; else if (mountainArr.get(mid) &gt; target) &#123; r = mid - 1 &#125; else &#123; return mid &#125; &#125; // Find the target in the right of peak l = peak, r = n - 1 while (l &lt;= r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &gt; target) &#123; l = mid + 1 &#125; else if (mountainArr.get(mid) &lt; target) &#123; r = mid -1 &#125; else &#123; return mid &#125; &#125; return -1&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"681. Next Closest Time","slug":"681-Next-Closest-Time","date":"2020-08-10T05:05:15.000Z","updated":"2020-08-11T03:05:48.114Z","comments":true,"path":"2020/08/09/681-Next-Closest-Time/","link":"","permalink":"https://jojoyang666.github.io/2020/08/09/681-Next-Closest-Time/","excerpt":"","text":"Solution 1 时间模拟， 以当下的0为时间起点， 递增模拟 Code1234567891011121314class Solution(object): def nextClosestTime(self, time): \"\"\" :type time: str :rtype: str \"\"\" cur = 60 * int(time[:2]) + int(time[3:]) allowed = &#123;int(x) for x in time if x != ':'&#125; while True: cur = (cur + 1) % (24*60) if all(digit in allowed for block in divmod(cur, 60) for digit in divmod(block, 10)): return \"&#123;:02d&#125;:&#123;:02d&#125;\".format(*divmod(cur, 60)) 12345678910111213141516171819202122232425/** * @param &#123;string&#125; time * @return &#123;string&#125; */var nextClosestTime = function(time) &#123; let timeBlock = time.split(\":\") cur = parseInt(timeBlock[0]) * 60 + parseInt(timeBlock[1]) allowed = new Set() time.split(\"\").forEach((x) =&gt; &#123; if (x !== ':') &#123; allowed.add(parseInt(x)) &#125; &#125;) while (true) &#123; cur = (cur + 1)%(24*60); const digits = [Math.floor(Math.floor(cur/60)/10), Math.floor(cur/60)%10, Math.floor((cur%60)/10), cur%60%10] const isInAllowed = (digit) =&gt; allowed.has(digit); if (digits.every(isInAllowed))&#123; digits.splice(2, 0, \":\") return digits.join(\"\") &#125; &#125;&#125;; Solution 2 找到所有组合， 转化为分钟， 找到interval最小的 python %n -&gt; 没有负数会自动加上n, 但是JavaScript不一样会有负数12345678910111213141516171819class Solution(object): def nextClosestTime(self, time): \"\"\" :type time: str :rtype: str \"\"\" ans = start = 60 * int(time[:2]) + int(time[3:]) elapsed = 24 * 60 allowed = &#123;int(x) for x in time if x != ':'&#125; for h1, h2, m1, m2 in itertools.product(allowed, repeat = 4): hours, mins = 10 * h1 + h2, 10 * m1 + m2 if hours &lt; 24 and mins &lt; 60: cur = hours * 60 + mins cand_elapsed = (cur - start)%(24 * 60) if 0 &lt; cand_elapsed &lt; elapsed: ans = cur elapsed = cand_elapsed return \"&#123;:02d&#125;:&#123;:02d&#125;\".format(*divmod(ans, 60)) 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;string&#125; time * @return &#123;string&#125; */var nextClosestTime = function(time) &#123; let timeBlock = time.split(\":\") let ans = parseInt(timeBlock[0]) * 60 + parseInt(timeBlock[1]) let elapsed = 24 * 60, start = ans let allowed = new Set() time.split(\"\").forEach((x) =&gt; &#123; if (x !== ':') &#123; allowed.add(parseInt(x)) &#125; &#125;) for (const h1 of allowed) &#123; for (const h2 of allowed) &#123; for (const m1 of allowed) &#123; for (const m2 of allowed) &#123; const hours = 10 * h1 + h2, mins = m1 * 10 + m2 if (hours &lt; 24 &amp;&amp; mins &lt; 60) &#123; let cur = hours * 60 + mins let cand_elapsed = (cur - start + 24 * 60)%(24*60) if (cand_elapsed &lt; elapsed &amp;&amp; cand_elapsed &gt; 0) &#123; elapsed = cand_elapsed ans = cur &#125; &#125; &#125; &#125; &#125; &#125; const hours = Math.floor(ans/60) &gt;= 10 ? Math.floor(ans/60) : `0$&#123;Math.floor(ans/60)&#125;` const mins = ans%60 &gt;= 10 ? ans%60 : `0$&#123;ans%60&#125;` return `$&#123;hours&#125;:$&#123;mins&#125;`&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"284. Peeking Iterator","slug":"284-Peeking-Iterator","date":"2020-08-09T00:05:40.000Z","updated":"2020-08-09T00:07:26.541Z","comments":true,"path":"2020/08/08/284-Peeking-Iterator/","link":"","permalink":"https://jojoyang666.github.io/2020/08/08/284-Peeking-Iterator/","excerpt":"","text":"Solution 设置flag， 这种情况每个section 都要进行检测 这个flag是否符合 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * // This is the Iterator's API interface. * // You should not implement it, or speculate about its implementation. * function Iterator() &#123; * @ return &#123;number&#125; * this.next = function() &#123; // return the next number of the iterator * ... * &#125;; * * @return &#123;boolean&#125; * this.hasNext = function() &#123; // return true if it still has numbers * ... * &#125;; * &#125;; *//** * @param &#123;Iterator&#125; iterator */var PeekingIterator = function(iterator) &#123; this.list = iterator&#125;;/** * @return &#123;number&#125; */PeekingIterator.prototype.peek = function() &#123; if (this.top) &#123; return this.top &#125; if (this.list.hasNext()) &#123; this.top = this.list.next() return this.top &#125; return false&#125;;/** * @return &#123;number&#125; */PeekingIterator.prototype.next = function() &#123; if (this.top) &#123; let v = this.top this.top = null return v; &#125; return this.list.next();&#125;;/** * @return &#123;boolean&#125; */PeekingIterator.prototype.hasNext = function() &#123; if (this.top) &#123; return true; &#125; return this.list.hasNext()&#125;;/** * Your PeekingIterator object will be instantiated and called as such: * var obj = new PeekingIterator(arr) * var param_1 = obj.peek() * var param_2 = obj.next() * var param_3 = obj.hasNext() */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"403. Frog Jump","slug":"403-Frog-Jump","date":"2020-08-08T21:15:00.000Z","updated":"2020-08-08T21:19:33.635Z","comments":true,"path":"2020/08/08/403-Frog-Jump/","link":"","permalink":"https://jojoyang666.github.io/2020/08/08/403-Frog-Jump/","excerpt":"","text":"Solution dp[i] 记录跳到stone i, possible steps code12345678910111213141516171819202122/** * @param &#123;number[]&#125; stones * @return &#123;boolean&#125; */var canCross = function(stones) &#123; const dp = [[0]] for (let i = 1; i &lt; stones.length; i++) &#123; dp[i] = [] for (let j = 0; j &gt; i; j++) &#123; for (let step of dp[j]) &#123; if (Math.abs(stones[j] + step - stones[i]) &lt;= 1) &#123; dp[i].push(stones[i] - stones[j]); break; &#125; &#125; &#125; &#125; return dp[stones.length-1].length &gt; 0;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1007. Minimum Domino Rotations For Equal Row `","slug":"1007-Minimum-Domino-Rotations-For-Equal-Row","date":"2020-08-04T18:29:23.000Z","updated":"2020-08-08T21:15:41.446Z","comments":true,"path":"2020/08/04/1007-Minimum-Domino-Rotations-For-Equal-Row/","link":"","permalink":"https://jojoyang666.github.io/2020/08/04/1007-Minimum-Domino-Rotations-For-Equal-Row/","excerpt":"","text":"Solution If we take only A[0], the answer wil be wrong for the remaining possible items? In the end, the whole A/B row should be equal to A[0]/B[0], so we could arbitrarily choose A[0]/B[0] as the final target number Code1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[]&#125; A * @param &#123;number[]&#125; B * @return &#123;number&#125; */var minDominoRotations = function(A, B) &#123; const n = A.length let rotations = check(A[0], A, B, n) // If one could make all elements in A or B equal to A[0] if (rotations !== -1 || A[0] === B[0]) return rotations; // If one could make all elements in A or B equal to B[0] else return check(B[0], A, B, n)&#125;;const check = (x, A, B, n) =&gt; &#123; // how many rotations should be done to have all elements in A equal to x and to have all elements in B equal to x let rotations_a = 0, rotations_b = 0 for (let i = 0; i &lt; n; i++) &#123; if (A[i] !== x &amp;&amp; B[i] !== x) &#123; return -1; &#125; else if (A[i] !== x) &#123; rotations_a++; &#125; else if (B[i] !== x) &#123; rotations_b++; &#125; &#125; return Math.min(rotations_b, rotations_a);&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"418. Sentence Screen Fitting","slug":"418-Sentence-Screen-Fitting","date":"2020-08-03T17:52:17.000Z","updated":"2020-08-03T18:54:08.063Z","comments":true,"path":"2020/08/03/418-Sentence-Screen-Fitting/","link":"","permalink":"https://jojoyang666.github.io/2020/08/03/418-Sentence-Screen-Fitting/","excerpt":"","text":"Solution 1 Thinking start is the counter for how many valid characters from _sentence have been put to our screen _sentence[start%length] === &#39; &#39; is the situation that we do not need an extra space for current row. THe current row could be successfully fitted. SO that we need to increase our counter by using start++ think about &quot;abc de f&quot;, when at the space between de and f, you are looking for the position of the first word in the next row, which f and so you move start forward by 1 如果是’ ‘,我们没有算空格那个字符， 因为start%length in _sentence is starting from 0, 所以要加加 Code1234567891011121314151617181920212223242526/** * @param &#123;string[]&#125; sentence * @param &#123;number&#125; rows * @param &#123;number&#125; cols * @return &#123;number&#125; */var wordsTyping = function(sentence, rows, cols) &#123; const _sentence = sentence.join(' ') + ' ' let start = 0; const length = _sentence.length for (let i = 0; i &lt; rows; i++) &#123; start += cols if (_sentence[start%length] === ' ') &#123; start++;//虽然剩余的位置刚好填满了单词， 后面不用再空格了。 但是我们再算有效空位个数的时候还是要加上这个空格的 &#125; else &#123; while (start &gt; 0 &amp;&amp; _sentence[(start-1)%length] !== ' ') &#123; start--; //removimh the extra word from the next word &#125; &#125; &#125; return Math.floor(start/_sentence.length)&#125;; Solution 2 Code123456789101112131415161718192021222324252627282930313233/** * @param &#123;string[]&#125; sentence * @param &#123;number&#125; rows * @param &#123;number&#125; cols * @return &#123;number&#125; */var wordsTyping = function(sentence, rows, cols) &#123; let all = sentence.join(' ') + ' '; let res = 0, idx = 0, n = sentence.length, len = all.length for (let i = 0; i &lt; rows; i++) &#123; let colsRemaining = cols while (colsRemaining &gt; 0) &#123; if (sentence[idx].length &lt;= colsRemaining) &#123; colsRemaining -= sentence[idx].length if (colsRemaining &gt; 0) &#123; colsRemaining -= 1 //miuns the length of space &#125; if (++idx &gt;= n) &#123; res += (1 + Math.floor(colsRemaining / len)) colsRemaining %= len idx = 0 &#125; &#125; else &#123; break; &#125; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"361. Bomb Enemy","slug":"361-Bomb-Enemy","date":"2020-07-31T16:04:07.000Z","updated":"2020-08-03T17:53:13.416Z","comments":true,"path":"2020/07/31/361-Bomb-Enemy/","link":"","permalink":"https://jojoyang666.github.io/2020/07/31/361-Bomb-Enemy/","excerpt":"","text":"Solution Thinking rowCnt: record the number of ememies before hiting the next wall colCnt[j]: in the jth col, the number of emeimis before hiting the wall why colCnt would be an array? For each row, we visit each column once. Once we visit second row(and other rows too), we do not want to recompute for colums because we are traversing row wise so value of rowCnt for a row is same throughout for ith row. it is not the case with colums because as we tranverse a particular row our columns keep on changing and also we need to make sure we do not exceed n*m, that is the reasosn for array Code 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;character[][]&#125; grid * @return &#123;number&#125; */var maxKilledEnemies = function(grid) &#123; let m = grid.length, n = m ? grid[0].length : 0 let res = 0, rowCnt = 0, colCnt = new Array(n).fill(0) for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (j === 0 || grid[i][j-1] === 'W') &#123; rowCnt = 0; for (let k = j; k &lt; n &amp;&amp; grid[i][k] != 'W'; k++) &#123; rowCnt += grid[i][k] === 'E' &#125; &#125; if (i === 0 || grid[i-1][j] === 'W') &#123; colCnt[j] = 0; for (let k = i; k &lt; m &amp;&amp; grid[k][j] != 'W'; k++) &#123; colCnt[j] += grid[k][j] === 'E' &#125; &#125; if (grid[i][j] === '0') &#123; res = Math.max(res, rowCnt + colCnt[j]) &#125; &#125; &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"489. Robot Room Cleaner","slug":"489-Robot-Room-Cleaner","date":"2020-07-29T21:48:02.000Z","updated":"2020-09-10T06:06:01.356Z","comments":true,"path":"2020/07/29/489-Robot-Room-Cleaner/","link":"","permalink":"https://jojoyang666.github.io/2020/07/29/489-Robot-Room-Cleaner/","excerpt":"","text":"Solution https://www.youtube.com/watch?v=y4izHfShEfU Backtrack algorithm we do not know where the robot is (the exactly location), thus we give the initial location is (0, 0) then [[-1, 0], [0, 1], [1, 0], [0, -1]] to 4 directions, we have all the point which is relative to the initial position This is the robot, it can only move to one direction(move forward), otherwise it need to turn right/left if the robot arrived a position where it is neighbors all have been vistied, it can not go back to the original position directly(like normal backtrack) Thus, we need to go back following the path how we get here exactly. This is the reason why we need goBack function why we turn the direction in the clock-wise? the robot just one move direction(move forward) –&gt; clock-wise way to guarantee 机器人要移动的方向和转向是一样的 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * // This is the robot's control interface. * // You should not implement it, or speculate about its implementation * function Robot() &#123; * // Returns true if the cell in front is open and robot moves into the cell. * // Returns false if the cell in front is blocked and robot stays in the current cell. * @return &#123;boolean&#125; * this.move = function() &#123; * ... * &#125;; * * // Robot will stay in the same cell after calling turnLeft/turnRight. * // Each turn will be 90 degrees. * @return &#123;void&#125; * this.turnLeft = function() &#123; * ... * &#125;; * * // Robot will stay in the same cell after calling turnLeft/turnRight. * // Each turn will be 90 degrees. * @return &#123;void&#125; * this.turnRight = function() &#123; * ... * &#125;; * * // Clean the current cell. * @return &#123;void&#125; * this.clean = function() &#123; * ... * &#125;; * &#125;; *//** * @param &#123;Robot&#125; robot * @return &#123;void&#125; */var cleanRoom = function(robot) &#123; const visited = new Set(); helper(robot, 0, 0, 0, visited)&#125;;const goback = (robot) =&gt; &#123; robot.turnRight(); robot.turnRight(); robot.move(); robot.turnLeft(); robot.turnLeft();&#125;const helper = (robot, x, y, dir, visited) =&gt; &#123; robot.clean(); visited.add(`$&#123;x&#125;-$&#123;y&#125;`); const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]] for (let i = 0; i &lt; 4; i++) &#123; let cur = (i + dir)%4, newX = x + dirs[cur][0], newY = y + dirs[cur][1]; if (!visited.has(`$&#123;newX&#125;-$&#123;newY&#125;`) &amp;&amp; robot.move()) &#123; helper(robot, newX, newY, cur, visited); goback(robot) &#125; robot.turnRight(); &#125;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"212. Word Search II","slug":"212-Word-Search-II","date":"2020-07-24T13:54:43.000Z","updated":"2020-07-24T14:19:01.029Z","comments":true,"path":"2020/07/24/212-Word-Search-II/","link":"","permalink":"https://jojoyang666.github.io/2020/07/24/212-Word-Search-II/","excerpt":"","text":"Solution Trie Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @param &#123;character[][]&#125; board * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(board, words) &#123; let res = [] const buildTrie = () =&gt; &#123; const root = &#123;&#125; for (let w of words) &#123; let node = root; for (let c of w) &#123; if (!node[c]) &#123; node[c] = &#123;&#125; &#125; node = node[c]; &#125; node.word = w; &#125; return root &#125; const search = (node, i, j) =&gt; &#123; if (node.word) &#123; res.push(node.word) node.word = null; &#125; if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length) return; if (!node[board[i][j]]) return; const c = board[i][j] board[i][j] = '#'; const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]] for (let dir of dirs) &#123; search(node[c], i + dir[0], j + dir[1]); &#125; board[i][j] = c; &#125; const root = buildTrie(); for (let i = 0; i &lt; board.length; i++) &#123; for (let j = 0; j &lt; board[0].length; j++) &#123; search(root, i, j) &#125; &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"295. Find Median from Data Stream","slug":"295-Find-Median-from-Data-Stream","date":"2020-07-23T00:21:33.000Z","updated":"2020-07-23T00:25:40.576Z","comments":true,"path":"2020/07/22/295-Find-Median-from-Data-Stream/","link":"","permalink":"https://jojoyang666.github.io/2020/07/22/295-Find-Median-from-Data-Stream/","excerpt":"","text":"Solution In python, heapq is the min heap, to do the max heap, there is a trick when push the the item, we can push -item, it will logically become the max heap Min Heap: put larger number part –&gt; largeMax Heap: put smaller number part –&gt; small the diff length of two heap must just be 1 code 1234567891011121314151617181920212223242526272829303132333435from heapq import *class MedianFinder(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.heaps = [], [] def addNum(self, num): \"\"\" :type num: int :rtype: None \"\"\" small, large = self.heaps heappush(small, -heappushpop(large, num)) if (len(large) &lt; len(small)): heappush(large, -heappop(small)) def findMedian(self): \"\"\" :rtype: float \"\"\" small, large = self.heaps if len(large) &gt; len(small): return float(large[0]) return (large[0] - small[0]) / 2.0# Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)# param_2 = obj.findMedian()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"123. Best Time to Buy and Sell Stock III","slug":"123-Best-Time-to-Buy-and-Sell-Stock-III","date":"2020-07-22T23:26:01.000Z","updated":"2020-07-22T23:52:03.701Z","comments":true,"path":"2020/07/22/123-Best-Time-to-Buy-and-Sell-Stock-III/","link":"","permalink":"https://jojoyang666.github.io/2020/07/22/123-Best-Time-to-Buy-and-Sell-Stock-III/","excerpt":"","text":"Solution 1 Ideas: two variables for the dp: global one and local one local[i][j]: means when we at the ith day, the maximum profit for having at most j transactions and the last one traction is the ith day global[i][j]: means when we at the ith day, the maximim profit for having at most j transactions local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff) why use max(diff, 0) –&gt; which means buy at ith day and sell at ith day global[i][j] = max(local[i][j], global[i - 1][j]) Code123456789101112131415161718192021/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; if (!prices || !prices.length) return 0; let n = prices.length, g = [...Array(n)].map(() =&gt; new Array(3).fill(0)), l = [...new Array(n)].map(() =&gt; new Array(3).fill(0)); // console.log('g ', g) for (let i = 1; i &lt; prices.length; i++) &#123; let diff = prices[i] - prices[i-1]; for (let j = 1; j &lt;= 2; j++) &#123; l[i][j] = Math.max(g[i-1][j-1] + Math.max(diff, 0), l[i-1][j] + diff); g[i][j] = Math.max(l[i][j], g[i-1][j]) &#125; &#125; return g[n-1][2]&#125;; Solution 2 use one dimensional array rather than two dimensional array, because of overriding problem, need to use j from 2 to 1 Code1234567891011121314151617181920/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; if (!prices || !prices.length) return 0; let g = new Array(3).fill(0), l = new Array(3).fill(0) for (let i = 0; i &lt; prices.length - 1; i++) &#123; let diff = prices[i + 1] - prices[i]; for (let j = 2; j &gt; 0; j--) &#123; l[j] = Math.max(g[j-1] + Math.max(diff, 0), l[j] + diff) g[j] = Math.max(l[j], g[j]) &#125; &#125; return g[2]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"4. Median of Two Sorted Arrays ","slug":"4-Median-of-Two-Sorted-Arrays","date":"2020-07-21T18:19:08.000Z","updated":"2020-07-21T21:58:04.654Z","comments":true,"path":"2020/07/21/4-Median-of-Two-Sorted-Arrays/","link":"","permalink":"https://jojoyang666.github.io/2020/07/21/4-Median-of-Two-Sorted-Arrays/","excerpt":"","text":"Solution 1 Trick: Find the median in an array, there are two cases – odd and even: number a: (m + 1)/2 number b: (m+2)/2. median is: a + b / 2 ==&gt; in this way: can handle even and odd case together in javascript: if /2, to aviod use Math.floor ==&gt; can use &gt;&gt;. Note: ‘&gt;&gt;’ is lower priority than +/- Idea: Find the kth element in the array Find k/2th in each array, by comparing, do drop some not possible values in the array Recursive function must be aware of the bottom case 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123; let m = nums1.length, n = nums2.length, left = (m + n + 1) &gt;&gt; 1, right = (m + n + 2) &gt;&gt; 1; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right))/2;&#125;;// Find the Kth number in nums1 and nums2const findKth = (nums1, i, nums2, j, k) =&gt; &#123; if (i &gt;= nums1.length) return nums2[j + k - 1]; if (j &gt;= nums2.length) return nums1[i + k - 1]; if (k == 1) return Math.min(nums1[i], nums2[j]); let minVal1 = (i + (k &gt;&gt; 1) - 1 &lt; nums1.length) ? nums1[i + (k &gt;&gt; 1) - 1] : Number.MAX_VALUE; let minVal2 = (j + (k &gt;&gt; 1) - 1 &lt; nums2.length) ? nums2[j + (k &gt;&gt; 1) - 1] : Number.MAX_VALUE; if (minVal1 &lt; minVal2) return findKth(nums1, i + (k &gt;&gt; 1), nums2, j, k - (k &gt;&gt; 1)); else return findKth(nums1, i, nums2, j + (k &gt;&gt; 1), k - (k &gt;&gt; 1)); &#125; Solution 2 Basic thinking: If cut the sorted array to two havles of equal length, then median is the average of max(lower_half) and min(upper_half). i.e. the two numbers immediately next to the cut L, R, N Meaning L: represent the number immediately left to the cut R: the right counterpart N: the length of the array N L = (n-1)/2, R=N/2 Be ready for the two array situation, let’s add imaginary positions(represented as ‘#’)`[6 9 13 18] -&gt; [# 6 # 9 # 13 # 18 #] (N = 4)position index 0 1 2 3 4 5 6 7 8 (N_Position = 9) [6 9 11 13 18]-&gt; [# 6 # 9 # 11 # 13 # 18 #] (N = 5)position index 0 1 2 3 4 5 6 7 8 9 10 (N_Position = 11)` there are always exactly 2*N+1 positions regardeless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2.4. To find the cut position: –&gt; using the binary search among two arrays * there are 2N1 + 2N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut * therefore, whem we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k * when the cuts are made, wh have two L’s and two R’s. They are * L1 = A1[(C1-1)/2]; R1 = A1[C1/2] * L2 = A2[(C2-1)/2]; R2 = A2[C2/2] * Need to make sure if the cut is what we want. Also ecause the A1, A2 are sorted. We can use binary search * we need to make sure * L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2 * because two arrays are sorted L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 * If we have L1 &gt; R2, it means there are too many large numbers on the left half of A1, then we must move C1 to the left(i,e. move the C2 to the right) * If L2 &gt; R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left. Otherwise, this cut is the right one. * After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2;5. https://www.youtube.com/watch?v=LPFhl65R7ww6. https://www.cnblogs.com/grandyang/p/4465932.html7. Code 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123; let m = nums1.length, n = nums2.length if (m &lt; n) return findMedianSortedArrays(nums2, nums1) // make sure the cut2 is the shorter one if (n == 0) return (nums1[(m-1)&gt;&gt;1] + nums1[(m&gt;&gt;1)])/2; let left = 0, right = n * 2; while (left &lt;= right) &#123; let mid2 = (left + right) &gt;&gt; 1 let mid1 = m + n - mid2; let L1 = mid1 === 0 ? Number.NEGATIVE_INFINITY : nums1[(mid1 - 1) &gt;&gt; 1]; let L2 = mid2 === 0 ? Number.NEGATIVE_INFINITY : nums2[(mid2 - 1) &gt;&gt; 1]; let R1 = mid1 === m * 2 ? Number.POSITIVE_INFINITY : nums1[mid1 &gt;&gt; 1]; let R2 = mid2 === n * 2 ? Number.POSITIVE_INFINITY : nums2[mid2 &gt;&gt; 1]; if (L1 &gt; R2) &#123; left = mid2 + 1; &#125; else if (L2 &gt; R1) &#123; right = mid2 - 1; &#125; else &#123; return (Math.max(L1, L2) + Math.min(R1, R2))/2; &#125; &#125; return -1;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"128. Longest Consecutive Sequence","slug":"128-Longest-Consecutive-Sequence","date":"2020-07-16T17:28:43.000Z","updated":"2020-07-16T18:12:42.169Z","comments":true,"path":"2020/07/16/128-Longest-Consecutive-Sequence/","link":"","permalink":"https://jojoyang666.github.io/2020/07/16/128-Longest-Consecutive-Sequence/","excerpt":"","text":"Solution 1 set and pointer Javascript code12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var longestConsecutive = function(nums) &#123; if (!nums || nums.length === 0) return 0; const set = new Set(nums); let res = 0; for (let num of nums) &#123; if (!set.has(num)) continue; set.delete(num); let prev = num - 1, next = num + 1; while (set.has(prev)) set.delete(prev--); while (set.has(next)) set.delete(next++); res = Math.max(res, next - prev - 1); &#125; return res;&#125;; python code1234567891011121314class Solution: def longestConsecutive(self, nums): nums = set(nums) maxlen = 0 while nums: first = last = nums.pop() while first - 1 in nums: first -= 1 nums.remove(first) while last + 1 in nums: last += 1 nums.remove(last) maxlen = max(maxlen, last - first + 1) return maxlen Solution 2 hashmap, only store the sequence length to the boundary points of the sequence code123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var longestConsecutive = function(nums) &#123; let max = 0 const lens = &#123;&#125; for (let n of nums) &#123; if (lens[n] !== undefined) continue; const l = lens[n-1] || 0; const r = lens[n+1] || 0; const len = l + r + 1; lens[n - l] = len; lens[n] = len; lens[n + r] = len; max = Math.max(max, len); &#125; return max;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"LinkedList","slug":"LinkedList","date":"2020-07-16T04:56:04.000Z","updated":"2020-07-16T05:10:29.038Z","comments":true,"path":"2020/07/15/LinkedList/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/LinkedList/","excerpt":"","text":"Conclusion dummy node is very common, especially head dummy Node Reverse LinkedList code:123456789101112// prev is the dummy head, next is nullconst reverseOneGroup = (pre, next) =&gt; &#123; let last = pre.next, cur = last.next; while (cur != next) &#123; last.next = cur.next cur.next = pre.next pre.next = cur cur = last.next &#125; return last&#125; 123456789101112// head is actual head, tail is null in initialconst reverse = (head, tail) =&gt; &#123; let pre = tail while (head != tail) &#123; let t = head.next head.next = pre pre = head head = t &#125; return pre&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"25. Reverse Nodes in k-Group","slug":"25-Reverse-Nodes-in-k-Group","date":"2020-07-16T04:53:59.000Z","updated":"2020-07-16T05:10:52.902Z","comments":true,"path":"2020/07/15/25-Reverse-Nodes-in-k-Group/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/25-Reverse-Nodes-in-k-Group/","excerpt":"","text":"Solution 1 code123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var reverseKGroup = function(head, k) &#123; if (!head || k == 1) return head let dummy = new ListNode(-1), pre = dummy, cur = head; dummy.next = head; for (let i = 1; cur; i++) &#123; if (i%k === 0) &#123; pre = reverseOneGroup(pre, cur.next) cur = pre.next &#125; else &#123; cur = cur.next &#125; &#125; return dummy.next&#125;;const reverseOneGroup = (pre, next) =&gt; &#123; let last = pre.next, cur = last.next; while (cur != next) &#123; last.next = cur.next cur.next = pre.next pre.next = cur cur = last.next &#125; return last&#125; Solution 2123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var reverseKGroup = function(head, k) &#123; let cur = head for (let i = 0; i &lt; k; i++) &#123; if (!cur) return head; cur = cur.next &#125; let new_head = reverse(head, cur) head.next = reverseKGroup(cur, k) return new_head&#125;;const reverse = (head, tail) =&gt; &#123; let pre = tail while (head != tail) &#123; let t = head.next head.next = pre pre = head head = t &#125; return pre&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"https://jojoyang666.github.io/tags/LinkedList/"}]},{"title":"381. Insert Delete GetRandom O(1) - Duplicates allowed","slug":"381-Insert-Delete-GetRandom-O-1-Duplicates-allowed","date":"2020-07-15T20:42:55.000Z","updated":"2020-07-16T05:11:56.276Z","comments":true,"path":"2020/07/15/381-Insert-Delete-GetRandom-O-1-Duplicates-allowed/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/381-Insert-Delete-GetRandom-O-1-Duplicates-allowed/","excerpt":"","text":"Solution 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Initialize your data structure here. */var RandomizedCollection = function() &#123; this.map = &#123;&#125; // val: [idx1, idx2] this.array = [] // [[val, 0], [val, 1]...], the seconde element in the array represents the idx of this value in the value of map&#125;;/** * Inserts a value to the collection. Returns true if the collection did not already contain the specified element. * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedCollection.prototype.insert = function(val) &#123; let res = true if (this.map[val] !== undefined) res = false this.map[val] = this.map[val] || [] this.map[val].push(this.array.length) this.array.push([val, this.map[val].length-1]); return res;&#125;;/** * Removes a value from the collection. Returns true if the collection contained the specified element. * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedCollection.prototype.remove = function(val) &#123; if (this.map[val] === undefined) return false; let valIdx = this.map[val].pop(); if (!this.map[val].length) delete this.map[val]; let lastIdx = this.array.length - 1 if (valIdx === lastIdx) &#123; this.array.pop(); &#125; else &#123; [this.array[valIdx], this.array[lastIdx]] = [this.array[lastIdx], this.array[valIdx]] this.array.pop(); let [key, idx] = this.array[valIdx] this.map[key][idx] = valIdx; &#125; return true;&#125;;/** * Get a random element from the collection. * @return &#123;number&#125; */RandomizedCollection.prototype.getRandom = function() &#123; return this.array[Math.floor(Math.random() * this.array.length)][0];&#125;;/** * Your RandomizedCollection object will be instantiated and called as such: * var obj = new RandomizedCollection() * var param_1 = obj.insert(val) * var param_2 = obj.remove(val) * var param_3 = obj.getRandom() */ Solution 2:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import randomclass RandomizedCollection(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.vals, self.idxs = [], collections.defaultdict(set) def insert(self, val): \"\"\" Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool \"\"\" self.vals.append(val) self.idxs[val].add(len(self.vals)-1) return len(self.idxs[val]) == 1 // check brillent def remove(self, val): \"\"\" Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool \"\"\" if self.idxs[val]: out, ins = self.idxs[val].pop(), self.vals[-1] self.vals[out] = ins self.idxs[ins].add(out) self.idxs[ins].discard(len(self.vals)-1) self.vals.pop() return True return False def getRandom(self): \"\"\" Get a random element from the collection. :rtype: int \"\"\" return random.choice(self.vals)# Your RandomizedCollection object will be instantiated and called as such:# obj = RandomizedCollection()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"432. All Oone Data Structure","slug":"432-All-Oone-Data-Structure","date":"2020-07-15T19:09:14.000Z","updated":"2020-07-16T05:12:07.709Z","comments":true,"path":"2020/07/15/432-All-Oone-Data-Structure/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/432-All-Oone-Data-Structure/","excerpt":"","text":"Solution class Node: key_set: is set of key. In current scenario, all key with the same frequency prev node next node class DoubleLinkedList head_node tail_node item is Node, this class is a link list of Node class AllOne dll is a DoubleLinkedList -&gt; node store set of key key_counter is a dict -&gt; key is key, value is how many times this key appear node_freq is a dict -&gt; key is how many times a key appear, value is the node Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132from collections import defaultdictclass Node(object): def __init__(self): self.key_set = set([]) self.prev, self.next = None, None def add_key(self, key): self.key_set.add(key) def remove_key(self, key): self.key_set.remove(key) def get_any_key(self): if self.key_set: result = self.key_set.pop() self.add_key(result) return result else: return None def count(self): return len(self.key_set) def is_empty(self): return self.count() == 0 class DoubleLinkedList(object): def __init__(self): self.head_node, self.tail_node = Node(), Node() self.head_node.next, self.tail_node.prev = self.tail_node, self.head_node def insert_after(self, x): node, temp = Node(), x.next x.next, node.prev = node, x node.next, temp.prev = temp, node return node def insert_before(self, x): return self.insert_after(x.prev) def remove(self, x): prev_node = x.prev prev_node.next, x.next.prev = x.next, prev_node def get_head(self): return self.head_node.next def get_tail(self): return self.tail_node.prev def get_sentinel_head(self): return self.head_node def get_sentinel_tail(self): return self.tail_node class AllOne(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int) self.node_freq = &#123;0: self.dll.get_sentinel_head()&#125; def _rmv_key_pf_node(self, pf, key): node = self.node_freq[pf] node.remove_key(key) if node.is_empty(): self.dll.remove(node) self.node_freq.pop(pf) return def inc(self, key): \"\"\" Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. :type key: str :rtype: None \"\"\" self.key_counter[key] += 1 cf, pf = self.key_counter[key], self.key_counter[key]-1 if cf not in self.node_freq: self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf]) self.node_freq[cf].add_key(key) if pf &gt; 0: self._rmv_key_pf_node(pf, key) def dec(self, key): \"\"\" Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. :type key: str :rtype: None \"\"\" if key in self.key_counter: self.key_counter[key] -= 1 cf, pf = self.key_counter[key], self.key_counter[key] + 1 if self.key_counter[key] == 0: self.key_counter.pop(key) if cf != 0: if cf not in self.node_freq: self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf]) self.node_freq[cf].add_key(key) self._rmv_key_pf_node(pf, key) def getMaxKey(self): \"\"\" Returns one of the keys with maximal value. :rtype: str \"\"\" return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() &gt; 0 else \"\" def getMinKey(self): \"\"\" Returns one of the keys with Minimal value. :rtype: str \"\"\" return self.dll.get_head().get_any_key() if self.dll.get_head().count() &gt; 0 else \"\" # Your AllOne object will be instantiated and called as such:# obj = AllOne()# obj.inc(key)# obj.dec(key)# param_3 = obj.getMaxKey()# param_4 = obj.getMinKey()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"python-basic-syntax","slug":"python-basic-syntax","date":"2020-07-02T19:07:39.000Z","updated":"2020-07-02T19:30:44.985Z","comments":true,"path":"2020/07/02/python-basic-syntax/","link":"","permalink":"https://jojoyang666.github.io/2020/07/02/python-basic-syntax/","excerpt":"","text":"from import and import Util.py 12345def lookNum(): print(\"I am number\") def lookStr(): print(\"I am string\") Teacher.py 1234567class Teacher: def check(self): return 'I am teacher'; class Order: def checkOrder(self): return 'I am order'; Student.py 123456789101112from Teacher import *import Utilclass Student: def login(self): str = Teacher.check(self) order = Order.checkOrder(self) Util.lookNum() Util.lookStr() print(str+'login success'+order) s = Student()s.login() Conclusion when we import a class, we must use from &lt;..&gt; import &lt;..&gt; if we write multiple classes in a file, we can use from Teacher import * import all if we just want to import one class from a file, we need to deicate the name of class. For example: from Teacher import Order If the file has some methods rather than a class file, can use import &lt;name of file&gt; directly, which means import all the methods from the file. For example: import Util, when want to use the specific method –&gt; Util.lookNum() if want to just import one method, from Util import lookNum, use it –&gt; lookNum()","categories":[{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"}],"tags":[]},{"title":"307. Range Sum Query - Mutable","slug":"307-Range-Sum-Query-Mutable","date":"2020-07-01T18:22:45.000Z","updated":"2020-07-16T05:11:38.034Z","comments":true,"path":"2020/07/01/307-Range-Sum-Query-Mutable/","link":"","permalink":"https://jojoyang666.github.io/2020/07/01/307-Range-Sum-Query-Mutable/","excerpt":"","text":"Solution1 Binary Indexed Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;number[]&#125; nums */var NumArray = function(nums) &#123; this.bitArray = new Array(nums.length + 1); this.nums = nums for (let i = 0; i &lt; nums.length; i++) &#123; this.bitArray[i+1] = nums[i] &#125; for (let i = 1; i &lt; this.bitArray.length; i++) &#123; let j = i + (i&amp;-i) if (j &lt; this.bitArray.length) &#123; this.bitArray[j] += this.bitArray[i] &#125; &#125;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; val * @return &#123;void&#125; */NumArray.prototype.update = function(i, val) &#123; let idx = i + 1 let delta = val - this.nums[i] while (idx &lt; this.bitArray.length) &#123; this.bitArray[idx] += delta idx = idx + (idx &amp; -idx) &#125; this.nums[i] = val;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; j * @return &#123;number&#125; */NumArray.prototype.sumRange = function(i, j) &#123; const prefixSum = (idx) =&gt; &#123; idx += 1 let result = 0; while (idx &gt; 0) &#123; result += this.bitArray[idx] idx = idx - (idx &amp; -idx) &#125; return result; &#125; return prefixSum(j) - prefixSum(i-1);&#125;;/** * Your NumArray object will be instantiated and called as such: * var obj = new NumArray(nums) * obj.update(i,val) * var param_2 = obj.sumRange(i,j) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","date":"2020-06-30T23:47:14.000Z","updated":"2020-07-01T18:26:03.531Z","comments":true,"path":"2020/06/30/Binary-Indexed-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/06/30/Binary-Indexed-Tree/","excerpt":"","text":"Definition A data structure that can efficiently update element and calculate prefix sums in a table of numbers It can solve the problems below efficiently update(idx, delta): add num at the number which at position idx prefixSum(idx): get the sum of numbers which start from position 1 to idx(include idx) rangeSum(from_idx, to_idx): get the sum of all the numbers which is from from_idx to to_idx Thoughts about Construction Binary Indexed Tree store the element in a logical way according to the binary of number Sum in the Binary Indexed Tree: Given the position i(we want to get the sum from position 1 to i), like 13 13 = 2^3 + 2^2 + 2^0 =&gt; prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13) Note: RANGE(x, y) represent the sum of array starting from postion x to postion y First level, fill from the first number in the array. length is the sum of 2^m(m is from 0 to infinite) numbersfor example 2^0, 2^1, 2^2, 2^3. stop here because 2^4 exceeds the length of array Second level. fill from 3(the first hole). length is the sum of 2^m(m is from 0 to infinite) numbers — always start from hole, to the end of array Third level is same as previous one contruct a binary indexed array, we call it BIT, for our coonvience, we index it starting from 1 prefixSum(13) = prefixSum(0b0001101) = BIT[13] + BIT[12] + BIT[8] This is how tree looks like: How to get prefix sum or range sumWay to find the parent node of current node Observation From BelowprefixSum(13) = prefixSum(0b0001101)= BIT[13] + BIT[12] + BIT[8]= BIT[0b00001101] + BIT[0b00001100] + BIT[0b00001000] Move from bottom to Up, actually is a process to flip last digit 1 to 0, for example x = 13 x = 13 = 0b00001101 -x = -13 = 0b11110011 x &amp; (-x) = 0b00000001 x - (x &amp; (-x)) = 0b00001100 Update elment in the array For example, update(5,2), we want to add 2 to the number at postion 5, the process of it would like: we can see that, the postition needed to update is the binary of original position plus 1 to the last 1 in the binary representation, for example x = 5 x = 5 = 0b00000101 -x = -5 = 0b11111011 x &amp; (-x) = 0b00000001 x + (x &amp; (-x)) = 0b00000110 Construction of Binary Indexed TreeMethod 1 Iinite an array with all 0, Do the update(i, delta) for every item –&gt; O(nlgn) Method 2Input is an array list with length n Initianize an array bit with length n+1 Put the numbers of list to bit array from position 1 to n for index i from 1 to n j = i + (i &amp; -i)，if j &lt; n + 1，then bit[j] = bit[j] + bit[i] Conclusion 如何确定某个位置到底是有几个数组成的呢 原来是根据坐标的最低位 Low Bit 来决定的，所谓的最低位，就是二进制数的最右边的一个1开始，加上后面的0(如果有的话)组成的数字 Notes (i &amp; -i): trick to extract the lowest set bit of i Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243public class BinaryIndexedTree &#123; private int[] bitArr; public BinaryIndexedTree(int[] list) &#123; // log(n) this.bitArr = new int[list.length + 1]; for (int i = 0; i &lt; list.length; i++) &#123; this.bitArr[i + 1] = list[i]; &#125; for (int i = 1; i &lt; this.bitArr.length; i++) &#123; let j = i + (i &amp; -i); if (j &lt; this.bitArr.length) &#123; this.bitArr[j] += this.bitArr[i] &#125; &#125; &#125; public void update(int idx, int delta) &#123; idx += 1 while (idx &lt; this.bitArr.length) &#123; this.bitArr[idx] += delta idx = idx + (idx &amp; -idx) &#125; &#125; public int prefixSum(int idx) &#123; idx += 1 int result = 0 while (idx &gt; 0) &#123; result += this.bitArr[idx] idx = idx - (idx &amp; -idx) &#125; return result &#125; public int rangeSum(int from_idx, int to_idx)&#123; return prefixSum(to_idx) - prefixSum(from_idx-1) &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://jojoyang666.github.io/tags/Binary-Indexed-Tree/"}]},{"title":"React LifeCycle","slug":"React-LifeCycle","date":"2020-06-25T16:51:13.000Z","updated":"2020-06-25T17:56:12.957Z","comments":true,"path":"2020/06/25/React-LifeCycle/","link":"","permalink":"https://jojoyang666.github.io/2020/06/25/React-LifeCycle/","excerpt":"","text":"Lifecycle Diagram UpdatingcomponentDidUpdate invoked immediately after updating occurs, is not called for the initial render A good place to do network requests as long as you compare the current props to previous props(e.g. a network request may not be necessary if the props have not changed) May call setState() immediately in componentDidUpdate(), but nore that it must be wrapped in a condition, otherwise will cause a infinite loop If try to “mirror” some state to a prop coming from above, consider using the prop directly instead shouldComponentUpdate Let react know if a component’s output is not affected by the current change in state or props Default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior Invoked before rendering when new props or state are being received. Defaults to true Exists as a performance optimization, do not rely on it to “prevent” a rendering, as this can lead bugs If want to prevent a rendering, can use PureComponent PureComponent performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped Noted that returning false does not prevent child components from rerendering when their states changes Not recommend doing deap equality checks or using JSON.stringify() in shouldComponentUpdate(), it is every inefficient and will harm the performanced React.PureComponent similar to React.Component. The difference between them is: React.Component does not implement shouldComponentUpdate() React.PureComponent implements it with a shallow prop and state comparison React.PureComponent’s shouldComponentUpdate only shallowly compares the object if contains complex data structer, may introduce false-negative for deeper diff React.PureComponent’s shouldComponentUpdate skips prop updates for the whole component subtree Make sure all the children components are also pure","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"}]},{"title":"308. Range Sum Query 2D - Mutable","slug":"308-Range-Sum-Query-2D-Mutable","date":"2020-06-24T18:27:47.000Z","updated":"2020-07-16T05:11:42.444Z","comments":true,"path":"2020/06/24/308-Range-Sum-Query-2D-Mutable/","link":"","permalink":"https://jojoyang666.github.io/2020/06/24/308-Range-Sum-Query-2D-Mutable/","excerpt":"","text":"Solution I 建立列之和的矩阵： 就是(i, j)就是(0, j) + (1, j) + … + (i, j) 之和 相当于把多个一维的区间之和拼到了一起， 所以在构造函数中需要建立起这样一个列之和的矩阵， 然后在更新某一个位置时， 我们只需要将该列中改变的位置下面的所有数字更新一下即可 求某个区间的和时， 只要将相差的各列中对应的起始和结束的行上的差值累加起来即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @param &#123;number[][]&#125; matrix */var NumMatrix = function(matrix) &#123; if (!matrix.length || !matrix[0].length) &#123; return; &#125; this.matrix = matrix this.colSum = [...new Array(matrix.length + 1)].map(item =&gt; new Array(matrix[0].length).fill(0)); for (let i = 1; i &lt; this.colSum.length; i++) &#123; for (let j = 0; j &lt; this.colSum[0].length; j++) &#123; this.colSum[i][j] = this.colSum[i-1][j] + this.matrix[i-1][j]; &#125; &#125;&#125;;/** * @param &#123;number&#125; row * @param &#123;number&#125; col * @param &#123;number&#125; val * @return &#123;void&#125; */NumMatrix.prototype.update = function(row, col, val) &#123; for (let i = row + 1; i &lt; this.colSum.length; i++) &#123; this.colSum[i][col] += val - this.matrix[row][col] &#125; this.matrix[row][col] = val&#125;;/** * @param &#123;number&#125; row1 * @param &#123;number&#125; col1 * @param &#123;number&#125; row2 * @param &#123;number&#125; col2 * @return &#123;number&#125; */NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) &#123; let res = 0; for (let j = col1; j &lt;= col2; j++) &#123; res += this.colSum[row2+1][j] - this.colSum[row1][j]; &#125; return res&#125;;/** * Your NumMatrix object will be instantiated and called as such: * var obj = new NumMatrix(matrix) * obj.update(row,col,val) * var param_2 = obj.sumRegion(row1,col1,row2,col2) */ Solution II","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Docker","slug":"Docker","date":"2020-06-23T18:09:23.000Z","updated":"2020-06-23T18:20:38.418Z","comments":true,"path":"2020/06/23/Docker/","link":"","permalink":"https://jojoyang666.github.io/2020/06/23/Docker/","excerpt":"","text":"Load docker load &lt; ***.tar.gz —&gt; load images from .tar.gz docker tag ** ***","categories":[{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"}],"tags":[]},{"title":"218. The Skyline Problem","slug":"218-The-Skyline-Problem","date":"2020-06-23T16:56:50.000Z","updated":"2020-07-16T05:11:09.755Z","comments":true,"path":"2020/06/23/218-The-Skyline-Problem/","link":"","permalink":"https://jojoyang666.github.io/2020/06/23/218-The-Skyline-Problem/","excerpt":"","text":"SolutionJSBasic Ideas for JS Treat all left, right positions as the candidate x-positions For each candidate x-position, find out it’s y-position by search for the highest height on top of that position Determine if it’s necessary to record the position by comparing the height with the previous height there is no heap in JS JS Code1234567891011121314151617181920212223242526272829303132var getSkyline = function(buildings) &#123; let cp = new Set(); for (let [l, r, h] of buildings) &#123; cp.add(l); cp.add(r); &#125; let cp1 = [...cp], n = buildings.length; cp1.sort((a, b) =&gt; Number.parseInt(a) - Number.parseInt(b)); let res = [[-1, 0]] for (let p of cp1) &#123; let i = 0, height = 0; while (i &lt; n &amp;&amp; buildings[i][0] &lt;= p) &#123; if (buildings[i][1] &gt; p) &#123; height = Math.max(height, buildings[i][2]); &#125; i++; &#125; if (res[res.length-1][1] === height) &#123; continue; &#125; res.push([p, height]); &#125; return res.slice(1);&#125;; PythonBasic Ideas for Python 对于一个building， 他由(l, r, h)三元组组成， 我们可以将其分解成两种事件 在 left position, 高度从0增加到h（并且这个高度将持续到right position） 在 right position, 高度从h降低到0 引入了一个event结构: 在某一个position p, 他引入了一个高度为h的skyline， 将一直持续到另一个end position 对于right position高度降为0的event， 它的持续长度是无效的 只保留一个right position event， 就可以同时触发不同的两个building， 在同一right position从各自的h降为0的event， 所以对right position events做集合操作会减少计算量 由于需要从左到右触发event， 所以按position对events排序，并且对于同一position， 我们需要先触发更高的h事件， 那么高的h相比于低的h会占据更高的skyline, 低h的 key point就一定不会产生； 相反， 可能会从低到高连续产生冗余的 key point, 所以event不仅需要按第一个元素position排序， 在position相同时， 第二个元素h也必须是有序的 hp记录了对于一条高为h的skyline，他将持续到什么position才结束: [h, endposition], 在同时有多条skyline的时候, h最高的那条skyline会掩盖掉h低的skyline， 因此在event出发时， 需要得到当前最高的skyline; 所以利用heap结构存储hp, 它的第一个值永远为列表中的最小值： 因此在event中记录的是-h, heap结构就会返回最高的skyline. 同时，h必须在endposition之前， 因为它按照第一个元素排序。 触发event时， 首先要做的就是清除已经到end position的skyline； hp: [h, endposition], 如果当前position大于等于hp中的endposition， 那么该skyline就会被清除掉； 由于在有high skyline的情况下， low skyline不会有影响， 因此， 只需要从高到低的方式清除skyline， 直到剩下一个最高的skyline并且它的end position大于前position 对于高度增加到 h 的时间(neg_h &lt; 0), 我们需要添加一个 skyline, 他将持续到 r 即 endposition 由于 res[-1][1] 记录了在当前事件触发之前一直保持的 skyline 如果当前事件触发后 skyline 发生了改变 来了一条新的高度大于 h 的 skyline res[-1] 中记录的 skyline 到达了 endposition 这两种事件都会导致刚才持续的 skyline 与现在最高的 skyline 不同; 同时, key point 产生了, 他将被记录在 res 中 there is no max heap’s push and pop method, so we can use a min heap hp storing -H as max heap Python Code12345678910111213141516171819class Solution(object): def getSkyline(self, buildings): \"\"\" :type buildings: List[List[int]] :rtype: List[List[int]] \"\"\" events = sorted([(l, -h, r) for l, r, h in buildings] + list(&#123;(r, 0, 0) for l, r, h in buildings&#125;)) res, hp = [[0, 0]], [(0, float('inf'))] for l, neg_h, r in events: while l &gt;= hp[0][1]: heapq.heappop(hp) if neg_h: heapq.heappush(hp, (neg_h, r)) if res[-1][1] != -hp[0][0]: res.append([l, -hp[0][0]]) return res[1:]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"305. Number of Islands II","slug":"305-Number-of-Islands-II","date":"2020-06-23T05:59:43.000Z","updated":"2020-07-16T05:11:27.195Z","comments":true,"path":"2020/06/22/305-Number-of-Islands-II/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/305-Number-of-Islands-II/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839var numIslands2 = function(m, n, positions) &#123; const res = [] const roots = new Array(m*n).fill(-1); const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let cnt = 0; for(let pos of positions) &#123; let id = pos[0] * n + pos[1]; if (roots[id] !== -1) &#123; res.push(cnt); continue; &#125; roots[id] = id; cnt++; for (let dir of dirs) &#123; let x = pos[0] + dir[0], y = pos[1] + dir[1], cur_id = n * x + y; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || roots[cur_id] === -1) continue; let p = findRoot(roots, cur_id), q = findRoot(roots, id) if (p !== q) &#123; roots[p] = q; cnt--; &#125; &#125; res.push(cnt); &#125; return res;&#125;;const findRoot = (roots, id) =&gt; &#123; return (id === roots[id]) ? id : findRoot(roots, roots[id]);&#125; TO speed up add one line to shorten the tree1234567const findRoot = (roots, id) =&gt; &#123; while (id !== roots[id]) &#123; roots[id] = roots[roots[id]] id = roots[id] &#125; return id;&#125; Conclusion For the problem about groups, Union Find is a possible solution Key point of UF: Find the rott Union parent node is the node whose parent is itself","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[{"name":"Union Find","slug":"Union-Find","permalink":"https://jojoyang666.github.io/tags/Union-Find/"}]},{"title":"GIT","slug":"GIT","date":"2020-06-22T22:29:47.000Z","updated":"2020-07-16T20:39:44.479Z","comments":true,"path":"2020/06/22/GIT/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/GIT/","excerpt":"","text":"Stash Git stash: Hide current work Git stash list: View current stash Git stash apply &amp; git stash drop Apply and delete Git stash pop Same as above Git stash apply stash@{0} Select stash Git stash show []: 展示存储单元和最新存储的结果 Git stash show -p []: stash detail Cherry-pick git cherry-pick -n Diff git diff –staged git diff –cached REWRITING GIT HISTORY git commit –amend: Replace the last commit with the staged changes and last commit combined. Use with nothing staged to edit the last commit’s message git commit –amend -m “New commit message”: what the command does is overwriting the most recent commit with the new one `-m’ option allows you to write the new message on the command line without opening an editor session git rebase -i —&gt; 前闭后开 Renamegit branch -m Create New Branchgit checkout -f -B local_TOT remotes/origin/TOT git checkout git checkout -- file git revoke the file in the working space, let it roll back to the latest status git commit/git add git checkout &lt;other branch&gt; -- &lt;file path1&gt; &lt;file path2&gt; copy the file from another branch to current one git log shows the current HEAD and its ancestry prints the commit HEAD points to, then its parent, its parent and so on it tranverse back through the repo’s ancestry, by revursively looking up each commit’s parent git log --oneline --graph --decorategit reflog an ordered list of the commits that HEAD has points to: it’s undo history for your repo Remove files from git commit git reset – soft HEAD^/HEAD~1 git reset HEAD git commit -c ORIG_HEAD Delete branch Delete local branchgit branch -d git branch -D =&gt; -D means force delete","categories":[{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"}],"tags":[{"name":"Source Control","slug":"Source-Control","permalink":"https://jojoyang666.github.io/tags/Source-Control/"}]},{"title":"Shortcut for Iterm2","slug":"Shortcut-for-Iterm2","date":"2020-06-22T21:41:31.000Z","updated":"2020-06-22T22:28:36.513Z","comments":true,"path":"2020/06/22/Shortcut-for-Iterm2/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/Shortcut-for-Iterm2/","excerpt":"","text":"Moving Faster Move to the start of line: Ctrl + A Move to the end of line: Ctrl + E Move forward a word: option + -&gt; Move back a word: option + -&gt; My Favorite Shell Key Combos Delete previous word (in shell): Ctrl + W","categories":[{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://jojoyang666.github.io/categories/cheatsheet/"}],"tags":[{"name":"iterm2","slug":"iterm2","permalink":"https://jojoyang666.github.io/tags/iterm2/"},{"name":"shortcut","slug":"shortcut","permalink":"https://jojoyang666.github.io/tags/shortcut/"}]},{"title":"Regular Expression","slug":"Regular-Expression","date":"2020-06-22T18:46:19.000Z","updated":"2020-06-25T16:51:55.414Z","comments":true,"path":"2020/06/22/Regular-Expression/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/Regular-Expression/","excerpt":"","text":"Character ClassesAssertions^ Matches the beginning of input if the multiline flas is set to true, also mathces immediately after a line break character Like: /^A/ does not match the “A” in “an A”, but does match the first “A” in “An A” Note: This character has a different meaning when it appears at the start of a group Groups and ranges(?:x) Matches “x” but does not remember the match The matched substring cannot be recalled from the resulting array’s element([1], …, [n]) or from the predefined RegExp object’s properties ($1, …, $2) x|y matches either “x” or “y” Quantifiersx? Matches the preceding item “x” 0 or 1 times If used immediately after any of the quantifiers *, +, ?, {} Unicode Property EscapesNote when create the regular expression, it will be global match or not? if it is global, it should add ‘g’; default is not global when create the regular expression, it will be case sensitive or not? it if is case insensitive, it should add ‘i’; defalut is case sensitive","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jojoyang666.github.io/categories/JavaScript/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"}]},{"title":"Flex Box","slug":"flex","date":"2020-06-19T22:39:00.000Z","updated":"2020-06-22T01:36:11.924Z","comments":true,"path":"2020/06/19/flex/","link":"","permalink":"https://jojoyang666.github.io/2020/06/19/flex/","excerpt":"","text":"Properties for the Parent(flex container)two axis cross axis main axis flex-direction the direction of the main axis, thus defining the direction flex items are placed in the flex container row（default）：main-axis is horizontal directions, start point is on the left row-reverse：main-axis is horizontal directions, start point is on the right column：main-axis is vertical directions, start point is on the top column-reverse：main-axis is vertical directions, start point is on the bottom flex-wrap nowrap(default): all flex items will be on the one line wrap: flex items will wrap onto multiple lines from top to bottom wrap-reverse: flex items will wrap onto multiple lines from bottom to top flex-flow flex-direction + flex wrap .containers { flex-flow: column wrap } justify-content define the alignment along the main axis flex-start(default): items are packed toward the start of the flex-direction flex-end: items are packed toward the end of the flex-direction center: items are centered along the line space-between: items are evenly distributed in the line, first item is on the start line, lastitem on the end line space-around: items are evenly distributed in the line with equal space around them, visuallythe spaces are not equal, since all the items have equal space on both side align-items how flex items are laid out along the cross axis on the current line stretch(default): stretch to fill the container(still respect min-width/max-width) flex-start/start/self-start items are placed start of the cross axis the difference between these is subtle, and is about respecting the flex-direction rulesor the writling-mode rules flex-end/end/self-end items are placed at the end of the cross axis the difference between thses is subtle, and is about respecting the flex-direction rulesor the writling-mode rules center items are centered in the cross-axis baseline itmes are aligned such as their baselines align align-content This aligns a flex container’s lines within when there is extra space in the cross-axis this property has no effect when there is only one line of flex items stretch(default): lines stretch to take up the remaining space flex-start/start: items packed to the start of the container flex-start: honors the flex direction start: honors the writing mode direction flex-end/end: items packed to the end of the container flex-end: honors the flex direction end: honors the writing mode direction center: items centered in the container space-around: items evenly distributed with equal space around each line space-between: items evenly distributed the first line is at the start of the container the last on is at the end the main diff between align-items and align-content is the exptra space, there is some extra space inthe align items, however there is no extra space in the align-content(except space-around and spacebetween) Properties for the Children(flex items)order control the order in which they appear in the flex container default is 0 the value is smaller, it will be in the front of the container flex-grow the ability for a flex item to grow if necessary Negative numbers are invalid defalut is 0, which means even there is extra space, it will not grow if all items have flex-glow set to 1, the remaining space in the container will be distributedequally to all children if one of the children has a value of 2, the remaining space would take up twice as much space as the others flex-shrink the ability for a flex item to shrink if necessary Negative numbers are invalid default is 1, if the space is not enough, it will shrink if an item is 0, others are 1, then if the space is not enough, the previous one will not shrink flex-basis: defines the default size of an element before the remaining space is distributed on the main-axis can set to width/height, then the item will have the fixed size default is auto, the original size of the item flex shorthand for flex-grow, flex-shrink and flex-basis, default value is 0 1 auto it is recommended that you use this shorthand property rather than set the individual properties.the shorthand sets the other values intelligiently align-self the default alignment to be overridden for individual flex items default is auto, inferit from the align-items of parent items, if there is no parent, it will be stretch","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"css","slug":"css","permalink":"https://jojoyang666.github.io/tags/css/"}]}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"},{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"},{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"},{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://jojoyang666.github.io/categories/cheatsheet/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jojoyang666.github.io/categories/JavaScript/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"https://jojoyang666.github.io/tags/LinkedList/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://jojoyang666.github.io/tags/Binary-Indexed-Tree/"},{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://jojoyang666.github.io/tags/Union-Find/"},{"name":"Source Control","slug":"Source-Control","permalink":"https://jojoyang666.github.io/tags/Source-Control/"},{"name":"iterm2","slug":"iterm2","permalink":"https://jojoyang666.github.io/tags/iterm2/"},{"name":"shortcut","slug":"shortcut","permalink":"https://jojoyang666.github.io/tags/shortcut/"},{"name":"css","slug":"css","permalink":"https://jojoyang666.github.io/tags/css/"}]}