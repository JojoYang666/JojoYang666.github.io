{"meta":{"title":"Jojo's Blog","subtitle":"","description":"","author":"Jojo Yang","url":"https://jojoyang666.github.io","root":"/"},"pages":[{"title":"Binary Indexed Tree","date":"2020-07-01T18:27:22.000Z","updated":"2020-07-01T18:27:22.044Z","comments":true,"path":"Binary-Indexed-Tree/index.html","permalink":"https://jojoyang666.github.io/Binary-Indexed-Tree/index.html","excerpt":"","text":""},{"title":"GraphQL","date":"2020-09-22T19:10:03.000Z","updated":"2020-09-22T19:10:03.310Z","comments":true,"path":"GraphQL/index.html","permalink":"https://jojoyang666.github.io/GraphQL/index.html","excerpt":"","text":""},{"title":"JavaScript","date":"2020-06-22T18:47:05.000Z","updated":"2020-06-22T18:47:05.243Z","comments":true,"path":"JavaScript/index.html","permalink":"https://jojoyang666.github.io/JavaScript/index.html","excerpt":"","text":""},{"title":"Algorithms","date":"2020-06-23T06:11:50.000Z","updated":"2020-06-23T06:11:50.975Z","comments":true,"path":"Algorithms/index.html","permalink":"https://jojoyang666.github.io/Algorithms/index.html","excerpt":"","text":""},{"title":"Leetcode","date":"2020-07-16T05:13:59.000Z","updated":"2020-07-16T05:13:59.728Z","comments":true,"path":"Leetcode/index.html","permalink":"https://jojoyang666.github.io/Leetcode/index.html","excerpt":"","text":""},{"title":"Redux","date":"2020-09-22T22:45:21.000Z","updated":"2020-09-22T22:45:21.835Z","comments":true,"path":"Redux/index.html","permalink":"https://jojoyang666.github.io/Redux/index.html","excerpt":"","text":""},{"title":"System Design","date":"2020-09-22T15:34:29.000Z","updated":"2020-09-22T15:34:29.424Z","comments":true,"path":"System-Design/index.html","permalink":"https://jojoyang666.github.io/System-Design/index.html","excerpt":"","text":""},{"title":"React","date":"2020-06-25T16:52:57.000Z","updated":"2020-06-25T16:52:57.456Z","comments":true,"path":"React/index.html","permalink":"https://jojoyang666.github.io/React/index.html","excerpt":"","text":""},{"title":"Work","date":"2020-10-03T00:02:01.000Z","updated":"2020-10-03T00:02:01.708Z","comments":true,"path":"Work/index.html","permalink":"https://jojoyang666.github.io/Work/index.html","excerpt":"","text":""},{"title":"python","date":"2020-07-02T19:07:50.000Z","updated":"2020-07-02T19:07:50.445Z","comments":true,"path":"python/index.html","permalink":"https://jojoyang666.github.io/python/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-22T01:51:07.000Z","updated":"2020-06-22T01:52:06.868Z","comments":true,"path":"categories/index.html","permalink":"https://jojoyang666.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-22T01:50:56.000Z","updated":"2020-06-22T01:51:38.044Z","comments":true,"path":"tags/index.html","permalink":"https://jojoyang666.github.io/tags/index.html","excerpt":"","text":""},{"title":"tools","date":"2020-06-22T22:34:37.000Z","updated":"2020-06-22T22:34:37.999Z","comments":true,"path":"tools/index.html","permalink":"https://jojoyang666.github.io/tools/index.html","excerpt":"","text":""},{"title":"读书","date":"2020-07-20T00:59:21.000Z","updated":"2020-07-20T00:59:21.372Z","comments":true,"path":"读书/index.html","permalink":"https://jojoyang666.github.io/%E8%AF%BB%E4%B9%A6/index.html","excerpt":"","text":""}],"posts":[{"title":"Segment Tree","slug":"Segment-Tree","date":"2020-11-17T05:17:30.000Z","updated":"2020-11-17T05:23:22.131Z","comments":true,"path":"2020/11/16/Segment-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/11/16/Segment-Tree/","excerpt":"","text":"线段树可以在O(logn) 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 Code12345678910111213141516171819202122232425262728293031323334class SegmentTree: def __init__(self, length): self.nodes = [0]*(length*4)# --&gt; length *4 self.n = length def add(self, num): self._addUtil(num, 0, self.n, 0) # Essentialy it tells count of numbers &lt; num., at this time num has not inserted yet def getCountLessThan(self, num): return self._getUtil(0, num, 0, self.n, 0) def _addUtil(self, num, l, r, node): if not (l &lt;= num &lt;= r): return if l == r: self.nodes[node] += 1 return mid = (l + r)/2 self._addUtil(num, l, mid, 2 * node + 1) self._addUtil(num, mid + 1, r, 2 * node + 2) self.nodes[node] = self.nodes[2 * node + 1] + self.nodes[2 * node + 2] def _getUtil(self, ql, qr, l, r, node): if qr &lt; l or ql &gt; r: return 0 if ql &lt;= l and qr &gt;= r: return self.nodes[node] mid = (l + r)/2 return self._getUtil(ql, qr, l, mid, 2 * node + 1) + self._getUtil(ql, qr, mid + 1, r, 2 * node + 2)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits","slug":"1505-Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits","date":"2020-11-17T05:10:27.000Z","updated":"2020-11-17T05:48:48.816Z","comments":true,"path":"2020/11/16/1505-Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits/","link":"","permalink":"https://jojoyang666.github.io/2020/11/16/1505-Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits/","excerpt":"","text":"when we move a digit to left, other digit are shifted to right. i.e 432 got shifted to right by 1. to calculate the correct number of shifts, we will need to also store how many elements before d already shifted. We will use segment tree for this. —&gt; a is the number of elements before d already sgifted, shifted means the digit must less than a Choose first smallest d that is in reach of k.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class SegmentTree: def __init__(self, length): self.nodes = [0]*(length*4) self.n = length def add(self, num): self._addUtil(num, 0, self.n, 0) # Essentialy it tells count of numbers &lt; num. def getCountLessThan(self, num): return self._getUtil(0, num, 0, self.n, 0) def _addUtil(self, num, l, r, node): if not (l &lt;= num &lt;= r): return if l == r: self.nodes[node] += 1 return mid = (l + r)/2 self._addUtil(num, l, mid, 2 * node + 1) self._addUtil(num, mid + 1, r, 2 * node + 2) self.nodes[node] = self.nodes[2 * node + 1] + self.nodes[2 * node + 2] def _getUtil(self, ql, qr, l, r, node): if qr &lt; l or ql &gt; r: return 0 if ql &lt;= l and qr &gt;= r: return self.nodes[node] mid = (l + r)/2 return self._getUtil(ql, qr, l, mid, 2 * node + 1) + self._getUtil(ql, qr, mid + 1, r, 2 * node + 2)class Solution(object): def minInteger(self, num, k): \"\"\" :type num: str :type k: int :rtype: str \"\"\" pqs = [[] for _ in range(10)] for i, c in enumerate(num): idx = int(c) heapq.heappush(pqs[idx], i) ans = \"\" segmentTree = SegmentTree(len(num)) for i in range(len(num)): for digit in range(10): if len(pqs[digit]) != 0: pos = pqs[digit][0] shift = segmentTree.getCountLessThan(pos) if pos - shift &lt;= k: k -= pos - shift segmentTree.add(pos) heapq.heappop(pqs[digit]) ans += str(digit) break return ans 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def minInteger(self, num, k): \"\"\" :type num: str :type k: int :rtype: str \"\"\" len_num = len(num) if k &gt;= len_num * (len_num - 1) / 2: return ''.join(sorted(num)) pos = [[] for _ in range(10)] for i in range(len_num-1, -1, -1): pos[int(num[i])].append(i) prev, ans = [], '' candi = list(range(10)) while k and len(ans) &lt; len_num: for di in candi[:]: if pos[di]: index = pos[di][-1] place = bisect.bisect(prev, index) if index - place &lt;= k: prev.insert(place, index) k -= index - place pos[di].pop() ans += str(di) break else: candi.remove(di) if k == 0 and len(ans) &lt; len_num: prev = set(prev) return ans + ''.join(ch for i, ch in enumerate(num) if i not in prev) else: return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"827. Making A Large Island","slug":"827-Making-A-Large-Island","date":"2020-11-16T22:59:25.000Z","updated":"2020-11-16T23:00:12.373Z","comments":true,"path":"2020/11/16/827-Making-A-Large-Island/","link":"","permalink":"https://jojoyang666.github.io/2020/11/16/827-Making-A-Large-Island/","excerpt":"","text":"cornor case all is 1 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def largestIsland(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" N = len(grid) def neighbors(r,c): for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)): if 0 &lt;= nr &lt; N and 0 &lt;= nc &lt; N: yield nr, nc def dfs(r, c, index): ans = 1 grid[r][c] = index for nr, nc in neighbors(r, c): if grid[nr][nc] == 1: ans += dfs(nr, nc, index) return ans area = &#123;&#125; index = 2 for r in xrange(N): for c in xrange(N): if grid[r][c] == 1: area[index] = dfs(r, c, index) index += 1 ans = max(area.values() or [0]) # cornor case all is 1 for r in xrange(N): for c in xrange(N): if grid[r][c] == 0: seen = &#123;grid[nr][nc] for nr, nc in neighbors(r, c) if grid[nr][nc] &gt; 1&#125; ans = max(ans, 1 + sum(area[i] for i in seen)) return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"913. Cat and Mouse","slug":"913-Cat-and-Mouse","date":"2020-11-16T21:14:27.000Z","updated":"2020-11-16T22:35:19.513Z","comments":true,"path":"2020/11/16/913-Cat-and-Mouse/","link":"","permalink":"https://jojoyang666.github.io/2020/11/16/913-Cat-and-Mouse/","excerpt":"","text":"Thinking state of the game (m, c, t) m is the location of the mouse c is the location of the cat t is 1 if it’s mouse’s move t is 2 if it is cat’s move States forms a graph: the player whose turn it has vaious moves which can be considered as outgoing edges from this node to other nodes. The node can be either colored Mouse, Cat, or Draw depending on which player is assured victory we will corlor the each node marked as DRAW: – suppose the current turn is Mouse Immediate coloring: if there is a child that is colored Mouse, this will be draw Eventual coloring: if all children are colored CAT, this node will be colired CAT Repeatedly do this kind of coloring until no node satisfies the above conditions. To perform this coloring efficiently, we will use a queue and perform a bottom-up percolation: Enqueue any node initially colored For every node in the queue, for each parent of that node: For every node in the queue, for each parent of that node: If you can’t, then decrement the side-count of the number of children marked DRAW. If it becomes zero, then do an “eventual coloring” of this parent. All parents that were colored in this manner get enqueued to the queue. Color the graph bottom up, final res is color[1, 2, 1], mouse 先下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def catMouseGame(self, graph): \"\"\" :type graph: List[List[int]] :rtype: int \"\"\" N = len(graph) # 1: mouse; 2: Cat def parents(m, c, t): if t == 2: for m2 in graph[m]: yield m2, c, 3-t else: for c2 in graph[c]: if c2: # current is mouse'turn, previous is cat and cat cannot goto the hole yield m, c2, 3-t DRAW, MOUSE, CAT = 0, 1, 2 color = collections.defaultdict(int) degree = &#123;&#125; for m in xrange(N): for c in xrange(N): degree[m, c, 1] = len(graph[m]) # # of mouse to choose for next turn degree[m, c, 2] = len(graph[c]) - (0 in graph[c]) # # of cat to choose for next turn, cat is not allowed to travel to hole # initial color from bottom up queue = collections.deque([]) for i in xrange(N): for t in xrange(1, 3): color[0, i, t] = MOUSE # no matter which node i code to the node 0, no matter whose turn to it, it is Mouse to win queue.append((0, i, t, MOUSE)) if i &gt; 0: color[i, i, t] = CAT queue.append((i, i, t, CAT)) # from node i to node i(means 2 different player), no matter whose to turn, it is cat win it, because mouse and cat arrive at the same node while queue: i, j, t, c = queue.popleft() for i2, j2, t2 in parents(i, j, t): # find which node comes to this pos if color[i2, j2, t2] is DRAW: # not make a dicision yet if t2 == c: # parent is t2 to turn, after t2 make decision, it goes to [i, j, t] state, this state is c to win, if t2 == c, color i2, j2, t2 to c, t2 make itself to win, add append it to the list color[i2, j2, t2] = c queue.append((i2, j2, t2, c)) else: # supose (i, j, t) is mouse to win, but current is cat, we remove this edge(do not go this way), if after remove, we do not have more ways to play, then it will be mouse to win, thus update it degree[i2, j2, t2] -= 1 if degree[i2, j2, t2] == 0: # t2 have no choice to make itself win, color it to the 3-t2 color[i2, j2, t2] = 3 - t2 queue.append((i2, j2, t2, 3 - t2)) # get the final state append it to the queue return color[1, 2, 1] # root state is mouse at pos 1, cat at pos 2, mouse play first","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"MIN-MAX","slug":"MIN-MAX","date":"2020-11-16T20:44:44.000Z","updated":"2020-11-16T20:52:57.601Z","comments":true,"path":"2020/11/16/MIN-MAX/","link":"","permalink":"https://jojoyang666.github.io/2020/11/16/MIN-MAX/","excerpt":"","text":"适合的游戏 零和游戏（Zero-sum Game）：意思就是你死我活，一方的胜利代表另一方的失败，比如，象棋，五子棋等。 完全信息（Perfect Information）：玩家知道之前所有的步骤。象棋就是完全信息，因为玩家是交替着落子，且之前的步骤都能在棋盘上体现，但是石头剪子布就不是。这样的游戏通常可以把他们看作一个树状图，把每一种可能性列出来。比如下面这个井字棋游戏，Max代表你自己，Min代表你的对手。 剪枝","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"174. Dungeon Game","slug":"174-Dungeon-Game-1","date":"2020-11-16T20:13:03.000Z","updated":"2020-11-16T20:13:22.913Z","comments":true,"path":"2020/11/16/174-Dungeon-Game-1/","link":"","permalink":"https://jojoyang666.github.io/2020/11/16/174-Dungeon-Game-1/","excerpt":"","text":"12345678910111213141516171819202122232425262728class Solution(object): def calculateMinimumHP(self, dungeon): \"\"\" :type dungeon: List[List[int]] :rtype: int \"\"\" rows, cols = len(dungeon), len(dungeon[0]) dp = [[float('inf')]*cols for _ in range(rows)] def get_min_health(curCell,nextRow, nextCol): if nextRow &gt;= rows or nextCol &gt;= cols: return float('inf') nextCell = dp[nextRow][nextCol] return max(nextCell - curCell, 1) for row in reversed(range(rows)): for col in reversed(range(cols)): currCell = dungeon[row][col] right_health = get_min_health(currCell, row, col+1) down_health = get_min_health(currCell, row+1, col) min_health = min(right_health, down_health) if min_health != float('inf'): dp[row][col] = min_health else: dp[row][col] = 1 if currCell &gt;= 0 else (1-currCell) return dp[0][0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1473. Paint House III","slug":"1473-Paint-House-III","date":"2020-11-16T20:04:58.000Z","updated":"2020-11-16T20:10:42.112Z","comments":true,"path":"2020/11/16/1473-Paint-House-III/","link":"","permalink":"https://jojoyang666.github.io/2020/11/16/1473-Paint-House-III/","excerpt":"","text":"dp[color, blocks]: the minimum cost with current house are painted in color and blocks neighbors up to now For each cell, calculate the range of possible neighborhoods number To reduce the space, thus when iterate to each house, update the space 1234567891011121314151617181920class Solution(object): def minCost(self, houses, cost, m, n, target): \"\"\" :type houses: List[int] :type cost: List[List[int]] :type m: int :type n: int :type target: int :rtype: int \"\"\" dp, dp2 = &#123;(0, 0): 0&#125;, &#123;&#125; for i, house in enumerate(houses): for corlor in range(1, n+1) if house == 0 else [house]: for col, nei in dp: nei2 = nei + (col != corlor) if nei2 &gt; target: continue dp2[(corlor, nei2)] = min(dp2.get((corlor, nei2), float('inf')), dp[col, nei] + (cost[i][corlor-1] if corlor != house else 0)) dp, dp2 = dp2, &#123;&#125; return min([dp[c, b] for c, b in dp if b == target] or [-1])","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"642. Design Search Autocomplete System","slug":"642-Design-Search-Autocomplete-System","date":"2020-11-16T18:03:53.000Z","updated":"2020-11-16T18:04:31.825Z","comments":true,"path":"2020/11/16/642-Design-Search-Autocomplete-System/","link":"","permalink":"https://jojoyang666.github.io/2020/11/16/642-Design-Search-Autocomplete-System/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class TrieNode(object): def __init__(self): self.children = &#123;&#125; self.isEnd = False self.data = None self.rank = 0 class AutocompleteSystem(object): def __init__(self, sentences, times): \"\"\" :type sentences: List[str] :type times: List[int] \"\"\" self.root = TrieNode() self.keyword = \"\" for i, sentence in enumerate(sentences): self.addRecord(sentence, times[i]) def input(self, c): \"\"\" :type c: str :rtype: List[str] \"\"\" results = [] if c != '#': self.keyword += c results = self.search(self.keyword) else: self.addRecord(self.keyword, 1) self.keyword = \"\" return [item[1] for item in sorted(results)[:3]] def addRecord(self, sentence, hot): p = self.root for c in sentence: if c not in p.children: p.children[c] = TrieNode() p = p.children[c] p.isEnd = True p.data = sentence p.rank -= hot def dfs(self, root): ret = [] if root: if root.isEnd: ret.append((root.rank, root.data)) for child in root.children: ret.extend(self.dfs(root.children[child])) return ret def search(self, sentence): p = self.root for c in sentence: if c not in p.children: return [] p = p.children[c] return self.dfs(p) # Your AutocompleteSystem object will be instantiated and called as such:# obj = AutocompleteSystem(sentences, times)# param_1 = obj.input(c)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"715. Range Module","slug":"715-Range-Module","date":"2020-11-16T07:05:59.000Z","updated":"2020-11-16T07:49:24.793Z","comments":true,"path":"2020/11/15/715-Range-Module/","link":"","permalink":"https://jojoyang666.github.io/2020/11/15/715-Range-Module/","excerpt":"","text":"self.X: is the coordinates where track might start/stop self.track: whether tracking is on the coordinate to its right 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class RangeModule(object): def __init__(self): self.X = [0, 10**9] self.track = [False] * 2 def addRange(self, left, right): \"\"\" :type left: int :type right: int :rtype: None \"\"\" self._addRange(left, right) def _addRange(self, left, right, track=True): \"\"\" :type left: int :type right: int :rtype: None \"\"\" def index(x): i = bisect.bisect_left(self.X, x) if self.X[i] != x: self.X.insert(i, x) self.track.insert(i, self.track[i-1]) # find the correct the x pos, add track value here, because this is maybe the the stop point, in otherwords, we will remove the end from the list, thus need to keep the previous value #Because if the num at i-1 is tracked, there is an original interval covering the new val, and we need to keep this coverage, and vice versa. Even self.track is updated afterwards, the item at rightIndex won't be updated there. Removing interval [left, right) does not affect the track status of num right. return i i = index(left) j = index(right) self.X[i:j] = [left] self.track[i:j] = [track] def queryRange(self, left, right): \"\"\" :type left: int :type right: int :rtype: bool \"\"\" i = bisect.bisect(self.X, left) - 1 j = bisect.bisect_left(self.X, right) return all(self.track[i:j]) def removeRange(self, left, right): \"\"\" :type left: int :type right: int :rtype: None \"\"\" self._addRange(left, right, False)# Your RangeModule object will be instantiated and called as such:# obj = RangeModule()# obj.addRange(left,right)# param_2 = obj.queryRange(left,right)# obj.removeRange(left,right)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"753. Cracking the Safe","slug":"753-Cracking-the-Safe","date":"2020-11-15T06:30:45.000Z","updated":"2020-11-15T06:53:28.974Z","comments":true,"path":"2020/11/14/753-Cracking-the-Safe/","link":"","permalink":"https://jojoyang666.github.io/2020/11/14/753-Cracking-the-Safe/","excerpt":"","text":"there are k ** n possible password, thus for loop from 0 to k ** n try to create new password from previuos one, and add to visited Cornor case initial state is 000 we need to tranvse from back to end: k-1, k-2, …0 if we tranverse from 0 to k, we will stuck: for example n = 2, k =2 (2^2=4) initial: 0 0(i = 0– 0) -&gt; 00(i = 1 – 0) -&gt; 001(i = 2 –1) -&gt; 0010(i=3 –0) stuck herenot generate any y in for loop if tranverse from k to 0: 0 i= 0 last digit = 0 01 i= 1 last digit = 1 011 i= 2 last digit = 1 0110 i= 3 last digit = 0 “01100”123456789101112131415161718class Solution(object): def crackSafe(self, n, k): \"\"\" :type n: int :type k: int :rtype: str \"\"\" ans = \"0\" * (n-1) visits = set() for x in range(k ** n): current = ans[-n+1:] if n &gt; 1 else \"\" for y in range(k-1, -1, -1): if current + str(y) not in visits: visits.add(current + str(y)) ans += str(y) break return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Hierholzer Algorithm","slug":"Hierholzer-Algorithm","date":"2020-11-15T05:36:53.000Z","updated":"2020-11-15T05:48:52.023Z","comments":true,"path":"2020/11/14/Hierholzer-Algorithm/","link":"","permalink":"https://jojoyang666.github.io/2020/11/14/Hierholzer-Algorithm/","excerpt":"","text":"Euler path: a path visiting every edge exactly once Euler circuit: an Euler path ending where it started. Any connected directed graph where all nodes have equal in-degree and out-degree has an Euler circuit 欧拉图判定定理： 含有欧拉回路的图称为欧拉图，含有欧拉路径的图称为半欧拉图。 无向图中，如果所有顶点的度数都为偶数，则为欧拉图；如果有两个顶点的度数为奇数，其他的为偶数，则为半欧拉图。 有向图中，如果所有顶点的入度等于出度，那么就是欧拉图。判定半欧拉图的方法也很简单，大家可以自行推理。 Hierholzer’s algorithmoverall： 现给出一个有向图，且为欧拉图。求欧拉回路。 Starting from a vertex u, we walk through (unwalked) edges until we get stuck. Because the in-degrees and out-degrees of each node are equal, we can only get stuck at u, which forms a cycle. Now, for any node v we had visited that has unwalked edges, we start a new cycle from v with the same procedure as above, and then merge the cycles together to form a new cycle u \\rightarrow \\dots \\rightarrow v \\rightarrow \\dots \\rightarrow v \\rightarrow \\dots \\rightarrow uu→⋯→v→⋯→v→⋯→u.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"730. Count Different Palindromic Subsequences","slug":"730-Count-Different-Palindromic-Subsequences","date":"2020-11-15T05:18:03.000Z","updated":"2020-11-15T05:22:28.979Z","comments":true,"path":"2020/11/14/730-Count-Different-Palindromic-Subsequences/","link":"","permalink":"https://jojoyang666.github.io/2020/11/14/730-Count-Different-Palindromic-Subsequences/","excerpt":"","text":"using memo + dfs 因为只有4个不一样的字符， 所以我们只用考虑4种情况 如果s[i] == S[j], 那么就有a, aa, a*a, * represent memo[i+1][j] otherwise it would be 112345678910111213141516171819202122232425262728class Solution(object): def countPalindromicSubsequences(self, S): \"\"\" :type S: str :rtype: int \"\"\" # substring is starting from start in S, end with end in S not included def cache(start, end): if end &lt;= start + 2: return end - start if (start, end) not in memo: memo[(start, end)] = DFS(start, end) return memo[(start, end)] def DFS(start, end): count, segment = 0, S[start: end] for x in 'abcd': try: i = segment.index(x) + start j = segment.rindex(x) + start except: continue count += cache(i+1, j) + 2 if i != j else 1 return count%(10**9 + 7) memo = &#123;&#125; return cache(0, len(S))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"864. Shortest Path to Get All Keys","slug":"864-Shortest-Path-to-Get-All-Keys","date":"2020-11-14T23:55:32.000Z","updated":"2020-11-15T04:00:57.942Z","comments":true,"path":"2020/11/14/864-Shortest-Path-to-Get-All-Keys/","link":"","permalink":"https://jojoyang666.github.io/2020/11/14/864-Shortest-Path-to-Get-All-Keys/","excerpt":"","text":"用BFS node用位置+current key来表示 corner case: 最优解可能从起点出发同时再路过起点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution(object): def shortestPathAllKeys(self, grid): \"\"\" :type grid: List[str] :rtype: int \"\"\" if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) all_keys = [0] * 6 for i in range(m): for j in range(n): if grid[i][j] == '@': i_start, j_start = i, j elif grid[i][j].islower(): all_keys[ord(grid[i][j]) - ord('a')] = 1 all_keys = tuple(all_keys) curr_level = [(i_start, j_start, tuple(6*[0]))] visited = &#123;(i_start, j_start, tuple(6*[0]))&#125; moves = 0 while curr_level: next_level = [] for x, y, keys in curr_level: for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: r, c = x + dx, y + dy if 0 &lt;= r &lt; m and 0 &lt;= c &lt; n and grid[r][c] != '#': if grid[r][c] in '.@': if (r, c, keys) not in visited: visited.add((r, c, keys)) next_level.append((r, c, keys)) elif grid[r][c].islower(): new_keys = list(keys) new_keys[ord(grid[r][c]) - ord('a')] = 1 new_keys = tuple(new_keys) if new_keys == all_keys: return moves + 1 if (r, c, new_keys) not in visited: visited.add((r, c, new_keys)) next_level.append((r, c, new_keys)) else: if keys[ord(grid[r][c].lower()) - ord('a')] == 1 and (r, c, keys) not in visited: visited.add((r, c, keys)) next_level.append((r, c, keys)) curr_level = next_level moves += 1 return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1274. Number of Ships in a Rectangle","slug":"1274-Number-of-Ships-in-a-Rectangle","date":"2020-11-14T22:26:38.000Z","updated":"2020-11-14T23:54:49.109Z","comments":true,"path":"2020/11/14/1274-Number-of-Ships-in-a-Rectangle/","link":"","permalink":"https://jojoyang666.github.io/2020/11/14/1274-Number-of-Ships-in-a-Rectangle/","excerpt":"","text":"Divide to 4 quaters recursive to find it and sum of it 123456789101112131415161718192021222324252627282930313233343536# \"\"\"# This is Sea's API interface.# You should not implement it, or speculate about its implementation# \"\"\"#class Sea(object):# def hasShips(self, topRight, bottomLeft):# \"\"\"# :type topRight: Point# :type bottomLeft: Point# :rtype bool# \"\"\"##class Point(object):# def __init__(self, x, y):# self.x = x# self.y = yclass Solution(object): def countShips(self, sea, topRight, bottomLeft): \"\"\" :type sea: Sea :type topRight: Point :type bottomLeft: Point :rtype: integer \"\"\" def count((x, X), (y, Y)): if x &gt; X or y &gt; Y or not sea.hasShips(Point(X, Y), Point(x, y)): return 0 if x == X and y == Y: return 1 xm, ym = (x + X)/2, (y + Y)/2 xranges = (x, xm), (xm+1, X) yranges = (y, ym), (ym+1, Y) return sum(count(newx, newy) for newx in xranges for newy in yranges) return count((bottomLeft.x, topRight.x), (bottomLeft.y, topRight.y))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid","slug":"1368-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid","date":"2020-11-14T21:01:19.000Z","updated":"2020-11-14T21:25:16.891Z","comments":true,"path":"2020/11/14/1368-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid/","link":"","permalink":"https://jojoyang666.github.io/2020/11/14/1368-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid/","excerpt":"","text":"dfs and bfs combination using bfs to find the minimum path(cost) to the target –&gt; in this problem: the length of path is k using dfs to update the node for the next level dfs to find the current node can reach to(if change current node) update dp only when the dp value is inf Find out all reachable nodes without changing anything.Save all new visited nodes to a queue bfs.Now iterate the queue 1 For each node, try changing it to all 3 other direction 2 Save the new reachable and not visited nodes to the queue. 3 repeat step 3 update dp only dp is inf 12345678910111213141516171819202122232425262728class Solution(object): def minCost(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" n, m, inf, k = len(grid), len(grid[0]), 10**9, 0 dp = [[inf]*m for i in xrange(n)] dirt = [[0, 1], [0, -1], [1, 0], [-1, 0]] bfs = [] def dfs(x, y): if not (0 &lt;= x &lt; n and 0 &lt;= y &lt; m and dp[x][y] == inf): return dp[x][y] = k bfs.append([x, y]) dfs(x + dirt[grid[x][y]-1][0], y + dirt[grid[x][y] - 1][1]) dfs(0, 0) while bfs: k += 1 bfs, bfs2 = [], bfs [dfs(x + i, y + j) for x, y in bfs2 for i, j in dirt] return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"773. Sliding Puzzle","slug":"773-Sliding-Puzzle","date":"2020-11-14T00:21:25.000Z","updated":"2020-11-14T02:12:14.749Z","comments":true,"path":"2020/11/13/773-Sliding-Puzzle/","link":"","permalink":"https://jojoyang666.github.io/2020/11/13/773-Sliding-Puzzle/","excerpt":"","text":"convert it to graph using BFS to find the minimun path Cornor Case if nei/C != pos/C and nei%C != pos%C: continue &lt;—- this happens because we convert to dismension to 1 dimension Considering the case [[1,2,3], [0,4,5]]. If the next move is to swap “3” and “0”, it does not violate the condition that the index of the next position of zero, indicated by variable “nei” remaining between 0 and 6. However, it is NOT POSSIBLE to actually swap 3 and 0, because they are not adjacent in a real grid. This can be easily found by drawing a grid.12345678910111213141516171819202122232425262728293031class Solution(object): def slidingPuzzle(self, board): \"\"\" :type board: List[List[int]] :rtype: int \"\"\" R, C = 2, 3 start = tuple(itertools.chain(*board)) queue = collections.deque([(start, start.index(0), 0)]) seen = &#123;start&#125; target = tuple(range(1, R*C) + [0]) while queue: board, pos, depth = queue.popleft() if board == target: return depth for d in (-1, 1, C, -C): nei = pos + d if nei/C != pos/C and nei%C != pos%C: continue if 0&lt;= nei &lt; R*C: newboard = list(board) newboard[pos], newboard[nei] = newboard[nei], newboard[pos] newt = tuple(newboard) if newt not in seen: seen.add(newt) queue.append((newt, nei, depth+1)) return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"dropbox","slug":"dropbox","date":"2020-11-13T21:38:42.000Z","updated":"2020-11-13T23:19:35.980Z","comments":true,"path":"2020/11/13/dropbox/","link":"","permalink":"https://jojoyang666.github.io/2020/11/13/dropbox/","excerpt":"","text":"Why Cloud Storage Availability: Have data availability anywhere, anytime Access their files/photos from any device whenever and wherever they like. Reliability and Durability Offers 100% reliability and durability of data Never lose their data by keeping multiple copies of the data stored on different geographically located servers. Scalability Unlimited storage as long as you are ready to pay for it Requirements and Goals of the System Upload and download their files/photos from any device. Share files or folders with other users. Support automatic synchronization between devices After updating a file on one device, it should get synchronized on all devices. Support storing large files up to a GB. ACID-ity is required. Atomicity, Consistency, Isolation and Durability of all file operations should be guaranteed. support offline editing add/delete/modify files while offline as soon as they come online, all their changes should be synced to the remote servers and other online devices Extended Requirements Support snapshotting of the data, so that users can go back to any version of the files Some Design Considerations Expect huge read and write volumes Read to write ratio is expected to be nearly the same files can be stored in small parts or chunks (say 4MB) All failed operations shall only be retried for smaller parts of a file Fails to upload a file, then only the failing chunk will be retried Reduce the amount of data exchange by transferring updated chunks only Removing duplicate chunks, we can save storage space and bandwidth usage Keeping a local copy of the metadata (file name, size, etc.) with the client can save us a lot of round trips to the server. For small changes, clients can intelligently upload the diffs instead of the whole chunk. Capacity Estimation and Constraints users: 500M Daily Active Users: 100M Average each user connects from three different devices On average if a user has 200 files/photos, 500M * 200 = 100 billion total files Average file size is 100KB: 100B * 100KB =&gt; 10PB High Level Design Store files and their metadata information like File Name, File Size, Directory, etc. Store who this file is shared with Block Servers: help the clients to upload/download files to Cloud Storage MetaData servers: facilitate updating metadata about files and users, (SQL or NoSQL database) Synchronization servers: Notify all clients whenever an update happens so they can synchronize their files. Component DesignClientEssential operations for the client Upload and download files. Detect file changes in the workspace folder. Handle conflict due to offline or concurrent updates. How do we handle file transfer efficiently? break each file into smaller chunks transfer only those chunks that are modified and not the whole file Calculate what could be an optimal chunk size Storage devices we use in the cloud to optimize space utilization and input/output operations per second (IOPS) Network bandwidth Average file size in the storage In our metadata, we should also keep a record of each file and the chunks that constitute it. Should we keep a copy of metadata with Client?yes offline updates Saves a lot of round trips to update remote metadata. How can clients efficiently listen to changes happening with other clients? clients periodically check with the server if there are any changes Problem: have a delay in reflecting changes locally clients will be checking for changes periodically compared to a server notifying whenever there is some change If the client frequently checks the server for changes, it will not only be wasting bandwidth as the server has to return an empty response most of the time be keeping the server busy Pulling information in this manner is not scalable. Use HTTP long polling DetailDivide our client into following four parts: Internal Metadata Database: keep track of all the files, chunks, their versions, and their location in the file system. Chunker: split the files into smaller pieces called chunks reconstructing a file from its chunks. will detect the parts of the files that have been modified by the user and only transfer those parts to the Cloud Storage will save us bandwidth and synchronization time Watcher monitor the local workspace folders and notify the Indexer of any actions performed by ther users listens to any changes happening on other clients that are broadcasted by Synchronization service. Indexer process the events received from the Watcher and update the internal metadata database with information about the chunks of the modified files. Once the chunks are successfully submitted/downloaded to the Cloud Storage Indexer will communicate with the remote Synchronization Service to broadcast changes to other clients and update remote metadata database. How should clients handle slow servers?If a server is too slow to respond, clients should delay their retries and this delay should increase exponentially. Should mobile clients sync remote changes immediately?Unlike desktop or web clients, mobile clients usually sync on demand to save user’s bandwidth and space. Metadata Database maintaining the versioning and metadata information about files/chunks, users, and workspaces. The Synchronization Service should be able to provide a consistent viewof the files using a database, especially if more than one user is working with the same file simultaneously. NoSQL data stores do not support ACID properties in favor of scalability and performance we need to incorporate the support for ACID properties programmatically in the logic of our Synchronization Service in case we opt for this kind of database. using a relational database can simplify the implementation of the Synchronization Service as they natively support ACID properties. metadata Database should be storing information about following objects: Chunks Files User Devices Workspace (sync folders) Synchronization Service Synchronizes clients’ local databases with the information stored in the remote Metadata DB. Desktop clients communicate with the Synchronization Service obtain updates from the Cloud Storage send files and updates to the Cloud Storage and, potentially, other users. If a client was offline for a period, it polls the system for new updates as soon as they come online. When the Synchronization Service receives an update request, it checks with the Metadata Database for consistency and then proceeds with the update. Subsequently, a notification is sent to all subscribed users or devices to report the file update. Synchronization Service can employ a differencing algorithm to reduce the amount of the data that needs to be synchronized TO achieve a better response time transmit the difference between two versions of a file. Therefore, only the part of the file that has been changed is transmitted. dividing our files into 4MB chunks and will be transferring modified chunks only. Server and clients can calculate a hash (e.g., SHA-256) to see whether to update the local copy of a chunk or not. On the server, if we already have a chunk with a similar hash (even from another user), we don’t need to create another copy, we can use the same chunk To be able to provide an efficient and scalable synchronization protocol we can consider using a communication middleware between clients and the Synchronization Service. the messaging middleware should provide scalable message queuing change notifications to support a high number of clients using pull or push strategies. multiple Synchronization Service instances can receive requests from a global request Queue, and the communication middleware will be able to balance its load. Message Queuing ServiceCloud/Block Storage","categories":[{"name":"System Design","slug":"System-Design","permalink":"https://jojoyang666.github.io/categories/System-Design/"}],"tags":[]},{"title":"1411. Number of Ways to Paint N × 3 Grid","slug":"1411-Number-of-Ways-to-Paint-N-×-3-Grid","date":"2020-11-13T18:25:54.000Z","updated":"2020-11-13T18:54:08.724Z","comments":true,"path":"2020/11/13/1411-Number-of-Ways-to-Paint-N-×-3-Grid/","link":"","permalink":"https://jojoyang666.github.io/2020/11/13/1411-Number-of-Ways-to-Paint-N-%C3%97-3-Grid/","excerpt":"","text":"In each row, there are two patterns: 121: the first color same as the third in the row Initial the pattern has 6 states: 121, 323, 212, 313, 131,232 123: one row has three different colors Initial the pattern has 6 states: 123, 132, 213, 231, 312,321 after get all the states in nth row, the number of states in the (n+1)th row. in nth row, we have a121, a123(to represent # of states of two patterns). Then b121, b123 represent the # of states of the two patterns in the n+1 th row no two cells that share vertical o r horizontal sides have the same colour). a121: if we append pattern 121 after a121, it have 2 states: 212, 232, 313 if we append patter 123 after a121, it has 3 states: 213, 312 pattern 123 can be followed by: 212, 232, 231, 312 two 121, two 123 Thus: b121 = a121 * 3 + a123 * 2 b123 = a121 * 2 + a123 * 2 1234567891011class Solution(object): def numOfWays(self, n): \"\"\" :type n: int :rtype: int \"\"\" a121, a123, mod = 6, 6, 10**9+7 for i in xrange(n-1): a121, a123 = a121 * 3 + a123*2, a121*2 + a123*2 return (a121 + a123)%mod","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"174. Dungeon Game","slug":"174-Dungeon-Game","date":"2020-11-13T17:39:10.000Z","updated":"2020-11-13T17:46:35.132Z","comments":true,"path":"2020/11/13/174-Dungeon-Game/","link":"","permalink":"https://jojoyang666.github.io/2020/11/13/174-Dungeon-Game/","excerpt":"","text":"dp[i][j]: the minimum health needed to reach the princess at the pos i, j 记得 如果不需要的话 初始化是112345678910111213141516171819202122232425262728class Solution(object): def calculateMinimumHP(self, dungeon): \"\"\" :type dungeon: List[List[int]] :rtype: int \"\"\" rows, cols = len(dungeon), len(dungeon[0]) dp = [[float('inf')]*cols for _ in range(rows)] def get_min_health(curCell,nextRow, nextCol): if nextRow &gt;= rows or nextCol &gt;= cols: return float('inf') nextCell = dp[nextRow, nextCol] return max(nextCell - curCell, 1) for row in reversed(range(rows)): for col in reversed(range(cols)): currCell = dungeon[row][col] right_health = get_min_health(currCell, row, col+1) down_health = get_min_health(currCell, row+1, col) min_health = min(right_health, down_health) if min_health != float('inf'): dp[row][col] = min_health else: dp[row][col] = 1 if currCell &gt;= 0 else (1-currCell) return dp[0][0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"471. Encode String with Shortest Length ","slug":"471-Encode-String-with-Shortest-Length","date":"2020-11-13T07:46:49.000Z","updated":"2020-11-13T07:53:44.020Z","comments":true,"path":"2020/11/12/471-Encode-String-with-Shortest-Length/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/471-Encode-String-with-Shortest-Length/","excerpt":"","text":"using dp[i][j]: shortest length from i to j, but i must from end to start because when update dp[i][j]: will using dp[k+1][j], k+1 &gt; i —&gt; split also need to update dp[i][j] using compression, str(len(cur_s)/len(pattern)) + ‘[‘ + dp[i][k] + ‘]’ using dp[i][k] to represent best way of encoding pattern123456789101112131415161718192021222324252627282930313233class Solution(object): def encode(self, s): \"\"\" :type s: str :rtype: str \"\"\" n = len(s) dp = [[''] * n for _ in range(n)] for i in range(n-1, -1, -1): for j in range(i, n): cur_s = s[i:j+1] dp[i][j] = cur_s if len(cur_s) &gt; 4: # Try all the possilbe splits for k in range(i, j): if len(dp[i][k] + dp[k+1][j]) &lt; len(dp[i][j]): dp[i][j] = dp[i][k] + dp[k+1][j] # Try to compress the string for k in range(i, j+1): pattern = s[i:k+1] if pattern and len(cur_s)%len(pattern) == 0 and cur_s.replace(pattern, '') == '': candidate = str(len(cur_s)/len(pattern)) + '[' + dp[i][k] + ']' if len(candidate) &lt; len(dp[i][j]): dp[i][j] = candidate return dp[0][n-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"440. K-th Smallest in Lexicographical Order","slug":"440-K-th-Smallest-in-Lexicographical-Order","date":"2020-11-13T05:23:28.000Z","updated":"2020-11-13T05:42:14.871Z","comments":true,"path":"2020/11/12/440-K-th-Smallest-in-Lexicographical-Order/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/440-K-th-Smallest-in-Lexicographical-Order/","excerpt":"","text":"12345678910111213141516171819202122232425class Solution(object): def findKthNumber(self, n, k): \"\"\" :type n: int :type k: int :rtype: int \"\"\" result = 1 k -= 1 while k &gt; 0: count = 0 interval = [result, result + 1] while interval[0] &lt;= n: count += min(n+1, interval[1]) - interval[0] interval = [10*interval[0], 10*interval[1]] if k &gt;= count: result += 1 k -= count else: result *= 10 k -= 1 return result","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1312. Minimum Insertion Steps to Make a String Palindrome","slug":"1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome","date":"2020-11-13T04:43:28.000Z","updated":"2020-11-13T05:01:42.783Z","comments":true,"path":"2020/11/12/1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome/","excerpt":"","text":"convert the problem to find the longest common sequence find the longest common sequences between s and reversed(s) -&gt; m then the chars needed to add is len(s) - m 12345678910111213class Solution(object): def minInsertions(self, s): \"\"\" :type s: str :rtype: int \"\"\" n = len(s) dp = [[0]*(n+1) for _ in range(n+1)] for i in range(n): for j in range(n): dp[i+1][j+1] = dp[i][j] + 1 if s[i] == s[n-j-1] else max(dp[i][j+1], dp[i+1][j]) return n - dp[n][n]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"321. Create Maximum Number","slug":"321-Create-Maximum-Number","date":"2020-11-13T04:23:38.000Z","updated":"2020-11-13T04:28:56.958Z","comments":true,"path":"2020/11/12/321-Create-Maximum-Number/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/321-Create-Maximum-Number/","excerpt":"","text":"using dp[i]: represent the maximun subsequence of arr with length i –&gt; using maxNumber function from end to start 这个DP的方法从最大的开始到最后 after find two dps, using merge function each pop the maximum value –&gt; like merge sort 12345678910111213141516171819202122232425262728class Solution(object): def maxNumber(self, nums1, nums2, k): \"\"\" :type nums1: List[int] :type nums2: List[int] :type k: int :rtype: List[int] \"\"\" def maximum(nums, length): dp, i = &#123;length: nums&#125;, 0 while length: while i + 1 &lt; length and nums[i] &gt;= nums[i+1]: i += 1 nums = nums[:i] + nums[i+1:] length -= 1 dp[length] = nums if i &gt; 0: i -= 1 return dp m, n, result = len(nums1), len(nums2), [] dp1, dp2 = maximum(nums1, m), maximum(nums2, n) for i in range(min(m+1, k+1)): if k - i not in dp2: continue result = max(result,[max(dp1[i], dp2[k-i]).pop(0) for _ in range(k)]) return result","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1092. Shortest Common Supersequence","slug":"1092-Shortest-Common-Supersequence","date":"2020-11-13T01:57:48.000Z","updated":"2020-11-13T02:04:19.172Z","comments":true,"path":"2020/11/12/1092-Shortest-Common-Supersequence/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/1092-Shortest-Common-Supersequence/","excerpt":"","text":"Covert it to find the longest subsequences 12345678910111213141516171819202122232425262728293031class Solution(object): def shortestCommonSupersequence(self, str1, str2): \"\"\" :type str1: str :type str2: str :rtype: str \"\"\" def lcs(A, B): n, m = len(A), len(B) dp = [[\"\" for _ in xrange(m+1)] for _ in range(n+1)] for i in range(n): for j in range(m): if A[i] == B[j]: dp[i+1][j+1] = dp[i][j] + A[i] else: dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1], key=len) return dp[-1][-1] res, i, j = \"\", 0, 0 for c in lcs(str1, str2): while c != str1[i]: res += str1[i] i += 1 while c!= str2[j]: res += str2[j] j += 1 res += c i += 1 j += 1 return res + str1[i:] + str2[j:]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"834. Sum of Distances in Tree","slug":"834-Sum-of-Distances-in-Tree","date":"2020-11-12T22:48:39.000Z","updated":"2020-11-12T23:17:10.011Z","comments":true,"path":"2020/11/12/834-Sum-of-Distances-in-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/834-Sum-of-Distances-in-Tree/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031class Solution(object): def sumOfDistancesInTree(self, N, edges): \"\"\" :type N: int :type edges: List[List[int]] :rtype: List[int] \"\"\" res = [0] * N count = [1] * N graph = collections.defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def postorder(node = 0, parent = None): for child in graph[node]: if child != parent: postorder(child, node) count[node] += count[child] res[node] += res[child] + count[child] def inorder(node = 0, parent = None): for child in graph[node]: if child != parent: res[child] = res[node] - count[child] + N - count[child] inorder(child, node) postorder() inorder() return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1044. Longest Duplicate Substring","slug":"1044-Longest-Duplicate-Substring","date":"2020-11-12T21:22:18.000Z","updated":"2020-11-12T21:23:53.835Z","comments":true,"path":"2020/11/12/1044-Longest-Duplicate-Substring/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/1044-Longest-Duplicate-Substring/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334class Solution(object): def longestDupSubstring(self, S): \"\"\" :type S: str :rtype: str \"\"\" a, modulus, n = 26, 2**32, len(S) left, right = 1, n nums = [ord(S[i]) - ord('a') for i in range(n)] while left &lt;= right: mid = (right - left)/2 + left if self.search(mid, a, modulus, n, nums) != -1: left = mid + 1 else: right = mid - 1 start = self.search(left-1, a, modulus, n, nums) return S[start: start+left-1] def search(self, L, a, modulus, n, nums): h = 0 for i in range(L): h = (h*a + nums[i])%modulus seen = &#123;h&#125; al = (a**L)%modulus for start in range(1, n-L+1): h = (h*a - nums[start-1]*al + nums[start+L-1])%modulus if h in seen: return start seen.add(h) #may add the logical here to compare if the two string equal to aviod the duplicate hash value return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Rabin-Karp algorithm","slug":"Rabin-Karp-algorithm","date":"2020-11-12T20:31:21.000Z","updated":"2020-11-12T21:16:27.907Z","comments":true,"path":"2020/11/12/Rabin-Karp-algorithm/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/Rabin-Karp-algorithm/","excerpt":"","text":"Rabin-Karp algorithmsearch(L) compute the has of substring(0, L) and initiate the hashset of already seen substring with this value Iterate over the start position of substring from 1 to N-L Compute rolling hash based on the previous hash value Return start position if the hash is in the hashset, because that means a duplicate string Otherwise, ass hash in the hashset return -1, that means there is no duplicate string of length L Hash Function A good hash function can reduce the time complexity from O(NL) –&gt; O(N) Assume L is only made of the lowercase english chars, and L is not that big hashfunction would be:abcd -&gt; [0, 1, 2, 3] could be hashed as a: base value for the rolling hash function(like: 26)modulus: modulus value for the rolling hash function to avoid overflow 1234567891011121314def search(self, L, a, modulus, n, nums): h = 0 for i in range(L): h = (h*a + nums[i])%modulus seen = &#123;h&#125; al = (a**L)%modulus for start in range(1, n-L+1): h = (h*a - nums[start-1]*al + nums[start+L-1])%modulus if h in seen: return start seen.add(h) # may need to compare substring return -1","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1326. Minimum Number of Taps to Open to Water a Garden","slug":"1326-Minimum-Number-of-Taps-to-Open-to-Water-a-Garden","date":"2020-11-12T19:00:48.000Z","updated":"2020-11-12T19:59:49.656Z","comments":true,"path":"2020/11/12/1326-Minimum-Number-of-Taps-to-Open-to-Water-a-Garden/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/1326-Minimum-Number-of-Taps-to-Open-to-Water-a-Garden/","excerpt":"","text":"dp[i]: is the minimum number of taps to water [0, i] 1234567891011121314class Solution(object): def minTaps(self, n, ranges): \"\"\" :type n: int :type ranges: List[int] :rtype: int \"\"\" dp = [0] + [n+2]*n for i, item in enumerate(ranges): for j in xrange(max(0, i-item), min(n, i+item)+1): dp[j] = min(dp[j], dp[max(i-item, 0)] + 1) return dp[n] if dp[n] &lt; n+2 else -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"466. Count The Repetitions","slug":"466-Count-The-Repetitions","date":"2020-11-12T17:46:13.000Z","updated":"2020-11-12T18:32:16.487Z","comments":true,"path":"2020/11/12/466-Count-The-Repetitions/","link":"","permalink":"https://jojoyang666.github.io/2020/11/12/466-Count-The-Repetitions/","excerpt":"","text":"records[i] = (a, b) a: the number of times s1 matched to s2 which starting from s2[i:] b: After this matches done, what is the position in the s2 for next matches After getting the records, calculate res which is the number of matches with n1 of s1 final result is: res//n2 123456789101112131415161718192021222324252627class Solution(object): def getMaxRepetitions(self, s1, n1, s2, n2): \"\"\" :type s1: str :type n1: int :type s2: str :type n2: int :rtype: int \"\"\" records = [] for i in range(len(s2)): next_pos, count = i, 0 for j in range(len(s1)): if s1[j] == s2[next_pos]: next_pos += 1 if next_pos == len(s2): next_pos = 0 count += 1 records.append((count, next_pos)) res, next_pos= 0, 0 for _ in range(n1): res += records[next_pos][0] next_pos = records[next_pos][1] return res/n2","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"980. Unique Paths III","slug":"980-Unique-Paths-III","date":"2020-11-12T05:57:24.000Z","updated":"2020-11-12T06:04:11.329Z","comments":true,"path":"2020/11/11/980-Unique-Paths-III/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/980-Unique-Paths-III/","excerpt":"","text":"不能有memo是因为题目要求要走过每一个非障碍 所以 每一次到pos可能经过的障碍节点不一样所以不能memo 但是要记住用visited 本题目在原数组上面进行更改来作为visited， 最后记得还原12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution(object): def uniquePathsIII(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" rows, cols = len(grid), len(grid[0]) self.path_count = 0 non_obstacles = 0 start_row, start_col = 0, 0 for row in range(rows): for col in range(cols): if grid[row][col] &gt;= 0: non_obstacles += 1 if grid[row][col] == 1: start_row, start_col = row, col path_count = 0 def backtrack(row, col, remain): if grid[row][col] == 2 and remain == 1: self.path_count += 1 return tmp = grid[row][col] grid[row][col] = -4 # mark as visited remain -= 1 for ro, co in [(0, 1), (0, -1), (1, 0), (-1, 0)]: next_row, next_col = row + ro, col + co if (not (0&lt;= next_row &lt; rows and 0 &lt;= next_col &lt; cols)) or grid[next_row][next_col] &lt; 0: continue backtrack(next_row, next_col, remain) grid[row][col] = tmp backtrack(start_row, start_col, non_obstacles) return self.path_count","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1240. Tiling a Rectangle with the Fewest Squares","slug":"1240-Tiling-a-Rectangle-with-the-Fewest-Squares","date":"2020-11-12T04:49:00.000Z","updated":"2020-11-12T05:26:11.278Z","comments":true,"path":"2020/11/11/1240-Tiling-a-Rectangle-with-the-Fewest-Squares/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/1240-Tiling-a-Rectangle-with-the-Fewest-Squares/","excerpt":"","text":"using dfs/backtrack 从下往上填充正方形 先从height 相同且最低的位置开始填充正方形 重点是正方形12345678910111213141516171819202122232425262728class Solution(object): def tilingRectangle(self, n, m): \"\"\" :type n: int :type m: int :rtype: int \"\"\" self.best = m * n def dfs(height, moves): if all(h == n for h in height): self.best = min(self.best, moves) return if moves &gt;= self.best: return min_height = min(height) idx = height.index(min_height) ridx = idx + 1 while ridx &lt; m and height[idx] == height[ridx]: ridx += 1 for i in range(min(ridx-idx, n - min_height), 0, -1): new_height = height[:] for j in range(i): new_height[idx+j] += i dfs(new_height, moves+1) dfs([0]*m, 0) return self.best","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"428. Serialize and Deserialize N-ary Tree","slug":"428-Serialize-and-Deserialize-N-ary-Tree","date":"2020-11-12T00:28:09.000Z","updated":"2020-11-12T02:49:33.770Z","comments":true,"path":"2020/11/11/428-Serialize-and-Deserialize-N-ary-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/428-Serialize-and-Deserialize-N-ary-Tree/","excerpt":"","text":"BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990\"\"\"# Definition for a Node.class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children\"\"\"class Codec: def _serializeHelper(self, root, serializedList): queue = collections.deque() queue.append(root) queue.append(None) # add None to the queue means this is the end node of current Level while queue: node = queue.popleft() if node == None: # when we meet node is None, which means this is the end of current Level, using # in the serializedList serializedList.append('#') if queue: # Add None to seperate the next level and next of next level queue.append(None) elif node == 'C': # Add a sentinal value of \"$\" here to mark the switch to a different parent serializedList.append('$') else: # add the value of current node and all of it's children to the queeue # covert the node vall to ascii in the serializedList serializedList.append(str(node.val)+'?') for child in node.children: queue.append(child) # If this not is NOT the last one on the current level, # add a childNode as well since we move on to processing the next node. if queue[0] != None: queue.append('C') def serialize(self, root): \"\"\"Encodes a tree to a single string. :type root: Node :rtype: str \"\"\" if not root:return \"\" serializedList = [] self._serializeHelper(root, serializedList) return \"\".join(serializedList) def _deserializeHelper(self, data, rootNode): prevLevel, currentLevel = collections.deque(), collections.deque() currentLevel.append(rootNode) parentNode = rootNode i = 0 while i &lt; len(data): if data[i] == '#': prevLevel = currentLevel currentLevel = collections.deque() parentNode = prevLevel.popleft() if prevLevel else None else: if data[i] == '$': parentNode = prevLevel.popleft() if prevLevel else None else: idx = data.find('?', i) childNode = Node(int(data[i: idx]), []) currentLevel.append(childNode) parentNode.children.append(childNode) i = idx i += 1 def deserialize(self, data): \"\"\"Decodes your encoded data to tree. :type data: str :rtype: Node \"\"\" if not data: return None idx = data.find('?') rootNode = Node(int(data[0: idx]), []) self._deserializeHelper(data[idx+1:], rootNode) return rootNode# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) Recursive12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758\"\"\"# Definition for a Node.class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children\"\"\"class Codec: def serialize(self, root): \"\"\"Encodes a tree to a single string. :type root: Node :rtype: str \"\"\" serial = [] def preorder(node): if not node: return serial.append(str(node.val)) for child in node.children: preorder(child) serial.append(\"#\") preorder(root) return \" \".join(serial) def deserialize(self, data): \"\"\"Decodes your encoded data to tree. :type data: str :rtype: Node \"\"\" if not data: return None tokens = deque(data.split()) root = Node(int(tokens.popleft()), []) def helper(node): if not tokens: return while tokens[0] != \"#\": value = tokens.popleft() child = Node(int(value), []) node.children.append(child) helper(child) tokens.popleft() helper(root) return root # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"410. Split Array Largest Sum","slug":"410-Split-Array-Largest-Sum","date":"2020-11-11T22:32:58.000Z","updated":"2020-11-11T23:30:53.065Z","comments":true,"path":"2020/11/11/410-Split-Array-Largest-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/410-Split-Array-Largest-Sum/","excerpt":"","text":"Memoization + Cumulative Sum1234567891011121314151617181920212223242526272829class Solution(object): def splitArray(self, nums, m): \"\"\" :type nums: List[int] :type m: int :rtype: int \"\"\" cums = [0] for x in nums: cums.append(cums[-1] + x) cache = defaultdict(dict) return self.helper(0, nums, m, cache, cums) def helper(self, i, nums, m, cache, cums): if i == len(nums): return 0 elif m == 1: return sum(nums[i:]) else: if i in cache and m in cache[i]: return cache[i][m] cache[i][m] = float('inf') for j in range(1, len(nums)+1-i): left, right = cums[i+j] - cums[i], self.helper(i+j, nums, m-1, cache, cums) cache[i][m] = min(cache[i][m], max(left, right)) if left &gt; right: break return cache[i][m] Binary Searchbecause know the rangewe can filter the not possible ones by binary search 123456789101112131415161718192021222324252627class Solution(object): def splitArray(self, nums, m): \"\"\" :type nums: List[int] :type m: int :rtype: int \"\"\" low, high = max(nums), sum(nums) while low &lt; high: mid = (high - low)/2 + low if self.is_valid(nums, m, mid): high = mid else: low = mid + 1 return high def is_valid(self, nums, m, mid): cuts, curr_sum = 0, 0 for x in nums: curr_sum += x if curr_sum &gt; mid: cuts += 1 curr_sum = x subs = cuts + 1 return subs &lt;= m","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1153. String Transforms Into Another String ","slug":"1153-String-Transforms-Into-Another-String","date":"2020-11-11T21:58:11.000Z","updated":"2020-11-11T22:14:44.632Z","comments":true,"path":"2020/11/11/1153-String-Transforms-Into-Another-String/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/1153-String-Transforms-Into-Another-String/","excerpt":"","text":"There are two ways of transformation between str1 and str2 a -&gt; b (a in str1 convert to b directly) (一对一) If a -&gt; b &amp; a -&gt; c, return false, a can not convert mulitiple different chars in str2（一对多） a -&gt; d -&gt; c -&gt; e -&gt; m(convert a in str1 to m in str2 by several conversion) why this happen? 多对一， because there are multiple chars in str1 convert to the same char in the str2 this, we need find a extra char not in str1 as a temp, make sure all the chars in str1 can convert to strr2 Another cornor case: if there are 26 different chars in str2, we can not find the extra char return false1234567891011121314class Solution(object): def canConvert(self, str1, str2): \"\"\" :type str1: str :type str2: str :rtype: bool \"\"\" if str1 == str2: return True dp = &#123;&#125; for i, j in zip(str1, str2): if dp.setdefault(i, j) != j: return False return len(set(str2)) &lt; 26","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"407. Trapping Rain Water II","slug":"407-Trapping-Rain-Water-II","date":"2020-11-11T21:14:26.000Z","updated":"2020-11-11T21:32:46.157Z","comments":true,"path":"2020/11/11/407-Trapping-Rain-Water-II/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/407-Trapping-Rain-Water-II/","excerpt":"","text":"123456789101112131415161718192021222324252627class Solution(object): def trapRainWater(self, heightMap): \"\"\" :type heightMap: List[List[int]] :rtype: int \"\"\" if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) heap = [] visited = [[False]*n for _ in xrange(m)] for i in range(m): for j in range(n): if i == 0 or j == 0 or i == m-1 or j == n-1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True res = 0 while heap: height, i, j = heapq.heappop(heap) for r, c in ((i-1,j), (i+1,j), (i,j-1), (i,j+1)): if 0 &lt;= r &lt; m and 0 &lt;= c &lt; n and not visited[r][c]: res += max(0, height - heightMap[r][c]) heapq.heappush(heap, (max(height, heightMap[r][c]), r, c)) visited[r][c] = 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"815. Bus Routes","slug":"815-Bus-Routes","date":"2020-11-11T20:16:51.000Z","updated":"2020-11-11T20:23:38.057Z","comments":true,"path":"2020/11/11/815-Bus-Routes/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/815-Bus-Routes/","excerpt":"","text":"Using BFS Each node represent the car if node A and node B are connected, which means people can take car B by taking car A source: a collection of bus which can reach to S target: a collection of bus which can reach to T find the depth from set A to set B 1234567891011121314151617181920212223242526272829303132class Solution(object): def numBusesToDestination(self, routes, S, T): \"\"\" :type routes: List[List[int]] :type S: int :type T: int :rtype: int \"\"\" if S == T: return 0 routes = map(set, routes) graph = collections.defaultdict(set) for i, r1 in enumerate(routes): for j in xrange(i+1, len(routes)): r2 = routes[j] if any (r in r2 for r in r1): graph[i].add(j) graph[j].add(i) seen, targets = set(), set() for node, route in enumerate(routes): if S in route: seen.add(node) if T in route: targets.add(node) queue = [(node, 1) for node in seen] for node, depth in queue: if node in targets: return depth for nei in graph[node]: if nei not in seen: seen.add(nei) queue.append((nei, depth+1)) return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"354. Russian Doll Envelopes","slug":"354-Russian-Doll-Envelopes","date":"2020-11-11T19:16:51.000Z","updated":"2020-11-11T19:18:28.961Z","comments":true,"path":"2020/11/11/354-Russian-Doll-Envelopes/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/354-Russian-Doll-Envelopes/","excerpt":"","text":"1234567891011121314151617181920class Solution(object): def maxEnvelopes(self, envelopes): \"\"\" :type envelopes: List[List[int]] :rtype: int \"\"\" envelopes = sorted(envelopes, key=lambda x: (x[0], -x[1])) def lis(nums): dp = [] for i in range(len(nums)): idx = bisect.bisect_left(dp, nums[i]) if idx == len(dp): dp.append(nums[i]) else: dp[idx] = nums[i] return len(dp) return lis([item[1] for item in envelopes])","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"300. Longest Increasing Subsequence ","slug":"300-Longest-Increasing-Subsequence","date":"2020-11-11T18:43:44.000Z","updated":"2020-11-11T19:09:03.411Z","comments":true,"path":"2020/11/11/300-Longest-Increasing-Subsequence/","link":"","permalink":"https://jojoyang666.github.io/2020/11/11/300-Longest-Increasing-Subsequence/","excerpt":"","text":"O(n*n)1234567891011121314class Solution(object): def lengthOfLIS(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) O(n*logn)12345678910111213141516class Solution(object): def lengthOfLIS(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" dp = [] for i in range(len(nums)): idx = bisect.bisect_left(dp, nums[i]) print dp, idx, nums[i] if idx == len(dp): dp.append(nums[i]) else: dp[idx] = nums[i] return len(dp) dpdp array does not result in longest increasing subsequence, but length of dpdp array will give you length of LIS.Example:input: [0, 8, 4, 12, 2]dp: [0]dp: [0, 8]dp: [0, 4]dp: [0, 4, 12]dp: [0 , 2, 12","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"135. Candy","slug":"135-Candy","date":"2020-11-11T06:20:04.000Z","updated":"2020-11-11T06:31:14.124Z","comments":true,"path":"2020/11/10/135-Candy/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/135-Candy/","excerpt":"","text":"123456789101112131415161718class Solution(object): def candy(self, ratings): \"\"\" :type ratings: List[int] :rtype: int \"\"\" left2right = [1] * len(ratings) right2left = [1] * len(ratings) for i in range(1, len(ratings)): if ratings[i] &gt; ratings[i-1]: left2right[i] = left2right[i-1] + 1 for i in range(len(ratings)-2, -1, -1): if ratings[i] &gt; ratings[i+1]: right2left[i] = right2left[i+1] + 1 return sum(max(left2right[i], right2left[i]) for i in range(len(ratings)))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1359. Count All Valid Pickup and Delivery Options","slug":"1359-Count-All-Valid-Pickup-and-Delivery-Options","date":"2020-11-11T05:45:36.000Z","updated":"2020-11-11T06:01:38.489Z","comments":true,"path":"2020/11/10/1359-Count-All-Valid-Pickup-and-Delivery-Options/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/1359-Count-All-Valid-Pickup-and-Delivery-Options/","excerpt":"","text":"Assume we already have n-1 pairs, now we need to insert the nth pair To insert the first element, there are 2*(n-1) + 1 = 2n - 1 choices of the position To insert the second element, there are 2*(n-1)+1 + = 2n choices of the position because second must element go after the first element, Thus, valid the # second item insertion is: 2n/2=n becuse when insert the second item either ahead of the first one or behind of the first one, we need to remove the first situation Thus, divde 2 res: # previous sequece * # of first item insertion * # of second item insertion 1234567891011class Solution(object): def countOrders(self, n): \"\"\" :type n: int :rtype: int \"\"\" res = 1 for i in range(2, n+1): res = (2*i - 1)*i*res return res%(10**9+7)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1293. Shortest Path in a Grid with Obstacles Elimination ","slug":"1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination","date":"2020-11-11T05:09:14.000Z","updated":"2020-11-11T05:13:50.828Z","comments":true,"path":"2020/11/10/1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/1293-Shortest-Path-in-a-Grid-with-Obstacles-Elimination/","excerpt":"","text":"最短距离 用BFS 因为有K变量 所以再记录的时候要将K变量考虑进去123456789101112131415161718192021222324252627282930313233class Solution(object): def shortestPath(self, grid, k): \"\"\" :type grid: List[List[int]] :type k: int :rtype: int \"\"\" if len(grid) == 1 and len(grid[0]) == 1: return 0 # cur pos, how many obstacles we can remove, steps queue = deque([(0, 0, k, 0)]) visited = set([(0, 0, k)]) # k is big enough, the shortest path would be the manhaton distance from (0,0) to (N-1, N-1) if k &gt; (len(grid)-1 + len(grid[0])-1): return len(grid)-1 + len(grid[0])-1 while queue: row, col, eliminate, steps = queue.popleft() for new_row, new_col in [(row-1, col), (row+1, col), (row, col-1), (row, col+1l)]: if 0 &lt;= new_row &lt; len(grid) and 0 &lt;= new_col &lt; len(grid[0]): if grid[new_row][new_col] == 1 and eliminate &gt; 0 and (new_row, new_col, eliminate-1) not in visited: visited.add((new_row, new_col, eliminate-1)) queue.append((new_row, new_col, eliminate-1, steps+1)) if grid[new_row][new_col] == 0 and (new_row, new_col, eliminate) not in visited: if new_row == len(grid) - 1 and new_col == len(grid[0]) - 1: return steps + 1 visited.add((new_row, new_col, eliminate)) queue.append((new_row, new_col, eliminate, steps+1)) return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"564. Find the Closest Palindrome","slug":"564-Find-the-Closest-Palindrome","date":"2020-11-11T04:39:55.000Z","updated":"2020-11-11T04:42:09.631Z","comments":true,"path":"2020/11/10/564-Find-the-Closest-Palindrome/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/564-Find-the-Closest-Palindrome/","excerpt":"","text":"1234567891011121314151617181920212223242526class Solution(object): def nearestPalindromic(self, n): \"\"\" :type n: str :rtype: str \"\"\" K = len(n) # cornor case 19, 这种情况结果可能是101, 所以我们要handle 这种case， 但是又要是palindrome， 所以必要是99， 101 candidates = [str(10**k + d) for k in (K-1, K) for d in (-1, 1)] prefix = n[:(K+1)/2] P = int(prefix) for start in map(str, (P-1, P, P+1)): candidates.append(start + (start[:-1] if K%2 else start)[::-1]) def delta(x): return abs(int(n) - int(x)) ans = None for cand in candidates: if cand != n and not cand.startswith('00'): if (ans is None or delta(cand) &lt; delta(ans) or (delta(cand) == delta(ans) and int(cand) &lt; int(ans))): ans = cand return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1220. Count Vowels Permutation ","slug":"1220-Count-Vowels-Permutation","date":"2020-11-11T03:09:17.000Z","updated":"2020-11-11T03:11:03.387Z","comments":true,"path":"2020/11/10/1220-Count-Vowels-Permutation/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/1220-Count-Vowels-Permutation/","excerpt":"","text":"My solution keeps track of the number of each vowel at a level in this tree. To calculate say ‘A’, we calculate how many nodes in the previous level produce ‘A’. This is the number of ‘E’, ‘I’, and ‘U’ nodes. 1234567891011class Solution(object): def countVowelPermutation(self, n): \"\"\" :type n: int :rtype: int \"\"\" a = e = i = o = u = 1 for _ in range(n-1): a, e, i, o, u = e + u + i, a + i, o + e, i, o+i return (a + e + i + o + u)%(10**9 + 7)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"420. Strong Password Checker","slug":"420-Strong-Password-Checker","date":"2020-11-10T23:56:36.000Z","updated":"2020-11-11T00:12:22.078Z","comments":true,"path":"2020/11/10/420-Strong-Password-Checker/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/420-Strong-Password-Checker/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def strongPasswordChecker(self, s): \"\"\" :type s: str :rtype: int \"\"\" missing_type = 3 if any('a' &lt;= c &lt;= 'z' for c in s): missing_type -= 1 if any('A' &lt;= c &lt;= 'Z' for c in s): missing_type -= 1 if any(c.isdigit() for c in s): missing_type -= 1 change, one, two = 0, 0, 0 p = 2 while p &lt; len(s): if s[p] == s[p-1] == s[p-2]: length = 2 while p &lt; len(s) and s[p] == s[p-1]: length += 1 p += 1 change += length/3 if length%3 == 0: one += 1 if length%3 == 1: two += 1 else: p += 1 if len(s) &lt; 6: return max(6-len(s), missing_type) elif len(s) &lt;= 20: return max(missing_type, change) else: delete = len(s) - 20 change -= min(delete, one) change -= min(max(delete - one, 0), two*2)/2 change -= max(delete - one - two*2, 0)/3 return delete + max(change, missing_type)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"749. Contain Virus","slug":"749-Contain-Virus","date":"2020-11-10T22:09:24.000Z","updated":"2020-11-10T22:10:27.761Z","comments":true,"path":"2020/11/10/749-Contain-Virus/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/749-Contain-Virus/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution(object): def containVirus(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" R, C = len(grid), len(grid[0]) def neighbors(r,c): for nr, nc in ((r-1,c), (r+1, c), (r, c-1), (r, c+1)): if 0 &lt;= nr &lt; R and 0 &lt;= nc &lt; C: yield nr, nc def dfs(r,c): if (r, c) not in seen: seen.add((r, c)) regions[-1].add((r,c)) for nr, nc in neighbors(r, c): if grid[nr][nc] == 1: dfs(nr, nc) elif grid[nr][nc] == 0: frontiers[-1].add((nr, nc)) perimeters[-1] += 1 ans = 0 while True: seen = set() regions = [] #list of set, each set is a group of connected virus region frontiers = [] #list of set, fronters[i] represent all the 0 the virus in regions[i] can reach to perimeters = [] # list of int, perimeters[i] represent how many times the virus in regions[i] can affect the 0, in other words, it is ther perimeter of the frontiers[i] for r, row in enumerate(grid): for c, val in enumerate(row): if val == 1 and (r, c) not in seen: regions.append(set()) frontiers.append(set()) perimeters.append(0) dfs(r,c) if not regions: break # we solve all the problems break and return triage_index = frontiers.index(max(frontiers, key = len)) # Because we want to save the day, each time we built the wall on the region can infrected the most cell, which means len(frontiers[i]) is the max, we built the wall on that position ans += perimeters[triage_index] for i, reg in enumerate(regions): if i == triage_index: for r, c in reg: grid[r][c] = -1 # we have built the wall, update the status in the grid else: for r, c in reg: for nr, nc in neighbors(r, c): if grid[nr][nc] == 0: grid[nr][nc] = 1 # because we did not built the wall, they are infecting other places return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"87. Scramble String","slug":"87-Scramble-String","date":"2020-11-10T19:54:11.000Z","updated":"2020-11-10T19:54:49.278Z","comments":true,"path":"2020/11/10/87-Scramble-String/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/87-Scramble-String/","excerpt":"","text":"12345678910111213141516171819class Solution(object): def isScramble(self, s1, s2): \"\"\" :type s1: str :type s2: str :rtype: bool \"\"\" n, m = len(s1), len(s2) if n != m or sorted(s1) != sorted(s2): return False if s1 == s2: return True for i in range(1, n): if (self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:i], s2[:i])) or (self.isScramble(s1[i:], s2[:-i]) and self.isScramble(s1[:i], s2[-i:])): return True return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1383. Maximum Performance of a Team","slug":"1383-Maximum-Performance-of-a-Team","date":"2020-11-10T19:14:28.000Z","updated":"2020-11-10T19:24:33.768Z","comments":true,"path":"2020/11/10/1383-Maximum-Performance-of-a-Team/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/1383-Maximum-Performance-of-a-Team/","excerpt":"","text":"Greddy 1234567891011121314151617181920class Solution(object): def maxPerformance(self, n, speed, efficiency, k): \"\"\" :type n: int :type speed: List[int] :type efficiency: List[int] :type k: int :rtype: int \"\"\" h = [] res = speed_sum = 0 for e, s in sorted(zip(efficiency, speed), reverse=1): heapq.heappush(h, s) speed_sum += s if len(h) &gt; k: speed_sum -= heapq.heappop(h) # even if the current speed is the smallest one, after we pop it, the speed_sum will be the previous_sum, previous efficiency is bigger than current e, thus the res will not change res = max(res, speed_sum*e) return res%(10**9+7)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"843. Guess the Word ","slug":"843-Guess-the-Word","date":"2020-11-10T17:50:26.000Z","updated":"2020-11-10T18:20:15.246Z","comments":true,"path":"2020/11/10/843-Guess-the-Word/","link":"","permalink":"https://jojoyang666.github.io/2020/11/10/843-Guess-the-Word/","excerpt":"","text":"solve(self, possible, path = ()): path: the guess we have made so far return the better guess we made everytime we update the possible list, in the matches list to narrow the range 12345678910111213141516171819202122232425262728293031323334353637383940414243# \"\"\"# This is Master's API interface.# You should not implement it, or speculate about its implementation# \"\"\"#class Master(object):# def guess(self, word):# \"\"\"# :type word: str# :rtype int# \"\"\"class Solution(object): def findSecretWord(self, wordlist, master): \"\"\" :type wordlist: List[Str] :type master: Master :rtype: None \"\"\" N = len(wordlist) self.H = [[sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j])) for j in xrange(N)] for i in xrange(N)] possible, path = range(N), () while possible: guess = self.solve(possible, path) matches = master.guess(wordlist[guess]) if matches == 6: return possible = [j for j in possible if self.H[guess][j] == matches] path = path + (guess,) def solve(self, possible, path=()): if len(possible) &lt;= 2: return possible[0] ansgrp, ansguess = possible, None for guess, row in enumerate(self.H): if guess not in path: groups = [[] for _ in range(7)] for j in possible: if j != guess: groups[row[j]].append(j) # idx represent how many matches with current guess, item is how many words are mateches with guess based on current match numbers maxgroups = max(groups, key=len) if len(maxgroups) &lt; len(ansgrp): # making guess in the minimizes the maximum possible size of the resulting lists ansgrp, ansguess = maxgroups, guess return ansguess","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1531. String Compression II","slug":"1531-String-Compression-II","date":"2020-11-10T06:39:24.000Z","updated":"2020-11-10T07:03:54.810Z","comments":true,"path":"2020/11/09/1531-String-Compression-II/","link":"","permalink":"https://jojoyang666.github.io/2020/11/09/1531-String-Compression-II/","excerpt":"","text":"决策最优解可以考虑用DP解决 123456789101112131415161718192021222324252627282930313233class Solution(object): def getLengthOfOptimalCompression(self, s, k): \"\"\" :type s: str :type k: int :rtype: int \"\"\" memo = &#123;&#125; # minimum length of runth when at start idx at s, # previous represent the previous char # last_count: # of consective precvious char # left: how many char we we delete # each we have two choice; keep the char or delete the char def counter(start, last, last_count, left): if (start, last, last_count, left) in memo: return memo[(start, last, last_count, left)] if left &lt; 0: return float('inf') if start &gt;= len(s): return 0 res = None if s[start] == last: # if last_count = 1 or 9 or 99, means we need add one more char for counting, add 1, 9 -&gt; 10, 99 -&gt;100 increase = 1 if last_count == 1 or last_count == 9 or last_count == 99 else 0 res = increase + counter(start+1, last, last_count+1, left) else: keep_start = 1 + counter(start+1, s[start], 1, left) delete = counter(start+1, last, last_count, left-1) res = min(keep_start, delete) memo[(start, last, last_count, left)] = res return res return counter(0, \"\", 0, k)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1163. Last Substring in Lexicographical Order","slug":"1163-Last-Substring-in-Lexicographical-Order","date":"2020-11-10T05:43:47.000Z","updated":"2020-11-10T06:02:26.230Z","comments":true,"path":"2020/11/09/1163-Last-Substring-in-Lexicographical-Order/","link":"","permalink":"https://jojoyang666.github.io/2020/11/09/1163-Last-Substring-in-Lexicographical-Order/","excerpt":"","text":"The mean idea here is to eliminate those candidates we are certain not the solution, at last, the only one left is our solution i, j,j &gt; i –&gt; final we return s[i:] s[i+k] == s[j+k], k++ s[i+k] &lt; s[j+k], 0 &lt;= p &lt;= k, which means idx between i, and i + k, will not be the answer, thus update i = max(j, i+k+1), j = i + 1 s[i+k] &gt; s[j+k], 0 &lt;= p &lt;= k, which means idx between j and j+k, will not be the answer, thus update j = j+k+1 if s[i+k] == s[j+k] s[i:] is the largest 123456789101112131415161718class Solution(object): def lastSubstring(self, s): \"\"\" :type s: str :rtype: str \"\"\" i, j, k = 0, 1, 0 while j + k &lt; len(s): if s[i+k] == s[j+k]: k += 1 continue elif s[i+k] &lt; s[j+k]: i = max(i+k+1, j) j = i+1 else: j = j + k + 1 k = 0 return s[i:]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1335. Minimum Difficulty of a Job Schedule","slug":"1335-Minimum-Difficulty-of-a-Job-Schedule","date":"2020-11-10T03:59:36.000Z","updated":"2020-11-10T04:38:25.484Z","comments":true,"path":"2020/11/09/1335-Minimum-Difficulty-of-a-Job-Schedule/","link":"","permalink":"https://jojoyang666.github.io/2020/11/09/1335-Minimum-Difficulty-of-a-Job-Schedule/","excerpt":"","text":"dp[i][j]: start work with ith job with d days left TOP Down12345678910111213141516class Solution(object): def minDifficulty(self, jobDifficulty, d): \"\"\" :type jobDifficulty: List[int] :type d: int :rtype: int \"\"\" n = len(jobDifficulty) dp = [[float('inf')]*n + [0] for _ in range(d+1)] for day in range(1, d + 1): for i in range(n - day + 1): maxd = 0 for j in range(i, n - day + 1): maxd = max(maxd, jobDifficulty[j]) dp[day][i] = min(dp[day][i], maxd + dp[day-1][j+1]) return dp[d][0] if dp[d][0] &lt; float('inf') else -1 Bottom Up1234567891011121314151617class Solution(object): def minDifficulty(self, jobDifficulty, d): \"\"\" :type jobDifficulty: List[int] :type d: int :rtype: int \"\"\" n = len(jobDifficulty) dp = [[float('inf')] * n + [0] for i in xrange(d+1)] for d in xrange(1, d+1): for i in xrange(n - d + 1): maxd = 0 for j in xrange(i, n-d + 1): maxd = max(maxd, jobDifficulty[j]) dp[d][j] = max(dp[d][i], maxd + dp[d-1][j+1]) return dp[d][0] if dp[d][0] &lt; float('inf') else -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"149. Max Points on a Line","slug":"149-Max-Points-on-a-Line","date":"2020-11-09T20:39:40.000Z","updated":"2020-11-09T20:45:38.371Z","comments":true,"path":"2020/11/09/149-Max-Points-on-a-Line/","link":"","permalink":"https://jojoyang666.github.io/2020/11/09/149-Max-Points-on-a-Line/","excerpt":"","text":"dic: key: key: slope, all the other points passing same point x value: the number of the points with same slopefind the max value cornor case same points vertical line123456789101112131415161718192021222324252627282930313233343536class Solution(object): def maxPoints(self, points): \"\"\" :type points: List[List[int]] :rtype: int \"\"\" def gcd(a, b): if b == 0: return a return gcd(b, a%b) def frac(x, y): g = gcd(x, y) return x//g, y//g l, m = len(points), 0 for i in range(l): dic, same = &#123;'i': 1&#125;, 0 for j in range(i+1, l): tx, ty = points[j][0], points[j][1] dx = points[i][0] - tx dy = points[i][1] - ty if dx == 0 and dy == 0: same += 1 continue if dx == 0: slope = 'i' else: slope = frac(dx, dy) dic[slope] = dic.get(slope, 1) + 1 # default is 1, not 0, becaus we need to include (i, j) m = max(m, max(dic.values()) + same) return m","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"741. Cherry Pickup","slug":"741-Cherry-Pickup","date":"2020-11-09T18:57:08.000Z","updated":"2020-11-09T19:28:57.961Z","comments":true,"path":"2020/11/09/741-Cherry-Pickup/","link":"","permalink":"https://jojoyang666.github.io/2020/11/09/741-Cherry-Pickup/","excerpt":"","text":"Person moves from [0, 0] to [N-1, N-1], then moves back from [N-1, N-1] to [0,0] Then we can convert the problem to 2 person moves from [0,0] to [N-1, N-1] at the same time Notice, after t steps, each position, we will have this property: r + c = t Thus, p1 -&gt; (r1, c1). p2 -&gt; (r2, c2) r1 + c1 = r2 + c2 r2 = r1 + c1 - c2 (using this we can convert n^4 to n^3) Then when move, it has 4 possible situations p1 down, p2 down: dp[r1+1][c1][c2] p1 right, p2 down: dp[r1][c1+1][c2] p1 down, p2 right: dp[r1+1][c1][c2+1] p1 right, p2 right: dp[r1][c1+1][c2+1]12345678910111213141516171819202122232425class Solution(object): def cherryPickup(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" N = len(grid) memo = [[ [None] * N for _1 in xrange(N)] for _2 in xrange(N)] def dp(r1, c1, c2): r2 = r1 + c1 - c2 if N == r1 or N == r2 or N == c1 or N == c2 or grid[r1][c1] == -1 or grid[r2][c2] == -1: return float('-inf') elif r1 == c1 == N-1: return grid[r1][c1] elif memo[r1][c1][c2] is not None: return memo[r1][c1][c2] else: # p1, p2 can not arrive at the same position at the same time with cheery on it ans = grid[r1][c1] + (c1 != c2) * grid[r2][c2] ans += max(dp(r1, c1+1, c2 + 1), dp(r1+1, c1, c2+1), dp(r1, c1+1, c2), dp(r1+1, c1, c2)) memo[r1][c1][c2] = ans return ans return max(0, dp(0, 0, 0))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"920. Number of Music Playlists ","slug":"920-Number-of-Music-Playlists","date":"2020-11-09T17:58:44.000Z","updated":"2020-11-09T18:04:22.432Z","comments":true,"path":"2020/11/09/920-Number-of-Music-Playlists/","link":"","permalink":"https://jojoyang666.github.io/2020/11/09/920-Number-of-Music-Playlists/","excerpt":"","text":"dp[i][j]: the number of playlists with length i that have exactly j unique songs dp[i][j] = dp[i-1][j-1]*(N-j+1)表示我们添加一个新的歌曲在里面dp[i-1][j-1]中没有用过 dp[i-1][j]*max(j-K, 0):表示添加一个已经用过的歌曲12345678910111213141516class Solution(object): def numMusicPlaylists(self, N, L, K): \"\"\" :type N: int :type L: int :type K: int :rtype: int \"\"\" dp = [[0] * (N+1) for _ in range(L+1)] dp[0][0] = 1 for i in range(1, L+1): for j in range(1, min(i, N)+1): dp[i][j] = dp[i-1][j-1] * (N - (j-1)) + dp[i-1][j] * max(j-K, 0) return dp[L][N]%(10**9+7)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"465. Optimal Account Balancing","slug":"465-Optimal-Account-Balancing","date":"2020-11-09T04:58:27.000Z","updated":"2020-11-09T05:42:19.652Z","comments":true,"path":"2020/11/08/465-Optimal-Account-Balancing/","link":"","permalink":"https://jojoyang666.github.io/2020/11/08/465-Optimal-Account-Balancing/","excerpt":"","text":"an array of non-zero numbers, which sums to be zero. For example[4, -2, -2, 6, -6] converted into finding the minimal clique such that the elements sum up to be zero. Minimal means there is no subset which sums up to zero.[4, -2, -2] and [6, -6] we only need to resolve the balance inside the clique. There will be no inter-clique transactions. Final number of transactions will be 5 - 2, which is num_non_zero - num_clique. have to sort non-zero debts before settling. Otherwise, unnecessary transactions are performed. cannot get the perfect minimun clique 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def minTransfers(self, transactions): \"\"\" :type transactions: List[List[int]] :rtype: int \"\"\" balances = collections.defaultdict(int) for p1, p2, value in transactions: balances[p1] -= value balances[p2] += value non_zero = [balances[i] for i in balances if balances[i] != 0] balances_cnt = len(non_zero) non_zero = sorted(non_zero) while len(non_zero) &gt; 0: non_zero = self.remove_one_zero(non_zero) balances_cnt -= 1 return balances_cnt def remove_one_zero(self, non_zero): n = len(non_zero) q = collections.deque() q.append(([0], non_zero[0])) min_zero_set = None while q: cur_set, cur_sum = q.popleft() if cur_sum == 0: min_zero_set = cur_set break for j in range(cur_set[-1] + 1, n): q.append((cur_set + [j], cur_sum + non_zero[j])) min_zero_set = set(min_zero_set) return [non_zero[i] for i in range(n) if i not in min_zero_set] 12345678910111213141516171819202122232425262728293031class Solution(object): def minTransfers(self, transactions): \"\"\" :type transactions: List[List[int]] :rtype: int \"\"\" balances = collections.defaultdict(int) for p1, p2, value in transactions: balances[p1] -= value balances[p2] += value non_zero = [balances[i] for i in balances if balances[i] != 0] return self.dfs(0, non_zero)#using backtrack to find global minimum transactions to set the debit def dfs(self, k, balances): if k == len(balances): return 0 cur = balances[k] if cur == 0: return self.dfs(k+1, balances) res = float('inf') for i in range(k+1, len(balances)): nxt = balances[i] if cur * nxt &lt; 0: balances[i] += cur res = min(res, 1 + self.dfs(k+1, balances)) balances[i] = nxt if cur + nxt == 0: break return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"363. Max Sum of Rectangle No Larger Than K ","slug":"363-Max-Sum-of-Rectangle-No-Larger-Than-K","date":"2020-11-09T03:22:41.000Z","updated":"2020-11-09T03:23:02.428Z","comments":true,"path":"2020/11/08/363-Max-Sum-of-Rectangle-No-Larger-Than-K/","link":"","permalink":"https://jojoyang666.github.io/2020/11/08/363-Max-Sum-of-Rectangle-No-Larger-Than-K/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132class Solution(object): def maxSumSubmatrix(self, matrix, k): \"\"\" :type matrix: List[List[int]] :type k: int :rtype: int \"\"\" def maxSumSubarray(arr): # prefix_sums: a sorted list with prefix_sums # s_curr: sum of items met so far # sub_s_max: max sum of subarray so far sub_s_max, s_curr = float('-inf'), 0 prefix_sums = [float('inf')] for x in arr: bisect.insort(prefix_sums, s_curr) s_curr += x i = bisect.bisect_left(prefix_sums, s_curr - k) sub_s_max = max(sub_s_max, s_curr - prefix_sums[i]) return sub_s_max m, n = len(matrix), len(matrix[0]) for x in range(m): for y in range(n - 1): matrix[x][y+1] += matrix[x][y] res = float('-inf') for y1 in range(n): for y2 in range(y1, n): arr = [matrix[x][y2] - (matrix[x][y1-1] if y1 &gt; 0 else 0) for x in range(m)] res = max(res, maxSumSubarray(arr)) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"871. Minimum Number of Refueling Stops","slug":"871-Minimum-Number-of-Refueling-Stops","date":"2020-11-08T22:46:01.000Z","updated":"2020-11-08T23:38:07.632Z","comments":true,"path":"2020/11/08/871-Minimum-Number-of-Refueling-Stops/","link":"","permalink":"https://jojoyang666.github.io/2020/11/08/871-Minimum-Number-of-Refueling-Stops/","excerpt":"","text":"1234567891011121314151617class Solution(object): def minRefuelStops(self, target, startFuel, stations): \"\"\" :type target: int :type startFuel: int :type stations: List[List[int]] :rtype: int \"\"\" dp = [startFuel] + [0]*len(stations) for i, (location, capacity) in enumerate(stations): for t in xrange(i, -1, -1):#一定要从后向前遍历, 从前向后遍历会多次叠加capacity if dp[t] &gt;= location: dp[t+1] = max(dp[t+1], dp[t]+capacity) for i, d in enumerate(dp): if d &gt;= target: return i return -1 123456789101112131415161718192021class Solution(object): def minRefuelStops(self, target, startFuel, stations): \"\"\" :type target: int :type startFuel: int :type stations: List[List[int]] :rtype: int \"\"\" pq = [] res = i = 0 cur = startFuel while cur &lt; target: while i &lt; len(stations) and stations[i][0] &lt;= cur: heapq.heappush(pq, -stations[i][1]) i += 1 if not pq: return -1 cur += -heapq.heappop(pq) res += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Interval","slug":"Interval","date":"2020-11-07T06:29:12.000Z","updated":"2020-11-07T06:36:37.807Z","comments":true,"path":"2020/11/06/Interval/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/Interval/","excerpt":"","text":"sort based on start/end time when update pointer, max()/min() 759. Employee Free Time","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"759. Employee Free Time","slug":"759-Employee-Free-Time","date":"2020-11-07T06:23:27.000Z","updated":"2020-11-07T06:28:55.959Z","comments":true,"path":"2020/11/06/759-Employee-Free-Time/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/759-Employee-Free-Time/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031\"\"\"# Definition for an Interval.class Interval(object): def __init__(self, start=None, end=None): self.start = start self.end = end\"\"\"class Solution(object): def employeeFreeTime(self, schedule): \"\"\" :type schedule: [[Interval]] :rtype: [Interval] \"\"\" OPEN, CLOSE = 0, 1 events = [] for intervals in schedule: for intetvsl in intervals: events.append((intetvsl.start, OPEN)) events.append((intetvsl.end, CLOSE)) events.sort() prev, occupied, res = None, 0, [] for t, cmd in events: if prev is not None and occupied == 0: res.append(Interval(prev, t)) occupied += 1 if cmd == OPEN else -1 prev = t return res 1234567891011121314151617181920212223242526272829303132\"\"\"# Definition for an Interval.class Interval(object): def __init__(self, start=None, end=None): self.start = start self.end = end\"\"\"class Solution(object): def employeeFreeTime(self, schedule): \"\"\" :type schedule: [[Interval]] :rtype: [Interval] \"\"\" heap = [] for employee in schedule: for interval in employee: heap.append((interval.start, interval.end)) heapify(heap) res = [] s, e = heapq.heappop(heap) while heap: start, end = heapq.heappop(heap) if e &lt; start: res.append(Interval(e, start)) e = end else: e = max(end, e) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"115. Distinct Subsequences ","slug":"115-Distinct-Subsequences","date":"2020-11-07T05:54:22.000Z","updated":"2020-11-07T06:00:46.263Z","comments":true,"path":"2020/11/06/115-Distinct-Subsequences/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/115-Distinct-Subsequences/","excerpt":"","text":"s: i, t: jdp[i][j]: the number of distinct subsenquences in s[0, i] &amp; t[0:j]at first, must initialize dp[i][j] = sp[i-1][j] then if s[i] == t[j], we can update dp[i][j] by adding dp[i-1][j-1] 123456789101112131415161718192021class Solution(object): def numDistinct(self, s, t): \"\"\" :type s: str :type t: str :rtype: int \"\"\" M, N = len(s), len(t) dp = [[0]*(N+1) for i in range(M+1)] for i in range(M+1): dp[i][0] = 1 for i in range(1, M+1): for j in range(1, N+1): dp[i][j] = dp[i-1][j] if s[i-1] == t[j-1]: dp[i][j] += dp[i-1][j-1] return dp[M][N]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"472. Concatenated Words","slug":"472-Concatenated-Words","date":"2020-11-07T05:19:33.000Z","updated":"2020-11-07T05:20:29.580Z","comments":true,"path":"2020/11/06/472-Concatenated-Words/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/472-Concatenated-Words/","excerpt":"","text":"split to prefix &amp; suffix to backtrack1234567891011121314151617181920212223242526272829class Solution(object): def findAllConcatenatedWordsInADict(self, words): \"\"\" :type words: List[str] :rtype: List[str] \"\"\" memo, res = &#123;&#125;, [] words = set(words) def dfs(word): if word in memo: return memo[word] for i in range(1, len(word)): prefix, suffix = word[:i], word[i:] if prefix in words and suffix in words: return True if prefix in words and dfs(suffix): memo[word] = True return memo[word] if suffix in words and dfs(prefix): memo[word] = True return memo[word] memo[word] = False return False for word in words: if dfs(word): res.append(word) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"679. 24 Game","slug":"679-24-Game","date":"2020-11-07T04:52:37.000Z","updated":"2020-11-07T04:53:23.059Z","comments":true,"path":"2020/11/06/679-24-Game/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/679-24-Game/","excerpt":"","text":"12345678910111213141516171819202122232425from operator import truediv, mul, add, subclass Solution(object): def judgePoint24(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" if not nums: return False if len(nums) == 1:return abs(nums[0] - 24) &lt; 1e-09 for i in xrange(len(nums)): for j in xrange(len(nums)): if i != j: B = [nums[k] for k in xrange(len(nums)) if i != k != j] for op in (truediv, mul, add, sub): if (op is add or op is mul) and j &lt; i: continue # + &amp; * is not relate with sequence if op is not truediv or nums[j]: B.append(op(nums[i], nums[j])) if self.judgePoint24(B): return True B.pop() return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"493. Reverse Pairs ","slug":"493-Reverse-Pairs","date":"2020-11-07T02:13:10.000Z","updated":"2020-11-07T02:39:14.835Z","comments":true,"path":"2020/11/06/493-Reverse-Pairs/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/493-Reverse-Pairs/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536class Solution(object): def reversePairs(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" self.res = 0 def sort(enums): half = len(enums)/2 if half: left, right = sort(enums[:half]), sort(enums[half:]) i, j = 0, 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= 2 * right[j]: i += 1 else: self.res += len(left) - i j += 1 i, j = 0, 0 # 在merge前先计算count 因为左边和右边都是有序的 while i &lt; len(left) or j &lt; len(right): if j == len(right) or i &lt; len(left) and left[i] &lt; right[j]: enums[i+j] = left[i] i += 1 else: enums[i+j] = right[j] j += 1 return enums sort(nums) return self.res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"132. Palindrome Partitioning II ","slug":"132-Palindrome-Partitioning-II","date":"2020-11-06T22:48:16.000Z","updated":"2020-11-06T22:52:25.945Z","comments":true,"path":"2020/11/06/132-Palindrome-Partitioning-II/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/132-Palindrome-Partitioning-II/","excerpt":"","text":"初始化： cut[0] = -1, if a string is palindropme, we need cut[0] to be -1, then if the string is palindrome, there is no need to be cutcut[i]: the minuimum cut made for palindrome with length i 1234567891011121314151617181920class Solution(object): def minCut(self, s): \"\"\" :type s: str :rtype: int \"\"\" n = len(s) cut = [i-1 for i in range(n+1)] for i in range(n): j = 0 while i - j &gt;= 0 and i + j &lt; n and s[i-j] == s[i+j]: #odd palindrome cut[i+j+1] = min(cut[i+j+1], cut[i-j] + 1) j += 1 j = 1 while i - j + 1 &gt;= 0 and i + j &lt; n and s[i-j+1] == s[i+j]: # even palidrome cut[i+j+1] = min(cut[i-j+1] + 1, cut[i+j+1]) j += 1 return cut[n]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"214. Shortest Palindrome","slug":"214-Shortest-Palindrome","date":"2020-11-06T21:38:21.000Z","updated":"2020-11-06T21:44:02.692Z","comments":true,"path":"2020/11/06/214-Shortest-Palindrome/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/214-Shortest-Palindrome/","excerpt":"","text":"longest Palindrome for s: s + reversed(s) –&gt; a if we can find longest prefix == lonest suffice in a –&gt; we get the longest subtring which is palindrome in s –&gt; b what we need is find substring c which is exlucde b from s, then reverse c and at the beginning of the s. this will be the final res 1234567891011121314151617181920212223242526class Solution(object): def shortestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" a = s + '*' + s[::-1] lps = self.getLPS(a) print self.getLPS(s) return s[lps[-1]:][::-1] + s def getLPS(self, pattern): m = len(pattern) lps = [0] * m i, j = 0, 1 while j &lt; m: if pattern[i] == pattern[j]: lps[j] = i + 1 i, j = i + 1, j + 1 elif i &gt; 0: i = lps[i-1] # if i &gt; 0, which means str(0, i-1) and j - 1 is matching, thus we need to recusively k(k&lt;i), thus substring[0,k] == substring[j-k, j] else: lps[j] = 0 # if i == 0 &amp;&amp; world[i] != word[j], no matching j += 1 return lps","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"KMP","slug":"KMP","date":"2020-11-06T20:39:17.000Z","updated":"2020-11-06T20:41:52.304Z","comments":true,"path":"2020/11/06/KMP/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/KMP/","excerpt":"","text":"input: an array of characters, W (the word to be analyzed) output: an array of integers, T (the table to be filled) define variables: an integer, pos ← 1 (the current position we are computing in T) an integer, cnd ← 0 (the zero-based index in W of the next character of the current candidate substring) input: an array of characters, S (the text to be searched) an array of characters, W (the word sought)output: an array of integers, P (positions in S at which W is found) an integer, nP (number of positions) define variables: an integer, j ← 0 (the position of the current character in S) an integer, k ← 0 (the position of the current character in W) an array of integers, T (the table, computed elsewhere)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"315. Count of Smaller Numbers After Self ","slug":"315-Count-of-Smaller-Numbers-After-Self","date":"2020-11-06T18:35:52.000Z","updated":"2020-11-06T18:49:39.977Z","comments":true,"path":"2020/11/06/315-Count-of-Smaller-Numbers-After-Self/","link":"","permalink":"https://jojoyang666.github.io/2020/11/06/315-Count-of-Smaller-Numbers-After-Self/","excerpt":"","text":"123456789101112131415161718192021222324class Solution(object): def countSmaller(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" def sort(enum): half = len(enum)/2 if half: left, right = sort(enum[:half]), sort(enum[half:]) m, n = len(left), len(right) i = j = 0 while i &lt; m or j &lt; n: if j == n or (i &lt; m and left[i][1] &lt;= right[j][1]): smaller[left[i][0]] += j enum[i+j] = left[i] i+= 1 else: enum[i+j] = right[j] j += 1 return enum smaller = [0] * len(nums) sort(list(enumerate(nums))) return smaller","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1235. Maximum Profit in Job Scheduling","slug":"1235-Maximum-Profit-in-Job-Scheduling","date":"2020-11-06T06:36:29.000Z","updated":"2020-11-06T06:48:53.238Z","comments":true,"path":"2020/11/05/1235-Maximum-Profit-in-Job-Scheduling/","link":"","permalink":"https://jojoyang666.github.io/2020/11/05/1235-Maximum-Profit-in-Job-Scheduling/","excerpt":"","text":"Kind of knapack algorithm, along with binary search 12345678910111213141516class Solution(object): def jobScheduling(self, startTime, endTime, profit): \"\"\" :type startTime: List[int] :type endTime: List[int] :type profit: List[int] :rtype: int \"\"\" jobs = sorted(zip(startTime, endTime, profit), key = lambda k: k[1]) dp = [[0, 0]] for start, end, pro in jobs: i = bisect.bisect(dp, [start+1]) - 1 if dp[i][-1] + pro &gt; dp[-1][-1]: dp.append([end, dp[i][1] + pro]) return dp[-1][1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"329. Longest Increasing Path in a Matrix","slug":"329-Longest-Increasing-Path-in-a-Matrix","date":"2020-11-06T06:20:25.000Z","updated":"2020-11-06T06:35:46.143Z","comments":true,"path":"2020/11/05/329-Longest-Increasing-Path-in-a-Matrix/","link":"","permalink":"https://jojoyang666.github.io/2020/11/05/329-Longest-Increasing-Path-in-a-Matrix/","excerpt":"","text":"12345678910111213141516171819class Solution(object): def longestIncreasingPath(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: int \"\"\" def dfs(i, j): if not dp[i][j]: val = matrix[i][j] dp[i][j] = 1 + max(dfs(i-1, j) if i and val &gt; matrix[i-1][j] else 0, dfs(i+1, j) if i &lt; M-1 and val &gt; matrix[i+1][j] else 0, dfs(i, j+1) if j &lt; N-1 and val &gt; matrix[i][j+1] else 0, dfs(i, j-1) if j and val &gt; matrix[i][j-1] else 0) return dp[i][j] if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) dp = [[0] * N for i in range(M)] return max(dfs(x, y) for x in range(M) for y in range(N))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"37. Sudoku Solver","slug":"37-Sudoku-Solver","date":"2020-11-06T05:26:57.000Z","updated":"2020-11-06T06:35:41.695Z","comments":true,"path":"2020/11/05/37-Sudoku-Solver/","link":"","permalink":"https://jojoyang666.github.io/2020/11/05/37-Sudoku-Solver/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution(object): def solveSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. \"\"\" n, N = 3, 9 box_index = lambda row, col: (row//n)*n + col//n rows = [defaultdict(int) for i in range(N)] cols = [defaultdict(int) for i in range(N)] boxes = [defaultdict(int) for i in range(N)] self.sudoku_solved = False def could_place(d, row, col): return not (d in rows[row] or d in cols[col] or d in boxes[box_index(row, col)]) def place_number(d, row, col): rows[row][d] += 1 cols[col][d] += 1 boxes[box_index(row, col)][d] += 1 board[row][col] = str(d) def remove_number(d, row, col): del rows[row][d] del cols[col][d] del boxes[box_index(row, col)][d] board[row][col] = '.' def place_next_numbers(row, col): if col == N - 1 and row == N -1: self.sudoku_solved = True else: if col == N - 1: backtrack(row + 1, 0) else: backtrack(row, col + 1) def backtrack(row = 0, col = 0): if board[row][col] == '.': for d in range(1, 10): if could_place(d, row, col): place_number(d, row, col) place_next_numbers(row, col) if not self.sudoku_solved: remove_number(d, row, col) else: place_next_numbers(row, col) for i in range(N): for j in range(N): if board[i][j] != '.': d = int(board[i][j]) place_number(d, i, j) backtrack()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"72. Edit Distance","slug":"72-Edit-Distance","date":"2020-11-06T04:10:57.000Z","updated":"2020-11-06T06:35:25.943Z","comments":true,"path":"2020/11/05/72-Edit-Distance/","link":"","permalink":"https://jojoyang666.github.io/2020/11/05/72-Edit-Distance/","excerpt":"","text":"12345678910111213141516171819202122232425class Solution(object): def minDistance(self, word1, word2): \"\"\" :type word1: str :type word2: str :rtype: int \"\"\" n, m = len(word1), len(word2) if n * m == 0: return max(n, m) dp = [[0]*(m+1) for _ in range(n+1)] for i in range(n+1): dp[i][0] = i for j in range(m+1): dp[0][j] = j for i in range(1, n+1): for j in range(1, m+1): if word1[i-1] == word2[j-1]: dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1] - 1) else: dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"460. LFU Cache","slug":"460-LFU-Cache","date":"2020-11-06T02:37:28.000Z","updated":"2020-11-06T06:35:08.733Z","comments":true,"path":"2020/11/05/460-LFU-Cache/","link":"","permalink":"https://jojoyang666.github.io/2020/11/05/460-LFU-Cache/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Node: def __init__(self, key, val): self.key = key self.val = val self.freq = 1 self.rev = self.next = Noneclass DlinkedList: def __init__(self): self._sentinel = Node(None, None) self._sentinel.next = self._sentinel.prev = self._sentinel self._size = 0 def __len__(self): return self._size def append(self, node): node.next = self._sentinel.next node.next.prev = node node.prev = self._sentinel self._sentinel.next = node self._size += 1 def pop(self, node=None): if self._size == 0: return if not node: node = self._sentinel.prev node.prev.next = node.next node.next.prev = node.prev self._size -= 1 return node class LFUCache(object): def __init__(self, capacity): \"\"\" :type capacity: int \"\"\" self._size = 0 self._capacity = capacity self._node = dict() self._freq = collections.defaultdict(DlinkedList) self._minfreq = 0 def _update(self, node): freq = node.freq self._freq[freq].pop(node) if self._minfreq == freq and not self._freq[freq]: self._minfreq += 1 node.freq += 1 freq = node.freq self._freq[freq].append(node) def get(self, key): \"\"\" :type key: int :rtype: int \"\"\" if key not in self._node: return -1 node = self._node[key] self._update(node) return node.val def put(self, key, value): \"\"\" :type key: int :type value: int :rtype: None \"\"\" if self._capacity == 0: return if key in self._node: node = self._node[key] self._update(node) node.val = value else: if self._size == self._capacity: node = self._freq[self._minfreq].pop() del self._node[node.key] self._size -= 1 node = Node(key, value) self._node[key] = node self._freq[1].append(node) self._minfreq = 1 self._size += 1 # Your LFUCache object will be instantiated and called as such:# obj = LFUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"588. Design In-Memory File System","slug":"588-Design-In-Memory-File-System","date":"2020-11-05T23:26:42.000Z","updated":"2020-11-06T06:34:59.202Z","comments":true,"path":"2020/11/05/588-Design-In-Memory-File-System/","link":"","permalink":"https://jojoyang666.github.io/2020/11/05/588-Design-In-Memory-File-System/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Node: def __init__(self): self.child = collections.defaultdict(Node) # children is type of Node self.content = \"\" class FileSystem(object): def __init__(self): self.root = Node() def find(self, path): curr = self.root if len(path) == 1: return self.root for word in path.split(\"/\")[1:]: curr = curr.child[word] return curr def ls(self, path): \"\"\" :type path: str :rtype: List[str] \"\"\" curr = self.find(path) if curr.content: return [path.split('/')[-1]] return sorted(curr.child.keys()) def mkdir(self, path): \"\"\" :type path: str :rtype: None \"\"\" self.find(path) def addContentToFile(self, filePath, content): \"\"\" :type filePath: str :type content: str :rtype: None \"\"\" curr = self.find(filePath) curr.content += content def readContentFromFile(self, filePath): \"\"\" :type filePath: str :rtype: str \"\"\" curr = self.find(filePath) return curr.content# Your FileSystem object will be instantiated and called as such:# obj = FileSystem()# param_1 = obj.ls(path)# obj.mkdir(path)# obj.addContentToFile(filePath,content)# param_4 = obj.readContentFromFile(filePath)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"68. Text Justification","slug":"68-Text-Justification","date":"2020-11-05T20:03:50.000Z","updated":"2020-11-06T06:34:35.151Z","comments":true,"path":"2020/11/05/68-Text-Justification/","link":"","permalink":"https://jojoyang666.github.io/2020/11/05/68-Text-Justification/","excerpt":"","text":"12345678910111213141516171819202122232425class Solution(object): def fullJustify(self, words, maxWidth): \"\"\" :type words: List[str] :type maxWidth: int :rtype: List[str] \"\"\" res, cur, num_of_letters = [], [], 0 for word in words: if len(word) + num_of_letters + len(cur) &gt; maxWidth: if len(cur) == 1: res.append(cur[0] + ' '*(maxWidth - num_of_letters)) else: num_spaces = maxWidth - num_of_letters space_between_words, num_extra_spaces = divmod(num_spaces, len(cur) - 1) # remeber to -1 for i in range(num_extra_spaces): cur[i] += ' ' res.append((' '*space_between_words).join(cur)) cur, num_of_letters = [], 0 cur.append(word) num_of_letters += len(word) res.append(' '.join(cur) + ' ' * (maxWidth - num_of_letters - len(cur) + 1)) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"829. Consecutive Numbers Sum","slug":"829-Consecutive-Numbers-Sum","date":"2020-11-05T07:34:54.000Z","updated":"2020-11-06T06:34:48.627Z","comments":true,"path":"2020/11/04/829-Consecutive-Numbers-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/11/04/829-Consecutive-Numbers-Sum/","excerpt":"","text":"1234567891011121314class Solution(object): def consecutiveNumbersSum(self, N): \"\"\" :type N: int :rtype: int \"\"\" count = 0 # x &gt; 0 --&gt; N/k - (k + 1)/2 &gt; 0 upper_limit = int((2 * ˜N + 0.25)**0.5 - 0.5 + 1) for k in range(1, upper_limit): # x should be integer if (N - k * (k + 1) // 2) % k == 0: count += 1 return count","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"780. Reaching Points","slug":"780-Reaching-Points","date":"2020-11-05T06:58:23.000Z","updated":"2020-11-05T06:59:21.476Z","comments":true,"path":"2020/11/04/780-Reaching-Points/","link":"","permalink":"https://jojoyang666.github.io/2020/11/04/780-Reaching-Points/","excerpt":"","text":"1234567891011121314151617class Solution(object): def reachingPoints(self, sx, sy, tx, ty): \"\"\" :type sx: int :type sy: int :type tx: int :type ty: int :rtype: bool \"\"\" if sx &gt; tx or sy &gt; ty: return False if sx == tx: return (ty-sy)%sx == 0 if sy == ty: return (tx-sx)%sy == 0 if tx &gt; ty: return self.reachingPoints(sx, sy, tx - ty, ty) elif tx &lt; ty: return self.reachingPoints(sx, sy, tx, ty-tx) else: return False 1234567891011121314151617class Solution(object): def reachingPoints(self, sx, sy, tx, ty): \"\"\" :type sx: int :type sy: int :type tx: int :type ty: int :rtype: bool \"\"\" if sx &gt; tx or sy &gt; ty: return False if sx == tx: return (ty-sy)%sx == 0 if sy == ty: return (tx-sx)%sy == 0 if tx &gt; ty: return self.reachingPoints(sx, sy, tx%ty, ty) elif tx &lt; ty: return self.reachingPoints(sx, sy, tx, ty%tx) else: return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"312. Burst Balloons ","slug":"312-Burst-Balloons","date":"2020-11-05T05:39:35.000Z","updated":"2020-11-05T05:40:03.783Z","comments":true,"path":"2020/11/04/312-Burst-Balloons/","link":"","permalink":"https://jojoyang666.github.io/2020/11/04/312-Burst-Balloons/","excerpt":"","text":"https://www.youtube.com/watch?v=uG_MtaCJIrM 12345678910111213141516class Solution(object): def maxCoins(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" N = len(nums) nums = [1] + nums + [1] dp = [[0] * (N+2) for i in range(N+2)] for width in range(1, N+1): for left in range(1, N-width+2): right = left + width - 1 # nums[i] last one to burst in window from left to right for i in range(left, right+1): dp[left][right] = max(dp[left][right], nums[left-1]*nums[i]*nums[right+1]+dp[left][i-1] + dp[i+1][right]) return dp[1][N]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"45. Jump Game II ","slug":"45-Jump-Game-II","date":"2020-11-05T04:46:35.000Z","updated":"2020-11-05T04:47:03.221Z","comments":true,"path":"2020/11/04/45-Jump-Game-II/","link":"","permalink":"https://jojoyang666.github.io/2020/11/04/45-Jump-Game-II/","excerpt":"","text":"Greedy 1234567891011121314151617181920class Solution(object): def jump(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt; 2: return 0 #cornor case # maximum position it can reach which is starting from pos idx, idx &lt; i max_pos = nums[0] # maximum position we can reach within current jumps max_step = nums[0] jump = 1 for i in range(1, len(nums)): if max_step &lt; i: jump += 1 max_step = max_pos max_pos = max(max_pos, nums[i] + i) return jump","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Tarjan algorithm","slug":"Tarjan-algorithm","date":"2020-11-05T04:12:04.000Z","updated":"2020-11-05T04:14:18.962Z","comments":true,"path":"2020/11/04/Tarjan-algorithm/","link":"","permalink":"https://jojoyang666.github.io/2020/11/04/Tarjan-algorithm/","excerpt":"","text":"1192. Critical Connections in a Network","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1192. Critical Connections in a Network ","slug":"1192-Critical-Connections-in-a-Network","date":"2020-11-05T04:08:45.000Z","updated":"2020-11-05T04:10:33.567Z","comments":true,"path":"2020/11/04/1192-Critical-Connections-in-a-Network/","link":"","permalink":"https://jojoyang666.github.io/2020/11/04/1192-Critical-Connections-in-a-Network/","excerpt":"","text":"1234567891011121314151617181920212223242526272829class Solution(object): def criticalConnections(self, n, connections): \"\"\" :type n: int :type connections: List[List[int]] :rtype: List[List[int]] \"\"\" graph = [[] for _ in range(n)] for first, second in connections: graph[first].append(second) graph[second].append(first) visited, rank, res = [False]*n, range(n), [] self.dfs(graph, 0, -1, 0, visited, rank, res) return res def dfs(self, graph, node, prev, currank, visited, rank, res): visited[node] = True rank[node] = currank for nxt in graph[node]: if nxt == prev: continue if not visited[nxt]: self.dfs(graph, nxt, node, currank+1, visited, rank, res) rank[node] = min(rank[node], rank[nxt]) if currank + 1 &lt;= rank[nxt]: res.append([node, nxt])","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"41. First Missing Positive","slug":"41-First-Missing-Positive","date":"2020-11-05T00:11:55.000Z","updated":"2020-11-05T00:12:15.410Z","comments":true,"path":"2020/11/04/41-First-Missing-Positive/","link":"","permalink":"https://jojoyang666.github.io/2020/11/04/41-First-Missing-Positive/","excerpt":"","text":"123456789101112131415161718192021222324252627282930class Solution(object): def firstMissingPositive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if 1 not in nums: return 1 n = len(nums) if n == 1: return 2 # cornor case [1] for i in range(n): if nums[i] &lt;= 0 or nums[i] &gt; n: #不能等于n因为n也可能是possible answer nums[i] = 1 for num in nums: num = abs(num) if num == n: nums[0] = -abs(nums[0]) else: nums[num] = -abs(nums[num]) for i in range(1, n): if nums[i] &gt; 0: return i if nums[0] &gt; 0:#这个必需放在之前的那个for循环后面， 因为可能有小于n的数a和n同时满足, 在这种情况下我们要选择a return n return n + 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"85. Maximal Rectangle","slug":"85-Maximal-Rectangle","date":"2020-11-04T23:16:02.000Z","updated":"2020-11-04T23:28:43.747Z","comments":true,"path":"2020/11/04/85-Maximal-Rectangle/","link":"","permalink":"https://jojoyang666.github.io/2020/11/04/85-Maximal-Rectangle/","excerpt":"","text":"123456789101112131415161718192021222324252627282930class Solution(object): def maximalRectangle(self, matrix): \"\"\" :type matrix: List[List[str]] :rtype: int \"\"\" if not matrix: return 0 maxarea = 0 dp = [0] * len(matrix[0]) for i in range(len(matrix)): for j in range(len(matrix[0])): dp[j] = dp[j] + 1 if matrix[i][j] == '1' else 0 maxarea = max(self.helper(dp), maxarea) return maxarea def helper(self, heights): heights = [0] + heights + [0] stack, res = [], 0 for i, height in enumerate(heights): while stack and heights[stack[-1]] &gt; height: prev = stack.pop() h = heights[prev] w = i - stack[-1] - 1 res = max(w * h, res) stack.append(i) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1348. Tweet Counts Per Frequency","slug":"1348-Tweet-Counts-Per-Frequency","date":"2020-11-04T04:31:05.000Z","updated":"2020-11-04T04:31:20.108Z","comments":true,"path":"2020/11/03/1348-Tweet-Counts-Per-Frequency/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1348-Tweet-Counts-Per-Frequency/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536class TweetCounts(object): def __init__(self): self.a = defaultdict(list) def recordTweet(self, tweetName, time): \"\"\" :type tweetName: str :type time: int :rtype: None \"\"\" bisect.insort(self.a[tweetName], time) def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime): \"\"\" :type freq: str :type tweetName: str :type startTime: int :type endTime: int :rtype: List[int] \"\"\" delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400 i = startTime res = [] while i &lt;= endTime: j = min(i + delta, endTime + 1) res.append(bisect_left(self.a[tweetName], j) - bisect_left(self.a[tweetName], i)) i += delta return res# Your TweetCounts object will be instantiated and called as such:# obj = TweetCounts()# obj.recordTweet(tweetName,time)# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"754. Reach a Number","slug":"754-Reach-a-Number","date":"2020-11-04T03:46:12.000Z","updated":"2020-11-04T03:55:26.372Z","comments":true,"path":"2020/11/03/754-Reach-a-Number/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/754-Reach-a-Number/","excerpt":"","text":"12345678910111213class Solution(object): def reachNumber(self, target): \"\"\" :type target: int :rtype: int \"\"\" target = abs(target) k = 0 while target &gt; 0: k += 1 target -= k return k if target % 2 == 0 else k + 1 + k%2","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1347. Minimum Number of Steps to Make Two Strings Anagram","slug":"1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram","date":"2020-11-04T02:27:29.000Z","updated":"2020-11-04T02:27:48.989Z","comments":true,"path":"2020/11/03/1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram/","excerpt":"","text":"123456789class Solution(object): def minSteps(self, s, t): \"\"\" :type s: str :type t: str :rtype: int \"\"\" cnt1, cnt2 = map(collections.Counter, (s, t)) return sum((cnt1 - cnt2).values())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"949. Largest Time for Given Digits","slug":"949-Largest-Time-for-Given-Digits","date":"2020-11-04T02:12:17.000Z","updated":"2020-11-04T02:16:32.995Z","comments":true,"path":"2020/11/03/949-Largest-Time-for-Given-Digits/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/949-Largest-Time-for-Given-Digits/","excerpt":"","text":"1234567891011121314151617181920212223class Solution(object): def largestTimeFromDigits(self, arr): \"\"\" :type arr: List[int] :rtype: str \"\"\" A = arr max_time = -1 for i1, D1 in enumerate(A): for i2, D2 in enumerate(A): for i3, D3 in enumerate(A): if i1 == i2 or i1 == i3 or i2 == i3: continue # the total sum of indices is 0 + 1 + 2 + 3 = 6. i4 = 6 - i1 - i2 - i3 D4 = A[i4] hour = D1 * 10 + D2 minute = D3 * 10 + D4 if hour &lt; 24 and minute &lt; 60: max_time = max(max_time, hour * 60 + minute) return \"\" if max_time == -1 else \"&#123;:02d&#125;:&#123;:02d&#125;\".format(max_time//60, max_time%60) 123456789101112131415class Solution: def largestTimeFromDigits(self, A: List[int]) -&gt; str: max_time = -1 # enumerate all possibilities, with the permutation() func for h, i, j, k in itertools.permutations(A): hour = h*10 + i minute = j*10 + k if hour &lt; 24 and minute &lt; 60: max_time = max(max_time, hour * 60 + minute) if max_time == -1: return \"\" else: return \"&#123;:02d&#125;:&#123;:02d&#125;\".format(max_time // 60, max_time % 60)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1162. As Far from Land as Possible","slug":"1162-As-Far-from-Land-as-Possible","date":"2020-11-04T01:49:30.000Z","updated":"2020-11-04T01:50:42.041Z","comments":true,"path":"2020/11/03/1162-As-Far-from-Land-as-Possible/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1162-As-Far-from-Land-as-Possible/","excerpt":"","text":"1234567891011121314151617181920212223242526class Solution(object): def maxDistance(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" m, n = len(grid), len(grid[0]) q = deque((i, j) for i in range(m) for j in range(n) if grid[i][j] == 1) if len(q) == m * n or len(q) == 0: return -1 level = 0 while q: size = len(q) for _ in range(size): i, j = q.popleft() for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]: xi, yj = x + i, y + j if 0 &lt;= xi &lt; m and 0 &lt;= yj &lt; n and grid[xi][yj] == 0: q.append((xi, yj)) grid[xi][yj] = 1 level += 1 return level - 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"451. Sort Characters By Frequency","slug":"451-Sort-Characters-By-Frequency","date":"2020-11-04T01:20:10.000Z","updated":"2020-11-04T01:37:15.039Z","comments":true,"path":"2020/11/03/451-Sort-Characters-By-Frequency/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/451-Sort-Characters-By-Frequency/","excerpt":"","text":"1234567class Solution(object): def frequencySort(self, s): \"\"\" :type s: str :rtype: str \"\"\" return ''.join([key * times for key, times in Counter(s).most_common()]) Bucket sort 12345678910111213141516171819202122class Solution(object): def frequencySort(self, s): \"\"\" :type s: str :rtype: str \"\"\" if not s: return s counts = collections.Counter(s) max_freq = max(counts.values()) buckets = [[] for _ in range(max_freq + 1)] for c, i in counts.items(): buckets[i].append(c) res = [] for i in range(len(buckets)-1, 0, -1): for c in buckets[i]: res.append(c * i) return ''.join(res)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"355. Design Twitter","slug":"355-Design-Twitter","date":"2020-11-04T01:13:52.000Z","updated":"2020-11-04T01:14:12.324Z","comments":true,"path":"2020/11/03/355-Design-Twitter/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/355-Design-Twitter/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Twitter(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.timer = itertools.count(step=-1) self.tweets = collections.defaultdict(deque) self.followees = collections.defaultdict(set) def postTweet(self, userId, tweetId): \"\"\" Compose a new tweet. :type userId: int :type tweetId: int :rtype: None \"\"\" self.tweets[userId].appendleft((next(self.timer), tweetId)) def getNewsFeed(self, userId): \"\"\" Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. :type userId: int :rtype: List[int] \"\"\" tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId]|&#123;userId&#125;)) return [t for _, t in itertools.islice(tweets, 10)] def follow(self, followerId, followeeId): \"\"\" Follower follows a followee. If the operation is invalid, it should be a no-op. :type followerId: int :type followeeId: int :rtype: None \"\"\" self.followees[followerId].add(followeeId) def unfollow(self, followerId, followeeId): \"\"\" Follower unfollows a followee. If the operation is invalid, it should be a no-op. :type followerId: int :type followeeId: int :rtype: None \"\"\" self.followees[followerId].discard(followeeId)# Your Twitter object will be instantiated and called as such:# obj = Twitter()# obj.postTweet(userId,tweetId)# param_2 = obj.getNewsFeed(userId)# obj.follow(followerId,followeeId)# obj.unfollow(followerId,followeeId)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1177. Can Make Palindrome from Substring","slug":"1177-Can-Make-Palindrome-from-Substring","date":"2020-11-04T00:14:27.000Z","updated":"2020-11-04T00:42:04.263Z","comments":true,"path":"2020/11/03/1177-Can-Make-Palindrome-from-Substring/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1177-Can-Make-Palindrome-from-Substring/","excerpt":"","text":"This will Time Limit Exceeded. Thus, we need some memo to aviod repeating counter operation 123456789101112131415class Solution(object): def canMakePaliQueries(self, s, queries): \"\"\" :type s: str :type queries: List[List[int]] :rtype: List[bool] \"\"\" res = [] for start, end, k in queries: substring = s[start:end+1] cnt = 0 for c, value in Counter(substring).items(): cnt += value%2 res.append((cnt/2) &lt;= k) return res 1234567891011121314151617181920class Solution(object): def canMakePaliQueries(self, s, queries): \"\"\" :type s: str :type queries: List[List[int]] :rtype: List[bool] \"\"\" dp = [[0] * 26] for i in range(1, len(s) + 1): new = dp[i-1][:] j = ord(s[i-1]) - ord('a') new[j] += 1 dp.append(new) ans = [] for l, r, k in queries: L, R = dp[l], dp[r+1] ans.append(sum((R[i] - L[i])&amp;1 for i in range(26))/2 &lt;= k) return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"444. Sequence Reconstruction","slug":"444-Sequence-Reconstruction","date":"2020-11-03T21:45:31.000Z","updated":"2020-11-03T23:45:17.566Z","comments":true,"path":"2020/11/03/444-Sequence-Reconstruction/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/444-Sequence-Reconstruction/","excerpt":"","text":"Topological Sort 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def sequenceReconstruction(self, org, seqs): \"\"\" :type org: List[int] :type seqs: List[List[int]] :rtype: bool \"\"\" graph = &#123;&#125; indegree = &#123;&#125; for seq in seqs: for i, c in enumerate(seq): if c not in graph: graph[c] = [] if i + 1&lt; len(seq): nxt = seq[i+1] graph[c].append(nxt) indegree[nxt] = indegree.get(nxt, 0) + 1 queue = collections.deque() for node in graph: if node not in indegree: queue.append(node) res = [] while queue: if len(queue) != 1: return False source = queue.popleft() res.append(source) for nei in graph[source]: indegree[nei] -= 1 if indegree[nei] == 0: queue.append(nei) return len(res) == len(graph) and res == org","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1169. Invalid Transactions ","slug":"1169-Invalid-Transactions","date":"2020-11-03T21:04:30.000Z","updated":"2020-11-03T21:04:47.871Z","comments":true,"path":"2020/11/03/1169-Invalid-Transactions/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1169-Invalid-Transactions/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839class Transaction: def __init__(self, name, time, amount, city): self.name = name self.time = int(time) self.amount = int(amount) self.city = cityclass Solution(object): def invalidTransactions(self, transactions): \"\"\" :type transactions: List[str] :rtype: List[str] \"\"\" transactions = [Transaction(*transaction.split(',')) for transaction in transactions] transactions.sort(key=lambda t: t.time) # O(nlogn) time trans_indexes = defaultdict(list) for i, t in enumerate(transactions): # O(n) time trans_indexes[t.name].append(i) res = [] for name, indexes in trans_indexes.items(): # O(n) time left = right = 0 for i, t_index in enumerate(indexes): t = transactions[t_index] if (t.amount &gt; 1000): res.append(\"&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\".format(t.name, t.time, t.amount, t.city)) continue while left &lt;= len(indexes)-2 and transactions[indexes[left]].time &lt; t.time - 60: left += 1 while right &lt;= len(indexes)-2 and transactions[indexes[right+1]].time &lt;= t.time + 60: # O(60) time right += 1 for i in range(left,right+1): if transactions[indexes[i]].city != t.city: res.append(\"&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\".format(t.name, t.time, t.amount, t.city)) break return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"532. K-diff Pairs in an Array ","slug":"532-K-diff-Pairs-in-an-Array","date":"2020-11-03T20:46:50.000Z","updated":"2020-11-03T20:47:34.124Z","comments":true,"path":"2020/11/03/532-K-diff-Pairs-in-an-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/532-K-diff-Pairs-in-an-Array/","excerpt":"","text":"12345678910111213141516class Solution(object): def findPairs(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" res = 0 counter = Counter(nums) for x in counter: if k &gt; 0 and x + k in counter: res += 1 elif k == 0 and counter[x] &gt; 1:#cornor case res += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1391. Check if There is a Valid Path in a Grid","slug":"1391-Check-if-There-is-a-Valid-Path-in-a-Grid","date":"2020-11-03T20:01:45.000Z","updated":"2020-11-03T20:02:42.770Z","comments":true,"path":"2020/11/03/1391-Check-if-There-is-a-Valid-Path-in-a-Grid/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1391-Check-if-There-is-a-Valid-Path-in-a-Grid/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031class Solution(object): def hasValidPath(self, grid): \"\"\" :type grid: List[List[int]] :rtype: bool \"\"\" if not grid: return True directions = &#123;1: [(0,-1),(0,1)], 2: [(-1,0),(1,0)], 3: [(0,-1),(1,0)], 4: [(0,1),(1,0)], 5: [(0,-1),(-1,0)], 6: [(0,1),(-1,0)]&#125; visited = set() goal = (len(grid)-1, len(grid[0]) - 1) def dfs(i, j): visited.add((i, j)) if (i, j) == goal: return True for d in directions[grid[i][j]]: ni, nj = i+d[0], j+d[1] if 0 &lt;= ni &lt; len(grid) and 0 &lt;= nj &lt; len(grid[0]) and (ni, nj) not in visited and (-d[0], -d[1]) in directions[grid[ni][nj]]: if dfs(ni, nj): return True return False return dfs(0, 0) Why (-d[0], -d[1]) in directions[grid[ni][nj]]:? When traversing from one cell to the next. the next cell must have a direction that is the opposite of the direction we are moving in for the cells to be connected. For example, if we are moving one unit to the right, then from the next cell it must be possible to go one unit to the left, otherwise it’s not actually connected.","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1049. Last Stone Weight II","slug":"1049-Last-Stone-Weight-II","date":"2020-11-03T19:44:28.000Z","updated":"2020-11-03T19:47:07.724Z","comments":true,"path":"2020/11/03/1049-Last-Stone-Weight-II/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1049-Last-Stone-Weight-II/","excerpt":"","text":"convert the problem to: divie the array into 2 groups, find the minimum differnence between the sum of two groups 123456789101112class Solution(object): def lastStoneWeightII(self, stones): \"\"\" :type stones: List[int] :rtype: int \"\"\" dp = set(&#123;0&#125;) sum_stones = sum(stones) for stone in stones: dp |= &#123;i + stone for i in dp&#125; return min(abs(sum_stones - i - i) for i in dp)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1375. Bulb Switcher III","slug":"1375-Bulb-Switcher-III","date":"2020-11-03T19:16:18.000Z","updated":"2020-11-03T19:17:15.337Z","comments":true,"path":"2020/11/03/1375-Bulb-Switcher-III/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1375-Bulb-Switcher-III/","excerpt":"","text":"right is the number of the right most lighted bulb. if right == i + 1,it means that all the previous bulbs (to the left) are turned on too. Then we increment res 12345678910111213class Solution(object): def numTimesAllBlue(self, light): \"\"\" :type light: List[int] :rtype: int \"\"\" right = res = 0 for i, l in enumerate(light): right = max(l, right) res += right == (i + 1) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"413. Arithmetic Slices","slug":"413-Arithmetic-Slices","date":"2020-11-03T18:35:56.000Z","updated":"2020-11-03T18:38:09.725Z","comments":true,"path":"2020/11/03/413-Arithmetic-Slices/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/413-Arithmetic-Slices/","excerpt":"","text":"12345678910111213class Solution(object): def numberOfArithmeticSlices(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" dp = [0] * len(A) s = 0 for i in range(2, len(A)): if A[i] - A[i-1] == A[i-1] - A[i-2]: dp[i] = dp[i-1]+1 s += dp[i] return s 123456789101112131415class Solution(object): def numberOfArithmeticSlices(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" dp = 0 s = 0 for i in range(2, len(A)): if A[i] - A[i-1] == A[i-1] - A[i-2]: dp = dp+1 s += dp else: dp = 0 return s","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1482. Minimum Number of Days to Make m Bouquets","slug":"1482-Minimum-Number-of-Days-to-Make-m-Bouquets","date":"2020-11-03T17:51:52.000Z","updated":"2020-11-03T17:52:18.296Z","comments":true,"path":"2020/11/03/1482-Minimum-Number-of-Days-to-Make-m-Bouquets/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/1482-Minimum-Number-of-Days-to-Make-m-Bouquets/","excerpt":"","text":"123456789101112131415161718192021222324252627282930class Solution(object): def minDays(self, bloomDay, m, k): \"\"\" :type bloomDay: List[int] :type m: int :type k: int :rtype: int \"\"\" if m * k &gt; len(bloomDay): return -1 left, right = 1, max(bloomDay) while left &lt; right: mid = (right - left)/2 + left boq = flow = 0 for b in bloomDay: flow = 1 + flow if b &lt;= mid else 0 #if there is flower not blooming at day mid, then update flower to 0 if flow == k: boq += 1 flow = 0 if boq == m: break if boq == m: right = mid else: left = mid + 1 return left","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"328. Odd Even Linked List ","slug":"328-Odd-Even-Linked-List","date":"2020-11-03T17:01:11.000Z","updated":"2020-11-03T17:01:53.274Z","comments":true,"path":"2020/11/03/328-Odd-Even-Linked-List/","link":"","permalink":"https://jojoyang666.github.io/2020/11/03/328-Odd-Even-Linked-List/","excerpt":"","text":"12345678910111213141516171819202122# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def oddEvenList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return head odd, even, evenhead = head, head.next, head.next while odd and even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenhead return head","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold ","slug":"1292-Maximum-Side-Length-of-a-Square-with-Sum-Less-than-or-Equal-to-Threshold","date":"2020-11-03T06:43:41.000Z","updated":"2020-11-03T06:54:37.388Z","comments":true,"path":"2020/11/02/1292-Maximum-Side-Length-of-a-Square-with-Sum-Less-than-or-Equal-to-Threshold/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/1292-Maximum-Side-Length-of-a-Square-with-Sum-Less-than-or-Equal-to-Threshold/","excerpt":"","text":"123456789101112131415161718192021222324class Solution(object): def maxSideLength(self, mat, threshold): \"\"\" :type mat: List[List[int]] :type threshold: int :rtype: int \"\"\" prefixSum = [[0] * (len(mat[0]) + 1) for _ in range(len(mat) + 1)] for i in range(1, len(mat) + 1): s = 0 for j in range(1, len(mat[0]) + 1): s += mat[i-1][j-1] prefixSum[i][j] = prefixSum[i-1][j] + s m, n = len(mat), len(mat[0]) for k in range(min(m, n)-1, 0, -1): for i in range(1, m-k+1): for j in range(1, n-k+1): if prefixSum[i+k][j+k] - prefixSum[i-1][j+k] - prefixSum[i+k][j-1] + prefixSum[i-1][j-1] &lt;= threshold: return k+1 return 0 1234567891011121314151617181920212223242526class Solution(object): def maxSideLength(self, mat, threshold): \"\"\" :type mat: List[List[int]] :type threshold: int :rtype: int \"\"\" if not mat: return 0 max_square = 0 dp = [[0] * (len(mat[0]) + 1) for _ in range(len(mat) + 1)] for i in range(1, len(mat) + 1): for j in range(1, len(mat[0]) + 1): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mat[i - 1][j - 1] l, r = 1, min(i, j) while l &lt;= r: k = (l + r)/2 cur_sum = dp[i][j] - dp[i - k][j] - dp[i][j - k] + dp[i - k][j - k] if cur_sum &lt;= threshold: max_square = max(max_square, k) l = k + 1 else: r = k - 1 return max_square 1234567891011121314151617181920212223242526272829303132class Solution(object): def maxSideLength(self, mat, threshold): \"\"\" :type mat: List[List[int]] :type threshold: int :rtype: int \"\"\" prefixSum = [[0] * (len(mat[0]) + 1) for _ in range(len(mat) + 1)] for i in range(1, len(mat) + 1): s = 0 for j in range(1, len(mat[0]) + 1): s += mat[i-1][j-1] prefixSum[i][j] = prefixSum[i-1][j] + s m, n = len(mat), len(mat[0]) max_square = 0 for i in range(1, m+1): for j in range(1, n+1): l, r = 1, min(i, j) while l &lt;= r: k = (l + r)/2 cur_sum = prefixSum[i][j] - prefixSum[i-k][j] - prefixSum[i][j-k] + prefixSum[i-k][j-k] if cur_sum &lt;= threshold: max_square = max(max_square, k) l = k + 1 else: r = k - 1 return max_square","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1376. Time Needed to Inform All Employees","slug":"1376-Time-Needed-to-Inform-All-Employees","date":"2020-11-03T05:59:59.000Z","updated":"2020-11-03T06:01:00.698Z","comments":true,"path":"2020/11/02/1376-Time-Needed-to-Inform-All-Employees/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/1376-Time-Needed-to-Inform-All-Employees/","excerpt":"","text":"12345678910111213141516171819202122class Solution(object): def numOfMinutes(self, n, headID, manager, informTime): \"\"\" :type n: int :type headID: int :type manager: List[int] :type informTime: List[int] :rtype: int \"\"\" q = collections.deque([(headID, 0)]) subordination = collections.defaultdict(list) for i, v in enumerate(manager): subordination[v].append(i) res = 0 while q: people, time = q.popleft() res = max(res, time) for p in subordination[people]: q.append((p, time + informTime[people])) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1481. Least Number of Unique Integers after K Removals","slug":"1481-Least-Number-of-Unique-Integers-after-K-Removals","date":"2020-11-03T05:13:07.000Z","updated":"2020-11-03T05:32:51.163Z","comments":true,"path":"2020/11/02/1481-Least-Number-of-Unique-Integers-after-K-Removals/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/1481-Least-Number-of-Unique-Integers-after-K-Removals/","excerpt":"","text":"123456789101112131415class Solution(object): def findLeastNumOfUniqueInts(self, arr, k): \"\"\" :type arr: List[int] :type k: int :rtype: int \"\"\" hp = [(count, value) for value, count in Counter(arr).items()] heapq.heapify(hp) while k &gt; 0: k -= heapq.heappop(hp)[0] return len(hp) + int(k &lt; 0) 1234567891011121314151617class Solution(object): def findLeastNumOfUniqueInts(self, arr, k): \"\"\" :type arr: List[int] :type k: int :rtype: int \"\"\" counter = Counter(arr) cnt, remaning = Counter(counter.values()), len(counter) for key in cnt: if k - key * cnt[key] &gt;= 0: k -= key * cnt[key] remaning -= cnt[key] else: return remaning - k/key return remaning","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"742. Closest Leaf in a Binary Tree","slug":"742-Closest-Leaf-in-a-Binary-Tree","date":"2020-11-03T05:04:59.000Z","updated":"2020-11-03T05:05:19.677Z","comments":true,"path":"2020/11/02/742-Closest-Leaf-in-a-Binary-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/742-Closest-Leaf-in-a-Binary-Tree/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def findClosestLeaf(self, root, k): \"\"\" :type root: TreeNode :type k: int :rtype: int \"\"\" graph = collections.defaultdict(list) def dfs(node, par=None): if node: graph[node].append(par) graph[par].append(node) dfs(node.left, node) dfs(node.right, node) dfs(root) queue = collections.deque([node for node in graph if node and node.val == k]) seen = set(queue) while queue: node = queue.popleft() if node: if len(graph[node]) == 1: return node.val for nei in graph[node]: if nei not in seen: seen.add(nei) queue.append(nei)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1429. First Unique Number ","slug":"1429-First-Unique-Number","date":"2020-11-03T04:41:54.000Z","updated":"2020-11-03T04:42:22.688Z","comments":true,"path":"2020/11/02/1429-First-Unique-Number/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/1429-First-Unique-Number/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637class FirstUnique(object): def __init__(self, nums): \"\"\" :type nums: List[int] \"\"\" self._queue = deque() self._is_unique = &#123;&#125; for num in nums: self.add(num) def showFirstUnique(self): \"\"\" :rtype: int \"\"\" while self._queue and not self._is_unique[self._queue[0]]: self._queue.popleft() return -1 if not self._queue else self._queue[0] def add(self, value): \"\"\" :type value: int :rtype: None \"\"\" if value not in self._is_unique: self._is_unique[value] = True self._queue.append(value) else: self._is_unique[value] = False# Your FirstUnique object will be instantiated and called as such:# obj = FirstUnique(nums)# param_1 = obj.showFirstUnique()# obj.add(value)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"323. Number of Connected Components in an Undirected Graph","slug":"323-Number-of-Connected-Components-in-an-Undirected-Graph","date":"2020-11-03T04:27:58.000Z","updated":"2020-11-03T04:28:26.982Z","comments":true,"path":"2020/11/02/323-Number-of-Connected-Components-in-an-Undirected-Graph/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/323-Number-of-Connected-Components-in-an-Undirected-Graph/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031class Solution(object): def countComponents(self, n, edges): \"\"\" :type n: int :type edges: List[List[int]] :rtype: int \"\"\" uf = UF(n) for start, end in edges: uf.union(start, end) res = 0 for i in range(n): if uf.find(i) == i: res += 1 return res class UF: def __init__(self, N): self.parent = range(N) def union(self, a, b): self.parent[self.find(a)] = self.find(b) def find(self, a): if self.parent[a] != a: self.parent[a] = self.find(self.parent[a]) return self.parent[a]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"310. Minimum Height Trees ","slug":"310-Minimum-Height-Trees","date":"2020-11-03T04:13:37.000Z","updated":"2020-11-03T04:14:26.523Z","comments":true,"path":"2020/11/02/310-Minimum-Height-Trees/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/310-Minimum-Height-Trees/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435class Solution(object): def findMinHeightTrees(self, n, edges): \"\"\" :type n: int :type edges: List[List[int]] :rtype: List[int] \"\"\" if n &lt;= 2: return [i for i in range(n)] neighbors = [set() for i in range(n)] for start, end in edges: neighbors[start].add(end) neighbors[end].add(start) leaves = [] for i in range(n): if len(neighbors[i]) == 1: leaves.append(i) remaining_nodes = n while remaining_nodes &gt; 2: remaining_nodes -= len(leaves) new_leaves = [] for leaf in leaves: for nei in neighbors[leaf]: neighbors[nei].remove(leaf) if len(neighbors[nei]) == 1: new_leaves.append(nei) leaves = new_leaves return leaves","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Designing Instagram","slug":"Designing-Instagram","date":"2020-11-02T22:20:49.000Z","updated":"2020-11-13T20:19:44.934Z","comments":true,"path":"2020/11/02/Designing-Instagram/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/Designing-Instagram/","excerpt":"","text":"Requirements and Goals of the System Functional Requirements Users should be able to upload/download/view photos. Users can perform searches based on photo/video titles. Users can follow other users. The system should generate and display a user’s News Feed consisting of top photos from all the people the user follows. Non-functional Requirements Our service needs to be highly available. The acceptable latency of the system is 200ms for News Feed generation. Consistency can take a hit (in the interest of availability) if a user doesn’t see a photo for a while; it should be fine. The system should be highly reliable; any uploaded photo or video should never be lost. Not in scope: Adding tags to photos, searching photos on tags, commenting on photos, tagging users to photos, who to follow, etc. Some Design ConsiderationsThe system would be read-heavy, so we will focus on building a system that can retrieve photos quickly. users can upload as many photos as they like; therefore, efficient management of storage should be a crucial factor in designing this system. Low latency is expected while viewing photos. Data should be 100% reliable. If a user uploads a photo, the system will guarantee that it will never be lost. Capacity Estimation and Constraints Assume we have 500M total users, with 1M daily active users. 2M new photos every day, 23 new photos every second. Average photo file size =&gt; 200KB Total space required for 1 day of photos2M * 200KB =&gt; 400 GB Total space required for 10 years400GB * 365 (days a year) * 10 (years) ~= 1425TB High Level System Design Support two scenarios Upload photos the other to view/search photos storage Need some object storage servers to store photos Some database servers to store metadata information about the photos. Database schema schema Storing the above schema would be to use an RDBMS like MySQL since we require joins. challenge: especially when we need to scale them. Can store photos in a distributed file storage like HDFS or S3. Store the above schema in a distributed key-value store to enjoy the benefits offered by NoSQL. Metadata related to photos All the metadata related to photos can go to a table where the ‘key’ would be the ‘PhotoID’ the ‘value’ would be an object containing PhotoLocation, UserLocation, CreationTimestamp, etc. Store relationships between users and photos/the list of people a user follows use a wide-column datastore like Cassandra For the ‘UserPhoto’ table the ‘key’ would be ‘UserID’ the ‘value’ would be the list of ‘PhotoIDs’ the user owns, stored in different columns. a similar scheme for the ‘UserFollow’ table. Cassandra or key-value stores, in general, always maintain a certain number of replicas to offer reliability. in such data stores, deletes don’t get applied instantly data is retained for certain days (to support undeleting) before getting removed from the system permanently. Data Size Estimation Estimate how much data will be going into each table how much total storage we will need for 10 years. User Assuming each “int” and “dateTime” is four bytes, each row in the User’s table will be of 68 bytesUserID (4 bytes) + Name (20 bytes) + Email (32 bytes) + DateOfBirth (4 bytes) + CreationDate (4 bytes) + LastLogin (4 bytes) = 68 bytes If we have 500 million users, we will need 32GB of total storage.500 million * 68 ~= 32GB Photo Each row in Photo’s table will be of 284 bytes:PhotoID (4 bytes) + UserID (4 bytes) + PhotoPath (256 bytes) + PhotoLatitude (4 bytes) + PhotoLongitude(4 bytes) + UserLatitude (4 bytes) + UserLongitude (4 bytes) + CreationDate (4 bytes) = 284 bytes If 2M new photos get uploaded every day, we will need 0.5GB of storage for one day2M * 284 bytes ~= 0.5GB per dayFor 10 years we will need 1.88TB of storage. UserFollow Each row in the UserFollow table will consist of 8 bytes If we have 500 million users and on average each user follows 500 users. We would need 1.82TB of storage for the UserFollow table:500 million users * 500 followers * 8 bytes ~= 1.82TB Total space required for all tables for 10 years will be 3.7TB:32GB + 1.88TB + 1.82TB ~= 3.7TB Component Design Uploading users can consume all the available connections, as uploading is a slow process. This means that ‘reads’ cannot be served if the system gets busy with all the ‘write’ requests. We should keep in mind that web servers have a connection limit before designing our system. To handle this bottleneck, we can split reads and writes into separate services. Dedicated servers for reads and different servers for writes to ensure that uploads don’t hog the system. Separating photos’ read and write requests will also allow us to scale and optimize each of these operations independently. Reliability and Redundancy Store multiple copies of each file so that if one storage server dies, we can retrieve the photo from the other copy present on a different storage server. High Reliability This same principle also applies to other components of the system. If we want to have high availability of the system, we need to have multiple replicas of services running in the system so that even if a few services die down, the system remains available and running. Redundancy removes the single point of failure in the system. If only one instance of a service is required to run at any point, we can run a redundant secondary copy of the service that is not serving any traffic, but it can take control after the failover when the primary has a problem Creating redundancy in a system can remove single points of failure and provide a backup or spare functionality if needed in a crisis Failover can happen automatically or require manual intervention. Data ShardingPartitioning based on UserID we can keep all photos of a user on the same shard. If one DB shard is 1TB, we will need four shards to store 3.7TB of data. Let’s assume for better performance and scalability we keep 10 shards. find the shard number by UserID % 10 and then store the data there To uniquely identify any photo in our system, we can append shard number with each PhotoID. How can we generate PhotoIDs? Each DB shard can have its own auto-increment sequence for PhotoIDs we will append ShardID with each PhotoID, it will make it unique throughout our system. What are the different issues with this partitioning scheme? How would we handle hot users? Several people follow such hot users and a lot of other people see any photo they upload. Some users will have a lot of photos compared to others, thus making a non-uniform distribution of storage. What if we cannot store all pictures of a user on one shard? If we distribute photos of a user onto multiple shards will it cause higher latencies? Storing all photos of a user on one shard can cause issues like unavailability of all of the user’s data if that shard is down or higher latency if it is serving high load etc. Partitioning based on Photo ID General If we can generate unique PhotoIDs first and then find a shard number through “PhotoID % 10” the above problems will have been solved. not need to append ShardID with PhotoID in this case as PhotoID will itself be unique throughout the system. How can we generate PhotoIDs Dedicate a separate database instance to generate auto-incrementing IDs. If our PhotoID can fit into 64 bits, we can define a table containing only a 64 bit ID field whenever we would like to add a photo in our system, we can insert a new row in this table and take that ID to be our PhotoID of the new photo. Wouldn’t this key generating DB be a single point of failure? Yes, it would be. Defining two such databases with one generating even numbered IDs and the other odd numbered. For the MySQL, the following script can define such sequences:1234567KeyGeneratingServer1:auto-increment-increment &#x3D; 2auto-increment-offset &#x3D; 1 KeyGeneratingServer2:auto-increment-increment &#x3D; 2auto-increment-offset &#x3D; 2 put a load balancer in front of both of these databases to round robin between them and to deal with downtime. Both these servers could be out of sync with one generating more keys than the other, but this will not cause any issue in our system. extend this design by defining separate ID tables for Users, Photo-Comments, or other objects present in our system. Alternately, we can implement a ‘key’ generation scheme similar to what we have discussed in Designing a URL Shortening service like TinyURL How can we plan for the future growth of our system? have a large number of logical partitions to accommodate future data growth Such that in the beginning, multiple logical partitions reside on a single physical database server Each database server can have multiple database instances on it, we can have separate databases for each logical partition on any server whenever we feel that a particular database server has a lot of data, we can migrate some logical partitions from it to another server. We can maintain a config file (or a separate database) that can map our logical partitions to database servers; this will enable us to move partitions around easily. Whenever we want to move a partition, we only have to update the config file to announce the change. Ranking and News Feed Generation we need to fetch the latest, most popular and relevant photos of the people the user follows. For simplicity, let’s assume we need to fetch top 100 photos for a user’s News Feed. Our application server will first get a list of people the user follows Then fetch metadata info of latest 100 photos from each user. The server will submit all these photos to our ranking algorithm which will determine the top 100 photos (based on recency, likeness, etc.) and return them to the user. A possible problem with this approach would be higher latency as we have to query multiple tables and perform sorting/merging/ranking on the results. To improve the efficiency, we can pre-generate the News Feed and store it in a separate table. Pre-generating the News Feed Dedicated servers that are continuously generating users’ News Feeds and storing them in a ‘UserNewsFeed’ table. whenever any user needs the latest photos for their News Feed, we will simply query this table and return the results to the user. What are the different approaches for sending News Feed contents to the users? Pull Clients can pull the News Feed contents from the server on a regular basis or manually whenever they need it. Possible problems New data might not be shown to the users until clients issue a pull request Most of the time pull requests will result in an empty response if there is no new data. Problem a user who follows a lot of people or a celebrity user who has millions of followers in this case, the server has to push updates quite frequently. Or: That the server pushes updates to all the users not more than a certain frequency, letting users with a lot of follows/updates to regularly pull data. Push Servers can push new data to the users as soon as it is available. To efficiently manage this, users have to maintain a Long Poll request with the server for receiving the updates. Hybrid move all the users who have a high number of follows to a pull-based model push data to those users who have a few hundred (or thousand) follows Other Techniques need to know as base Polling Situation 1 when an I/O operation is required, the computer does nothing other than check the status of the I/O device until it is ready at which point the device is accessed. In other words, the computer waits until the device is ready. Situation 2 where a device is repeatedly checked for readiness, and if it is not, the computer returns to a different task. Long Polling the client requests information from the server exactly as in normal polling with the expectation the server may not respond immediately. If the server has no new information for the client when the poll is received, the server holds the request open and waits for response information to become available. Once it does have new information, the server immediately sends an HTTP/S response to the client, completing the open HTTP/S Request. Upon receipt of the server response, the client often immediately issues another server request. News Feed Creation with Sharded Data One of the most important requirement to create the News Feed for any given user is to fetch the latest photos from all people the user follows. Need to have a mechanism to sort photos on their time of creation. Make photo creation time part of the PhotoID As we will have a primary index on PhotoID, it will be quite quick to find the latest PhotoIDs PhotoID = epoch time + auto-incrementing sequence(auto-incrementing ID from our key-generating DB) Figure out shard number from this PhotoID ( PhotoID % 10) and store the photo there What could be the size of our PhotoID? our epoch time starts today, how many bits we would need to store the number of seconds for next 50 years? 86400 sec/day * 365 (days a year) * 50 (years) =&gt; 1.6 billion seconds Need 31 bits to store this number Expecting 23 new photos per second; we can allocate 9 bits to store auto incremented sequence Every second we can store (2^9 =&gt; 512) new photos Can reset our auto incrementing sequence every second Cache and Load Balancing Need a massive-scale photo delivery system to serve the globally distributed users Service should push its content closer to the user using a large number of geographically distributed photo cache servers and use CDNs A cache for metadata servers to cache hot database rows Use Memcache to cache the data and Application servers before hitting database can quickly check if the cache has desired rows. Least Recently Used (LRU) can be a reasonable cache eviction policy for our system How can we build more intelligent cache? If we go with 80-20 rule: 20% of daily read volume for photos is generating 80% of traffic which means that certain photos are so popular that the majority of people read them. Can try caching 20% of daily read volume of photos and metadata","categories":[{"name":"System Design","slug":"System-Design","permalink":"https://jojoyang666.github.io/categories/System-Design/"}],"tags":[]},{"title":"Designing Pastebin","slug":"Designing-Pastebin","date":"2020-11-02T17:30:32.000Z","updated":"2020-11-02T22:16:55.547Z","comments":true,"path":"2020/11/02/Designing-Pastebin/","link":"","permalink":"https://jojoyang666.github.io/2020/11/02/Designing-Pastebin/","excerpt":"","text":"What is Pastebin? Services enable users to store plain text or images over the network(typically the internet) generate unique URLs to access the uploaded data Requirements and GoalsFunctional Requirements Users should be able to upload or ‘paste’ their data and get a unique URL to access it Users will only be able to upload text Data and links will expire after a specific timespan automatically; users should also be able to specify expiration time Users should optionally be able to pick a custom alias for their paste Non-Functional Requirements The system should be highly reliable, any data uploaded should not be lost The system should be highly available. This is required because if our service is down, users will not be able to access their Pastes Users should be able to access their Pastes in real-time with minimum latency Extended Requirements Analytics, e.g.. how many times a paste was accessed? Our serivce should also be accessible through REST APIs by other services Some Design Considerations some requirements with Designing a URL Shortening service like TinyURL, but there are some additional desgin considerations we should keep in mind what should be the limit on the amount of text user can paste at a time? we can limit users not to have Pastes bigger than 10MB to stop the abuse of the service should we impose size limits on custom URLs? Since our service supports custom URLs, users can pick any URL that they like, but providing a custom URL is not mandatory It is mandatory(and often desirable) to impose a size limit on custom URLs, so that we have a consistent URL db Capacity Estimation and Constraints our services will be read-heavy –&gt; more read requests compared to new Paste creation Assume a 5:1 ratio betweem the read and write Traffice Estimates Assume: 1M new pastes added to the system every day –&gt; 5M reads/day New pastes per second: 1M / (24 hours * 3600 seconds) ~= 12 pastes/sec Paste reads per second: 5M / (24 hours * 3600 seconds) ~= 58 reads/sec Storage Estimates Users can upload maximum 10Mb of data Commonly Pastebin like services are used to share source code, configs or logs such texts are not huge, let’s assume thant each paste on average contains 10KB Storing 10GB of data per day 1M * 10KB =&gt; 10 GB/day Store this data for 10 years, need storage capacity of 36TB with 1M pastes ervery day, will have 3.6 billion pastes in 10 years generate and store keys to uniquely identify the pastes. If use base64 encoding([A-Z, a-z, 0-9,..]), need six letter strings 64^6 ~= 68.7 billion unique strings if it takes one byte to store one character, total size required to store 3.6Bkeys: 6B * 6 =&gt; 22 GB 22GB is negligible compared to 36 TB Assume 70% capacity model, which means we do not not want to use more than 70% of our storage capacity at any point, raises storage needs to 51.4TB Bandwidth estimates For write requests, expect 12 new pastes per second, resulting in 120KB of ingress per second12 * 10KB =&gt; 120 KB/s For read request, expect 58 requests per second, total data egress(sent to users) will be 0.6MB/s58 * 10KB =&gt; 0.6 MB/s Although total ingress and egress are not big, we should keep these numbers in mind while designing our service Memory Estimates Cache some of the hot pastes that are frequently accessed Following the 80-20 rule, meaning 20% of hot pastes generate 80% traffice, we would like to cache these 20% pastes 0.2 * 5M * 10KB ~= 10 GB System APIs addPaste(api_dev_key, paste_data, custom_url=None user_name=None, paste_name=None, expire_date=None) api_dev_key (string): The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota paste_data (string): Textual data of the paste. custom_url (string): Optional custom URL user_name (string): Optional user name to be used to generate URL. paste_name (string): Optional name of the paste expire_date (string): Optional expiration date for the paste.Returns: (string)A successful insertion returns the URL through which the paste can be accessed, otherwise, it will return an error code. getPaste(api_dev_key, api_paste_key) “api_paste_key” is a string representing the Paste Key of the paste to be retrieved. This API will return the textual data of the paste. deletePaste(api_dev_key, api_paste_key) A successful deletion returns ‘true’, otherwise returns ‘false’. Database Design some observations about the nature of the data We need to store billions of records. Each metadata object we are storing would be small (less than 1KB). Each paste object we are storing can be of medium size (it can be a few MB). There are no relationsips between records, except if we want to store which user screated what paste Our service is read-heavy Data schema ‘URlHash’ is the URL equivalent of the TinyURL ‘ContentKey’ is a reference to an external object storing the contents of the paste; High Level Design Need an application layer that will serve all the read and write requests Applicayion layer will talk to a storage layer to store and retrieve data can segregate our storage layer with one db storing metadata related to each paste, users, etc. the other storing the paste contents in some object storage(like Amazon S3) This division of data will also allow us to scale them individually Component DesignApplication layer how to handle a write-request? Upon receiving a write-request, application layer will generate a six-letter random string, which would serve as the key of the paste(if user not provide a custom key) Application layer will then store the contents of the paste and the generated key in the db after the sucessful insertion, the server can return the key to the user One possible problem here The insertion fails because of a duplicate keySolution 1 We should regenerate a new key and try again until we do not seen the duplication If the custom key user provided is already present in db, should return an error to the userSolution 2 Run a standalone Key Generation Service(KGS) generates random six letters strings beforehand and stores them in a database (let’s call it key-DB). Whenever we want to store a new paste, we will just take one of the already generated keys and use it. we will not be worrying about duplications or collisions. KGS can use two tables to store keys one for keys that are not used yet one for all the used keys KGS can always keep some keys in memory so that whenever a server needs them, it can quickly provide them. As soon as KGS loads some keys in memory, it can move them to the used keys table, this way we can make sure each server gets unique keys If KGS dies before using all the keys loaded in memory, we will be wasting those keys. We can ignore these keys given that we have a huge number of them. Is not KGS a single point of failure? Yes, it is. To solve this, we can have a standby replica of KGS whenever the primary server dies it can take over to generate and provide keys. Can each app server cache some keys from key-DB? Yes, this can surely speed things up. Although in this case, if the application server dies before consuming all the keys, we will end up losing those keys. This could be acceptable since we have 68B unique six letters keys, which are a lot more than we require. How does it handle a paste read request? Upon receiving a read paste request, the application service layer contacts the datastore. The datastore searches for the key, and if it is found, it returns the paste’s contents. Otherwise, an error code is returned. Datastore layerwe can divide the datastire layer into two Metadata database: We can use a relational database like MySQL or a Distributed Key-Value store like Dynamo or Cassandra. Object storage: We can store our contents in an Object Storage like Amazon’s S3. Whenever we feel like hitting our full capacity on content storage, we can easily increase it by adding more servers. Purging or DB cleanupsame with Designing a URL Shortening service like TinyURL Data partitioning and replicationsame with Designing a URL Shortening service like TinyURL cache and load balancersame with Designing a URL Shortening service like TinyURL Security and permisionssame with Designing a URL Shortening service like TinyURL","categories":[{"name":"System Design","slug":"System-Design","permalink":"https://jojoyang666.github.io/categories/System-Design/"}],"tags":[]},{"title":"1202. Smallest String With Swaps ","slug":"1202-Smallest-String-With-Swaps","date":"2020-11-02T06:17:44.000Z","updated":"2020-11-02T06:40:17.310Z","comments":true,"path":"2020/11/01/1202-Smallest-String-With-Swaps/","link":"","permalink":"https://jojoyang666.github.io/2020/11/01/1202-Smallest-String-With-Swaps/","excerpt":"","text":"You can swap the characters at any pair of indices in the given pairs any number of times. –&gt; using union find 1234567891011121314151617181920212223242526272829303132333435class UF: def __init__(self, N): self.parent = range(N) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): self.parent[self.find(x)] = self.find(y) class Solution(object): def smallestStringWithSwaps(self, s, pairs): \"\"\" :type s: str :type pairs: List[List[int]] :rtype: str \"\"\" uf = UF(len(s)) m = defaultdict(list) for x, y in pairs: uf.union(x,y) for i in range(len(s)): m[uf.find(i)].append(s[i]) for k in m: m[k].sort(reverse=True) res = [] for i in range(len(s)): res.append(m[uf.find(i)].pop()) return ''.join(res)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"795. Number of Subarrays with Bounded Maximum ","slug":"795-Number-of-Subarrays-with-Bounded-Maximum","date":"2020-11-02T06:00:07.000Z","updated":"2020-11-02T06:00:30.373Z","comments":true,"path":"2020/11/01/795-Number-of-Subarrays-with-Bounded-Maximum/","link":"","permalink":"https://jojoyang666.github.io/2020/11/01/795-Number-of-Subarrays-with-Bounded-Maximum/","excerpt":"","text":"1234567891011121314151617class Solution(object): def numSubarrayBoundedMax(self, A, L, R): \"\"\" :type A: List[int] :type L: int :type R: int :rtype: int \"\"\" # Find the number of sub arrays that have all elements less than or equal to bound def count(bound): ans = cur = 0 for x in A: cur = cur + 1 if x &lt;= bound else 0 ans += cur return ans return count(R) - count(L-1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"454. 4Sum II","slug":"454-4Sum-II","date":"2020-11-02T05:41:27.000Z","updated":"2020-11-02T05:47:18.264Z","comments":true,"path":"2020/11/01/454-4Sum-II/","link":"","permalink":"https://jojoyang666.github.io/2020/11/01/454-4Sum-II/","excerpt":"","text":"4sum ==&gt; 2sum 1234567891011121314151617181920class Solution(object): def fourSumCount(self, A, B, C, D): \"\"\" :type A: List[int] :type B: List[int] :type C: List[int] :type D: List[int] :rtype: int \"\"\" m = defaultdict(int) for a in A: for b in B: m[a + b] += 1 cnt = 0 for c in C: for d in D: cnt += m[-c-d] return cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"386. Lexicographical Numbers","slug":"386-Lexicographical-Numbers","date":"2020-11-02T05:16:40.000Z","updated":"2020-11-02T05:29:22.773Z","comments":true,"path":"2020/11/01/386-Lexicographical-Numbers/","link":"","permalink":"https://jojoyang666.github.io/2020/11/01/386-Lexicographical-Numbers/","excerpt":"","text":"这种思路是按个位数遍历 在遍历下一个个位数之前，先遍历十位数，十位数的高位为之前的个位数，只要这个多位数并没有超过n，就可以一直往后遍历， 如果超过了，我们除以10，然后再加1，如果加1后末尾形成了很多0，那么我们要用个while循环把0都去掉，然后继续运算， 12345678910111213141516171819202122class Solution(object): def lexicalOrder(self, n): \"\"\" :type n: int :rtype: List[int] \"\"\" res = [0] * n cur = 1 for i in range(n): res[i] = cur if cur * 10 &lt;= n: cur *= 10 else: if cur &gt;= n: cur /= 10 cur += 1 while cur%10 == 0: cur /= 10 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"63. Unique Paths II","slug":"63-Unique-Paths-II","date":"2020-11-02T04:41:01.000Z","updated":"2020-11-02T04:41:23.616Z","comments":true,"path":"2020/11/01/63-Unique-Paths-II/","link":"","permalink":"https://jojoyang666.github.io/2020/11/01/63-Unique-Paths-II/","excerpt":"","text":"1234567891011121314151617181920212223242526class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): \"\"\" :type obstacleGrid: List[List[int]] :rtype: int \"\"\" m, n = len(obstacleGrid), len(obstacleGrid[0]) if obstacleGrid[0][0] == 1: return 0 obstacleGrid[0][0] = 1 for i in range(1, m): obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0]) for j in range(1, n): obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1]) for i in range(1, m): for j in range(1, n): if obstacleGrid[i][j] == 0: obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1] else: obstacleGrid[i][j] = 0 return obstacleGrid[m-1][n-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"889. Construct Binary Tree from Preorder and Postorder Traversal","slug":"889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal","date":"2020-10-31T23:00:41.000Z","updated":"2020-10-31T23:03:35.919Z","comments":true,"path":"2020/10/31/889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal/","link":"","permalink":"https://jojoyang666.github.io/2020/10/31/889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal/","excerpt":"","text":"通过length来左recursive find pre/pos list of subtree 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def constructFromPrePost(self, pre, post): \"\"\" :type pre: List[int] :type post: List[int] :rtype: TreeNode \"\"\" if not pre: return None root = TreeNode(pre[0]) if len(pre) == 1: return root L = post.index(pre[1]) + 1#length of left tree root.left= self.constructFromPrePost(pre[1:L+1], post[:L]) root.right = self.constructFromPrePost(pre[L+1:], post[L:-1]) return root","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1233. Remove Sub-Folders from the Filesystem ","slug":"1233-Remove-Sub-Folders-from-the-Filesystem","date":"2020-10-31T21:50:42.000Z","updated":"2020-10-31T21:52:31.066Z","comments":true,"path":"2020/10/31/1233-Remove-Sub-Folders-from-the-Filesystem/","link":"","permalink":"https://jojoyang666.github.io/2020/10/31/1233-Remove-Sub-Folders-from-the-Filesystem/","excerpt":"","text":"cornor case: startswith(f + ‘/‘)a/b, a/bc 1234567891011class Solution(object): def removeSubfolders(self, folder): \"\"\" :type folder: List[str] :rtype: List[str] \"\"\" res = [] for f in sorted(folder): if not res or not f.startswith(res[-1]+'/'): res.append(f) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"467. Unique Substrings in Wraparound String","slug":"467-Unique-Substrings-in-Wraparound-String","date":"2020-10-31T21:29:08.000Z","updated":"2020-10-31T21:36:23.834Z","comments":true,"path":"2020/10/31/467-Unique-Substrings-in-Wraparound-String/","link":"","permalink":"https://jojoyang666.github.io/2020/10/31/467-Unique-Substrings-in-Wraparound-String/","excerpt":"","text":"res表示以i结尾的最长substring -&gt; length is a, then final res_val += a 12345678910111213141516class Solution(object): def findSubstringInWraproundString(self, p): \"\"\" :type p: str :rtype: int \"\"\" res = &#123;i: 1 for i in p&#125; length = 1 for i, c in enumerate(p): if i &gt; 0 and (ord(c) - ord(p[i-1]) == 1 or ord(c) - ord(p[i-1]) == -25): length += 1 else: length = 1 res[c] = max(res[c], length) return sum(res.values())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1026. Maximum Difference Between Node and Ancestor ","slug":"1026-Maximum-Difference-Between-Node-and-Ancestor","date":"2020-10-31T20:51:10.000Z","updated":"2020-10-31T20:56:22.455Z","comments":true,"path":"2020/10/31/1026-Maximum-Difference-Between-Node-and-Ancestor/","link":"","permalink":"https://jojoyang666.github.io/2020/10/31/1026-Maximum-Difference-Between-Node-and-Ancestor/","excerpt":"","text":"因为是ancestor所以要从上到下而不是从下到上 找到最大的 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def maxAncestorDiff(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def helper(root, max_val, min_val): if not root: return max_val - min_val res1 = helper(root.left, max(max_val, root.val), min(min_val, root.val)) res2 = helper(root.right, max(max_val, root.val), min(min_val, root.val)) return max(res1, res2) return helper(root, float('-inf'), float('inf'))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"611. Valid Triangle Number ","slug":"611-Valid-Triangle-Number","date":"2020-10-31T20:19:22.000Z","updated":"2020-10-31T20:20:19.664Z","comments":true,"path":"2020/10/31/611-Valid-Triangle-Number/","link":"","permalink":"https://jojoyang666.github.io/2020/10/31/611-Valid-Triangle-Number/","excerpt":"","text":"sort kind of liking 3sum 12345678910111213141516class Solution(object): def triangleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" res = 0 nums.sort() for i in range(0, len(nums)-2): if nums[i] == 0: continue k = i + 2 for j in range(i+1, len(nums)-1): while k &lt; len(nums) and nums[i] + nums[j] &gt; nums[k]: k += 1 res += k - j - 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1262. Greatest Sum Divisible by Three","slug":"1262-Greatest-Sum-Divisible-by-Three","date":"2020-10-31T18:55:36.000Z","updated":"2020-10-31T19:54:41.145Z","comments":true,"path":"2020/10/31/1262-Greatest-Sum-Divisible-by-Three/","link":"","permalink":"https://jojoyang666.github.io/2020/10/31/1262-Greatest-Sum-Divisible-by-Three/","excerpt":"","text":"dp[i] (i: 0, 1, 2): represent the greatest sum which module 3 is 0, 1, 2(in current array a) formula: (num is the current last number in a) val = (dp[i] + num)%3 dp[i] = max(dp[val], dp[i] + num) Cornor case: 当前更新的值可能影响后面的值， 所以要new tmp array seen[:] will generate a new array not the original one 12345678910111213class Solution(object): def maxSumDivThree(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" dp = [0, 0, 0] for num in nums: tmp = list(dp) for i in range(3): mol = tmp[i] + num dp[mol%3] = max(dp[mol%3], mol) return dp[0] 123456789101112class Solution(object): def maxSumDivThree(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" dp = [0, 0, 0] for num in nums: for i in dp[:]: mol = i + num dp[mol%3] = max(dp[mol%3], mol) return dp[0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"853. Car Fleet","slug":"853-Car-Fleet","date":"2020-10-31T17:41:33.000Z","updated":"2020-10-31T18:03:01.893Z","comments":true,"path":"2020/10/31/853-Car-Fleet/","link":"","permalink":"https://jojoyang666.github.io/2020/10/31/853-Car-Fleet/","excerpt":"","text":"12345678910111213141516171819202122class Solution(object): def carFleet(self, target, position, speed): \"\"\" :type target: int :type position: List[int] :type speed: List[int] :rtype: int \"\"\" cars = sorted(zip(position, speed)) times = [float(target - p)/s for p, s in cars] res = 0 while times: lead = times.pop() if len(times) == 0 or times[-1] &gt; lead: res += 1 else: times[-1] = lead return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"838. Push Dominoes","slug":"838-Push-Dominoes","date":"2020-10-31T02:58:50.000Z","updated":"2020-10-31T03:05:28.017Z","comments":true,"path":"2020/10/30/838-Push-Dominoes/","link":"","permalink":"https://jojoyang666.github.io/2020/10/30/838-Push-Dominoes/","excerpt":"","text":"12345678910111213141516171819202122232425class Solution(object): def pushDominoes(self, dominoes): \"\"\" :type dominoes: str :rtype: str \"\"\" dominoes = list(dominoes) cnt = [0] * len(dominoes) n = len(dominoes) for i in xrange(1, n): if dominoes[i-1] == 'R' and dominoes[i] == '.': dominoes[i] = 'R' cnt[i] = cnt[i-1] + 1 # after first for loop, cnt[i] where deminoes[i] == 'L' is 0 for i in xrange(n-2, -1, -1): if dominoes[i+1] == 'L': cur = cnt[i+1] + 1 if dominoes[i] == '.' or cnt[i] &gt; cur: # 说明右侧的dominoes falls to this position first dominoes[i] = 'L' cnt[i] = cur elif dominoes[i] == 'R' and cur == cnt[i]: dominoes[i] = '.' return ''.join(dominoes)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1570. Dot Product of Two Sparse Vectors","slug":"1570-Dot-Product-of-Two-Sparse-Vectors","date":"2020-10-30T21:51:22.000Z","updated":"2020-10-30T21:51:42.656Z","comments":true,"path":"2020/10/30/1570-Dot-Product-of-Two-Sparse-Vectors/","link":"","permalink":"https://jojoyang666.github.io/2020/10/30/1570-Dot-Product-of-Two-Sparse-Vectors/","excerpt":"","text":"12345678910111213141516171819class SparseVector: def __init__(self, nums): \"\"\" :type nums: List[int] \"\"\" self.map = &#123;i: num for i, num in enumerate(nums) if num&#125; # Return the dotProduct of two sparse vectors def dotProduct(self, vec): \"\"\" :type vec: 'SparseVector' :rtype: int \"\"\" return sum(self.map[i] * vec.map[i] for i in self.map if i in vec.map)# Your SparseVector object will be instantiated and called as such:# v1 = SparseVector(nums1)# v2 = SparseVector(nums2)# ans = v1.dotProduct(v2)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1166. Design File System","slug":"1166-Design-File-System","date":"2020-10-30T21:39:29.000Z","updated":"2020-10-30T21:40:42.138Z","comments":true,"path":"2020/10/30/1166-Design-File-System/","link":"","permalink":"https://jojoyang666.github.io/2020/10/30/1166-Design-File-System/","excerpt":"","text":"hashmap 1234567891011121314151617181920212223242526272829class FileSystem(object): def __init__(self): self.d = &#123;\"\": -1&#125; def createPath(self, path, value): \"\"\" :type path: str :type value: int :rtype: bool \"\"\" parent = path[:path.rfind('/')] if parent not in self.d or path in self.d: return False self.d[path] = value return True def get(self, path): \"\"\" :type path: str :rtype: int \"\"\" return self.d[path] if path in self.d else -1# Your FileSystem object will be instantiated and called as such:# obj = FileSystem()# param_1 = obj.createPath(path,value)# param_2 = obj.get(path)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1296. Divide Array in Sets of K Consecutive Numbers","slug":"1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers","date":"2020-10-30T21:19:01.000Z","updated":"2020-10-30T21:21:24.585Z","comments":true,"path":"2020/10/30/1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers/","link":"","permalink":"https://jojoyang666.github.io/2020/10/30/1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers/","excerpt":"","text":"1234567891011121314151617181920class Solution(object): def isPossibleDivide(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: bool \"\"\" counter = collections.Counter(nums) starts = [key for key in counter if counter[key-1] == 0] while starts: start = starts.pop() for i in range(start + k - 1, start-1, -1): if counter[i] &lt; counter[start]: return False counter[i] -= counter[start] if counter[i] == 0 and counter[i+1] != 0: starts.append(i+1) return True","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"450. Delete Node in a BST","slug":"450-Delete-Node-in-a-BST","date":"2020-10-30T04:26:51.000Z","updated":"2020-10-30T05:04:46.493Z","comments":true,"path":"2020/10/29/450-Delete-Node-in-a-BST/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/450-Delete-Node-in-a-BST/","excerpt":"","text":"recursive to solve it 不是就return current node 是的话 就delete node and return new node12345678910111213141516171819202122232425262728293031323334# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def deleteNode(self, root, key): \"\"\" :type root: TreeNode :type key: int :rtype: TreeNode \"\"\" if not root: return root if root.val &lt; key: root.right = self.deleteNode(root.right, key) elif root.val &gt; key: root.left = self.deleteNode(root.left, key) else: if not root.left and not root.right: return None elif root.right: node = root.right left = node while left and left.left: left = left.left left.left = root.left root = node else: root = root.left return root","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1268. Search Suggestions System","slug":"1268-Search-Suggestions-System","date":"2020-10-30T03:57:56.000Z","updated":"2020-10-30T04:02:42.479Z","comments":true,"path":"2020/10/29/1268-Search-Suggestions-System/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/1268-Search-Suggestions-System/","excerpt":"","text":"if word.startswith(prefix)])这个判断不能少 12345678910111213141516class Solution(object): def suggestedProducts(self, products, searchWord): \"\"\" :type products: List[str] :type searchWord: str :rtype: List[List[str]] \"\"\" products.sort() prefix = '' res, i = [], 0 for c in searchWord: prefix += c i = bisect.bisect_left(products, prefix, i) res.append([word for word in products[i:i+3] if word.startswith(prefix)]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"713. Subarray Product Less Than K","slug":"713-Subarray-Product-Less-Than-K","date":"2020-10-30T03:15:16.000Z","updated":"2020-10-30T03:15:44.624Z","comments":true,"path":"2020/10/29/713-Subarray-Product-Less-Than-K/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/713-Subarray-Product-Less-Than-K/","excerpt":"","text":"12345678910111213141516171819class Solution(object): def numSubarrayProductLessThanK(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" if k &lt;= 1: return 0 left, res, product = 0, 0, 1 for right, val in enumerate(nums): product *= val while product &gt;= k: product /= nums[left] left += 1 res += right - left + 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"333. Largest BST Subtree","slug":"333-Largest-BST-Subtree","date":"2020-10-30T02:36:58.000Z","updated":"2020-10-30T02:39:29.451Z","comments":true,"path":"2020/10/29/333-Largest-BST-Subtree/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/333-Largest-BST-Subtree/","excerpt":"","text":"当前节点是BST的一个重要条件是： 当前节点的值一定要比左节点的最大节点的值要大， 比右子树的最小节点要小 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def largestBSTSubtree(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def dfs(root):# return 4 values: return the size of the largest BST in the tree# if is a BST, n is the number of nodes, other is -infinity# if is the bst, min/max is the min/max value in the tree if not root: return 0, 0, float('inf'), float('-inf') N1, n1, min1, max1 = dfs(root.left) N2, n2, min2, max2 = dfs(root.right) if max1 &lt; root.val &lt; min2 and n1 != float('-inf') and n2 != float('-inf'): n = n1 + n2 + 1 else: n = float('-inf') return max(N1, N2, n), n, min(min1, root.val), max(root.val, max2) return dfs(root)[0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"898. Bitwise ORs of Subarrays","slug":"898-Bitwise-ORs-of-Subarrays","date":"2020-10-30T01:02:39.000Z","updated":"2020-10-30T01:04:12.899Z","comments":true,"path":"2020/10/29/898-Bitwise-ORs-of-Subarrays/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/898-Bitwise-ORs-of-Subarrays/","excerpt":"","text":"12345678910111213class Solution(object): def subarrayBitwiseORs(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" ans = set() cur = set() for num in A: cur = &#123;num | x for x in cur&#125; | &#123;num&#125; ans |= cur return len(ans)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"95. Unique Binary Search Trees II","slug":"95-Unique-Binary-Search-Trees-II","date":"2020-10-29T22:44:12.000Z","updated":"2020-10-29T22:49:01.638Z","comments":true,"path":"2020/10/29/95-Unique-Binary-Search-Trees-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/95-Unique-Binary-Search-Trees-II/","excerpt":"","text":"Recursive tp find allsubproblem 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def generateTrees(self, n): \"\"\" :type n: int :rtype: List[TreeNode] \"\"\" def helper(start, end): if start &gt; end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = helper(start, i-1) right_trees = helper(i+1, end) for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees return helper(1, n) if n else []","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"47. Permutations II","slug":"47-Permutations-II","date":"2020-10-29T21:58:12.000Z","updated":"2020-10-29T22:29:32.632Z","comments":true,"path":"2020/10/29/47-Permutations-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/47-Permutations-II/","excerpt":"","text":"12345678910111213141516171819202122class Solution(object): def permuteUnique(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" res = [] def backtrack(comb, counter): if len(comb) == len(nums): res.append(list(comb)) return for num in counter:# iterate key in counter to guarantee no repetition if counter[num] &gt; 0: comb.append(num) counter[num] -= 1 backtrack(comb, counter) comb.pop() counter[num] += 1 backtrack([], Counter(nums)) return res (i &gt; 0 and nums[i-1] == nums[i]) and not used[i-1]这个条件很重要 not used[i-1] 12345678910111213141516171819202122class Solution(object): def permuteUnique(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" res = [] used = [False]*len(nums) def backtrack(comb): if len(comb) == len(nums): res.append(list(comb)) return for i in range(len(nums)): if ((i &gt; 0 and nums[i-1] == nums[i]) and not used[i-1]) or used[i]: continue used[i] = True backtrack(comb + [nums[i]]) used[i] = False nums.sort() backtrack([]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1019. Next Greater Node In Linked List","slug":"1019-Next-Greater-Node-In-Linked-List","date":"2020-10-29T21:50:22.000Z","updated":"2020-10-29T21:50:47.018Z","comments":true,"path":"2020/10/29/1019-Next-Greater-Node-In-Linked-List/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/1019-Next-Greater-Node-In-Linked-List/","excerpt":"","text":"12345678910111213141516171819202122# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def nextLargerNodes(self, head): \"\"\" :type head: ListNode :rtype: List[int] \"\"\" res, stack = [], [] while head: while stack and head.val &gt; stack[-1][1]: i, _ = stack.pop() res[i] = head.val stack.append([len(res), head.val]) res.append(0) head = head.next return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"918. Maximum Sum Circular Subarray","slug":"918-Maximum-Sum-Circular-Subarray","date":"2020-10-29T20:13:27.000Z","updated":"2020-10-29T20:21:37.668Z","comments":true,"path":"2020/10/29/918-Maximum-Sum-Circular-Subarray/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/918-Maximum-Sum-Circular-Subarray/","excerpt":"","text":"1234567891011121314151617181920212223class Solution(object): def maxSubarraySumCircular(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" max_sum, min_sum, s, min_s = float('-inf'), float('inf'), 0, 0 for num in A: s += num min_s += num min_sum = min(min_sum, min_s) max_sum = max(s, max_sum) if s &lt; 0: s = 0 if min_s &gt; 0: min_s = 0 return max(max_sum, sum(A)-min_sum) if max_sum &gt; 0 else max_sum","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1366. Rank Teams by Votes","slug":"1366-Rank-Teams-by-Votes","date":"2020-10-29T19:22:58.000Z","updated":"2020-10-29T19:31:23.703Z","comments":true,"path":"2020/10/29/1366-Rank-Teams-by-Votes/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/1366-Rank-Teams-by-Votes/","excerpt":"","text":"given the sequence and sort based on thatbecause we want from highest to lowest so count[v][i] -= 1 -1 not +1 12345678910111213class Solution(object): def rankTeams(self, votes): \"\"\" :type votes: List[str] :rtype: str \"\"\" count = &#123;v: [0]*len(votes[0]) + [v] for v in votes[0]&#125; for vote in votes: for i, v in enumerate(vote): count[v][i] -= 1 return ''.join(sorted(votes[0], key=count.get))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"646. Maximum Length of Pair Chain","slug":"646-Maximum-Length-of-Pair-Chain","date":"2020-10-29T18:47:40.000Z","updated":"2020-10-29T18:49:29.318Z","comments":true,"path":"2020/10/29/646-Maximum-Length-of-Pair-Chain/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/646-Maximum-Length-of-Pair-Chain/","excerpt":"","text":"Greedy: 重点一定要知道what should be sorting based on 12345678910111213class Solution(object): def findLongestChain(self, pairs): \"\"\" :type pairs: List[List[int]] :rtype: int \"\"\" cur, ans = float('-inf'), 0 for s, e in sorted(pairs, key= lambda pair: pair[1]): if s &gt; cur: cur = e ans += 1 return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1497. Check If Array Pairs Are Divisible by k","slug":"1497-Check-If-Array-Pairs-Are-Divisible-by-k","date":"2020-10-29T17:28:18.000Z","updated":"2020-10-29T17:41:46.357Z","comments":true,"path":"2020/10/29/1497-Check-If-Array-Pairs-Are-Divisible-by-k/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/1497-Check-If-Array-Pairs-Are-Divisible-by-k/","excerpt":"","text":"数学a%k = m b%k = n if (a + b)%k == 0 ===&gt; m+n =k 12345678910111213141516171819202122class Solution(object): def canArrange(self, arr, k): \"\"\" :type arr: List[int] :type k: int :rtype: bool \"\"\" reminders = [num%k for num in arr] reminders.sort() left, right = 0, len(arr)-1 while left &lt;= right and reminders[left] == 0: left += 1 if left%2 == 1: return False while left &lt; right: if reminders[left] + reminders[right] != k: return False left += 1 right -= 1 return True 123456789101112131415161718class Solution(object): def canArrange(self, arr, k): \"\"\" :type arr: List[int] :type k: int :rtype: bool \"\"\" reminders = [num%k for num in arr] counter = Counter(reminders) for key in counter: if key == 0: if counter[key]%2: return False else: continue if not (k - key in counter and counter[key] == counter[k-key]): return False return True","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum ","slug":"1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum","date":"2020-10-29T16:34:03.000Z","updated":"2020-10-29T16:49:59.686Z","comments":true,"path":"2020/10/29/1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum/","excerpt":"","text":"using another premin[i] array to store the min length of subarray which sum is equal is target in the array which starts with 0 ends with i, premin保证了不会overlap 数组越界in python可能是是a[-1] 不会越界， 但是有时候考虑是否有效的what we want 12345678910111213141516171819202122232425class Solution(object): def minSumOfLengths(self, arr, target): \"\"\" :type arr: List[int] :type target: int :rtype: int \"\"\" premin = [float('inf')] * len(arr) cur = window = left = 0 res = float('inf') for i, val in enumerate(arr): window += val while window &gt; target: window -= arr[left] left += 1 if window == target: cur = i - left + 1 #注意及时left==0， premin[-1]表示最后一个item 这时候还没有更新 依旧是最大 res = min(res, cur + premin[left-1]) premin[i] = min(cur, premin[i-1]) else: premin[i] = premin[i-1] return res if res &lt; float('inf') else -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1405. Longest Happy String","slug":"1405-Longest-Happy-String","date":"2020-10-29T15:54:16.000Z","updated":"2020-10-29T16:06:43.817Z","comments":true,"path":"2020/10/29/1405-Longest-Happy-String/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/1405-Longest-Happy-String/","excerpt":"","text":"为了简化， 要做个默认的设置a &gt;= b &gt;= c, 所以helper函数中， 先对大小进行调整 当大小调整好了我们只用来计算a,b能组成的字符串， 因为当b &lt; c时 c会被交换到b位置12345678910111213141516171819202122class Solution(object): def longestDiverseString(self, a, b, c): \"\"\" :type a: int :type b: int :type c: int :rtype: str \"\"\" return self.helper(a, b, c, 'a', 'b', 'c')# preprocess to assume a &gt;= b &gt;= c. def helper(self, a, b, c, aa, bb, cc): if a &lt; b: return self.helper(b, a, c, bb, aa, cc) if b &lt; c: return self.helper(a, c, b, aa, cc, bb) if b == 0: return aa * min(2, a) use_a = min(a, 2) use_b = 1 if a - use_a &gt;=b else 0 #这里一定要计算作为阻隔， 但是当a - use_a &lt; b后use_b必需为0 因为递归会进行置换， 如果在这一步用了b可能求出来的就不是最长的了 return use_a*aa + bb * use_b + self.helper(a-use_a, b-use_b, c, aa, bb, cc)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"593. Valid Square","slug":"593-Valid-Square","date":"2020-10-29T15:13:42.000Z","updated":"2020-10-29T15:15:45.433Z","comments":true,"path":"2020/10/29/593-Valid-Square/","link":"","permalink":"https://jojoyang666.github.io/2020/10/29/593-Valid-Square/","excerpt":"","text":"square: 对角线相等 边相等 –》 任意两点之间的距离 只有两种， 并且不能为0 12345678910111213141516171819class Solution(object): def validSquare(self, p1, p2, p3, p4): \"\"\" :type p1: List[int] :type p2: List[int] :type p3: List[int] :type p4: List[int] :rtype: bool \"\"\" def dist(p1, p2): return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 points = [p1, p2, p3, p4] s = set() for i in range(4): for j in range(i+1, 4): d = dist(points[i], points[j]) s.add(d) return len(s) == 2 and 0 not in s","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"662. Maximum Width of Binary Tree","slug":"662-Maximum-Width-of-Binary-Tree","date":"2020-10-29T04:08:41.000Z","updated":"2020-10-29T04:14:42.234Z","comments":true,"path":"2020/10/28/662-Maximum-Width-of-Binary-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/662-Maximum-Width-of-Binary-Tree/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def widthOfBinaryTree(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 max_width = 0 queue = deque() queue.append((root, 0)) while queue: level_length = len(queue) _, level_head_index = queue[0] for _ in range(level_length): node, col_index = queue.popleft() if node.left: queue.append((node.left, 2 * col_index)) if node.right: queue.append((node.right, 2 * col_index + 1)) max_width = max(max_width, col_index - level_head_index + 1) return max_width 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def widthOfBinaryTree(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" first_col_index_table = &#123;&#125; self.max_width = 0 def DFS(node, depth, col_index): if not node: return if depth not in first_col_index_table: first_col_index_table[depth] = col_index self.max_width = max(self.max_width, col_index - first_col_index_table[depth] + 1) DFS(node.left, depth+1, 2 * col_index) DFS(node.right, depth+1, 2 * col_index + 1) DFS(root, 0, 0) return self.max_width","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1191-K-Concatenation-Maximum-Sum","slug":"1191-K-Concatenation-Maximum-Sum","date":"2020-10-29T03:35:39.748Z","updated":"2020-10-29T03:51:54.574Z","comments":true,"path":"2020/10/28/1191-K-Concatenation-Maximum-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/1191-K-Concatenation-Maximum-Sum/","excerpt":"","text":"title: 1191. K-Concatenation Maximum Sumdate: 2020-10-28 20:35:39tags:categories: Leetcode 123456789101112131415161718192021222324class Solution(object): def kConcatenationMaxSum(self, arr, k): \"\"\" :type arr: List[int] :type k: int :rtype: int \"\"\" def maxSum(r): ans = s = 0 for i in range(r): for val in arr: s += val if s &lt; 0: s = 0 ans = max(s, ans) return ans if k &lt; 3: return maxSum(k) val1 = maxSum(1) val2 = maxSum(2) s = sum(arr) return max(val1, val2+(k-2)*s, val2)%(10**9 + 7)","categories":[],"tags":[]},{"title":"1140. Stone Game II","slug":"1140-Stone-Game-II","date":"2020-10-29T02:43:25.000Z","updated":"2020-10-29T02:54:47.834Z","comments":true,"path":"2020/10/28/1140-Stone-Game-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/1140-Stone-Game-II/","excerpt":"","text":"dfs(p, m):表示从前P位置拿石头，在m的前提下拿到的最大的值这个值是固定的所有可以memo 1234567891011121314151617181920212223242526272829class Solution(object): def stoneGameII(self, piles): \"\"\" :type piles: List[int] :rtype: int \"\"\" n = len(piles) presum = list(piles) presum[n-1] = piles[-1] for i in range(n-2, -1, -1): presum[i] += presum[i+1] memo = &#123;&#125; def dfs(p, m): if (p, m) in memo: return memo[(p, m)] if p + 2 * m &gt;= n: return presum[p] res = 0 for i in range(1, 2*m+1): take = presum[p] - presum[p+i] res = max(res, take + presum[p+i] - dfs(p+i, max(i,m))) memo[(p, m)] = res return res return dfs(0, 1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"792. Number of Matching Subsequences","slug":"792-Number-of-Matching-Subsequences","date":"2020-10-29T01:39:41.000Z","updated":"2020-10-29T01:48:48.985Z","comments":true,"path":"2020/10/28/792-Number-of-Matching-Subsequences/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/792-Number-of-Matching-Subsequences/","excerpt":"","text":"map: key词汇的首字母c， value是所有首字母为c的word 遍历\bS时来update c &amp; word pair in the map cornor case 每次遍历一个到c时一定要重置head[c] = []， 因为可能有重复连续的字符出现在一个word这样就会出错12345678910111213141516171819202122232425class Solution(object): def numMatchingSubseq(self, S, words): \"\"\" :type S: str :type words: List[str] :rtype: int \"\"\" head = defaultdict(list) for word in words: word = iter(word) head[next(word)].append(word) res = 0 for c in S: bucket = head[c] head[c] = [] while bucket: cur = bucket.pop() nxt = next(cur, None) if nxt: head[nxt].append(cur) else: res += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1219. Path with Maximum Gold","slug":"1219-Path-with-Maximum-Gold","date":"2020-10-28T22:27:47.000Z","updated":"2020-10-28T22:29:55.969Z","comments":true,"path":"2020/10/28/1219-Path-with-Maximum-Gold/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/1219-Path-with-Maximum-Gold/","excerpt":"","text":"结果是由递归结果组成 则先递归 最后计算并return 12345678910111213141516171819class Solution(object): def getMaximumGold(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" def findMaxGold(r, c): if 0 &lt;= r &lt; len(grid) and 0&lt;= c &lt; len(grid[0]) and grid[r][c] != 0: maxGold = 0 origin, grid[r][c] = grid[r][c], 0 for i, j in ((r+1, c), (r-1, c), (r, c+1), (r, c-1)): maxGold = max(findMaxGold(i, j), maxGold) grid[r][c] = origin return maxGold + origin else: return 0 return max(findMaxGold(i, j) for j in range(len(grid[0])) for i in range(len(grid)))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"886. Possible Bipartition","slug":"886-Possible-Bipartition","date":"2020-10-28T22:00:28.000Z","updated":"2020-10-28T22:01:59.330Z","comments":true,"path":"2020/10/28/886-Possible-Bipartition/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/886-Possible-Bipartition/","excerpt":"","text":"红蓝标记法 用dfs12345678910111213141516171819202122class Solution(object): def possibleBipartition(self, N, dislikes): \"\"\" :type N: int :type dislikes: List[List[int]] :rtype: bool \"\"\" graph = defaultdict(list) for u, v in dislikes: graph[u].append(v) graph[v].append(u) corlors = &#123;&#125; def dfs(node, corlor): if node in corlors: return corlors[node] == corlor corlors[node] = corlor return all(dfs(nei, corlor^1) for nei in graph[node]) return all(dfs(node, 0) for node in graph if node not in corlors)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"260. Single Number III","slug":"260-Single-Number-III","date":"2020-10-28T21:37:23.000Z","updated":"2020-10-28T21:39:16.725Z","comments":true,"path":"2020/10/28/260-Single-Number-III/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/260-Single-Number-III/","excerpt":"","text":"通过找到不一样的那个位数， 再进行一次异或 123456789101112131415161718class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" bitmask = 0 for num in nums: bitmask ^= num diff = bitmask&amp;-bitmask x = 0 for num in nums: if num &amp; diff: x ^= num return [x, bitmask^x]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"82. Remove Duplicates from Sorted List II","slug":"82-Remove-Duplicates-from-Sorted-List-II","date":"2020-10-28T19:54:00.000Z","updated":"2020-10-28T19:54:44.709Z","comments":true,"path":"2020/10/28/82-Remove-Duplicates-from-Sorted-List-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/82-Remove-Duplicates-from-Sorted-List-II/","excerpt":"","text":"123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" dummy = ListNode(float('inf')) dummy.next = head prev = dummy cur = dummy.next while cur: nxt = cur.next if nxt and nxt.val == cur.val: while nxt and nxt.val == cur.val: nxt = nxt.next prev.next = nxt else: prev = cur cur = nxt return dummy.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"comparator","slug":"comparator","date":"2020-10-28T17:15:33.000Z","updated":"2020-10-28T18:29:42.007Z","comments":true,"path":"2020/10/28/comparator/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/comparator/","excerpt":"","text":"Classes and Objects Objects are an encapsulation of variables and functions into a single entity. Objects get their variables and functions from classes. Classes are essentially a template to create your objects. class built in comparaobject.lt(self, other)object.le(self, other)object.eq(self, other)object.ne(self, other)object.gt(self, other)object.ge(self, other) 179. Largest Number","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"179. Largest Number","slug":"179-Largest-Number","date":"2020-10-28T17:03:01.000Z","updated":"2020-10-28T18:27:28.086Z","comments":true,"path":"2020/10/28/179-Largest-Number/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/179-Largest-Number/","excerpt":"","text":"cornor case: number is 0 123456789101112class LargetKey(str): def __lt__(x, y): return x + y &gt; y + x class Solution(object): def largestNumber(self, nums): \"\"\" :type nums: List[int] :rtype: str \"\"\" large_num = ''.join(sorted(map(str, nums), key=LargetKey)) return '0' if large_num[0] == '0' else large_num 1234567891011121314151617class Solution(object): def largestNumber(self, nums): \"\"\" :type nums: List[int] :rtype: str \"\"\" def cmp_func(x, y): if x + y &gt; y + x: return -1 elif x == y: return 0 else: return 1 large_num = ''.join(sorted(map(str, nums), key=cmp_to_key(cmp_func))) return '0' if large_num[0] == '0' else large_num 123456789class Solution(object): def largestNumber(self, nums): \"\"\" :type nums: List[int] :rtype: str \"\"\" large_num = ''.join(sorted(map(str, nums), key=cmp_to_key(lambda x, y: -1 if x + y &gt; y + x else 0 if x == y else 1))) return '0' if large_num[0] == '0' else large_num","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"935. Knight Dialer","slug":"935-Knight-Dialer","date":"2020-10-28T16:34:43.000Z","updated":"2020-10-28T16:48:31.781Z","comments":true,"path":"2020/10/28/935-Knight-Dialer/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/935-Knight-Dialer/","excerpt":"","text":"using dp method dp[i][j] 表示骑士第i次跳到数字j时组成的不同号码的个数 那么最终所求的就是将 dp[N-1][j] 累加起来 This way is reduce the memory 1234567891011121314151617class Solution(object): def knightDialer(self, n): \"\"\" :type n: int :rtype: int \"\"\" moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[], [1,7,0],[2,6],[1,3],[2,4]] dp = [1]*10 for i in range(n-1): dp2 = [0] * 10 for j in range(10): for nei in moves[j]: dp2[nei] += dp[j] dp = dp2 return sum(dp)%(10**9 + 7)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"165. Compare Version Numbers","slug":"165-Compare-Version-Numbers","date":"2020-10-28T16:16:37.000Z","updated":"2020-10-28T16:17:23.192Z","comments":true,"path":"2020/10/28/165-Compare-Version-Numbers/","link":"","permalink":"https://jojoyang666.github.io/2020/10/28/165-Compare-Version-Numbers/","excerpt":"","text":"12345678910111213141516171819class Solution(object): def compareVersion(self, version1, version2): \"\"\" :type version1: str :type version2: str :rtype: int \"\"\" versions1 = [int(version) for version in version1.split(\".\")] versions2 = [int(version) for version in version2.split(\".\")] for i in range(max(len(versions1), len(versions2))): i1 = versions1[i] if i &lt; len(versions1) else 0 i2 = versions2[i] if i &lt; len(versions2) else 0 if i1 != i2: return 1 if i1 &gt; i2 else -1 return 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1236. Web Crawler","slug":"1236-Web-Crawler","date":"2020-10-28T05:35:49.000Z","updated":"2020-10-28T05:48:01.738Z","comments":true,"path":"2020/10/27/1236-Web-Crawler/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/1236-Web-Crawler/","excerpt":"","text":"123456789101112131415161718192021222324252627282930# \"\"\"# This is HtmlParser's API interface.# You should not implement it, or speculate about its implementation# \"\"\"#class HtmlParser(object):# def getUrls(self, url):# \"\"\"# :type url: str# :rtype List[str]# \"\"\"class Solution(object): def crawl(self, startUrl, htmlParser): \"\"\" :type startUrl: str :type htmlParser: HtmlParser :rtype: List[str] \"\"\" domain = ''.join(re.findall('^(http:\\/\\/)([a-z0-9.\\-]+)', startUrl)[0]) visited = &#123;startUrl&#125; q = deque([startUrl]) while q: url = q.popleft() for nxt in htmlParser.getUrls(url): if nxt.startswith(domain) and nxt not in visited: q.append(nxt) visited.add(nxt) return list(visited) 注意不一定是.com结尾 (.*?) –&gt; ?表示：making the preceding quantifier lazy, casusing it to match as few chars as possible","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1011. Capacity To Ship Packages Within D Days","slug":"1011-Capacity-To-Ship-Packages-Within-D-Days","date":"2020-10-28T04:24:02.000Z","updated":"2020-10-28T04:24:27.752Z","comments":true,"path":"2020/10/27/1011-Capacity-To-Ship-Packages-Within-D-Days/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/1011-Capacity-To-Ship-Packages-Within-D-Days/","excerpt":"","text":"Binary Search 1234567891011121314151617181920212223242526class Solution(object): def shipWithinDays(self, weights, D): \"\"\" :type weights: List[int] :type D: int :rtype: int \"\"\" left, right = max(weights), sum(weights) while left &lt; right: mid = (right - left)/2 + left cur, d = 0, 1 for weight in weights: cur += weight if cur &gt; mid: cur = weight d += 1 if d &lt;= D: right = mid else: left = mid + 1 return right","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"542. 01 Matrix","slug":"542-01-Matrix","date":"2020-10-27T22:49:32.000Z","updated":"2020-10-28T02:51:43.716Z","comments":true,"path":"2020/10/27/542-01-Matrix/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/542-01-Matrix/","excerpt":"","text":"当前的值可能是上方， 左方（从左上角遍历）， 下方， 右方（从右下角）里面选取最小的值+1 —&gt; 所以要遍历两次 range(len(matrix)-1, -1, -1) 最后一个step -1不能少， 要不然不会遍历， 因为default是112345678910111213141516171819202122232425262728class Solution(object): def updateMatrix(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: List[List[int]] \"\"\" if not matrix or not matrix[0]: return [] dist = [[float('inf')]*len(matrix[0]) for row in range(len(matrix))] for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1: if i &gt; 0: dist[i][j] = min(dist[i][j], dist[i-1][j] + 1) if j &gt; 0: dist[i][j] = min(dist[i][j], dist[i][j-1] + 1) else: dist[i][j] = 0 for i in range(len(matrix)-1, -1, -1): for j in range(len(matrix[0])-1, -1, -1): if i &lt; len(matrix) - 1: dist[i][j] = min(dist[i][j], dist[i+1][j] + 1) if j &lt; len(matrix[i]) - 1: dist[i][j] = min(dist[i][j], dist[i][j+1] + 1) return dist","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1381. Design a Stack With Increment Operation","slug":"1381-Design-a-Stack-With-Increment-Operation","date":"2020-10-27T22:36:32.000Z","updated":"2020-10-27T22:36:50.786Z","comments":true,"path":"2020/10/27/1381-Design-a-Stack-With-Increment-Operation/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/1381-Design-a-Stack-With-Increment-Operation/","excerpt":"","text":"Lazy IncrementLazy is a wayinc[i] means for all elements stack[0] ~ stack[i],we should plus inc[i] when popped from the stack.Then inc[i-1]+=inc[i],so that we can accumulate the increment inc[i]for the bottom elements and the following pops. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class CustomStack(object): def __init__(self, maxSize): \"\"\" :type maxSize: int \"\"\" self.n = maxSize self.stack = [] self.inc = [] def push(self, x): \"\"\" :type x: int :rtype: None \"\"\" if len(self.inc) &lt; self.n: self.stack.append(x) self.inc.append(0) def pop(self): \"\"\" :rtype: int \"\"\" if not self.stack: return -1 if len(self.inc) &gt; 1: self.inc[-2] += self.inc[-1] return self.stack.pop() + self.inc.pop() def increment(self, k, val): \"\"\" :type k: int :type val: int :rtype: None \"\"\" if self.inc: self.inc[min(k, len(self.inc)) - 1] += val # Your CustomStack object will be instantiated and called as such:# obj = CustomStack(maxSize)# obj.push(x)# param_2 = obj.pop()# obj.increment(k,val)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1329. Sort the Matrix Diagonally","slug":"1329-Sort-the-Matrix-Diagonally","date":"2020-10-27T20:41:55.000Z","updated":"2020-10-27T20:42:19.093Z","comments":true,"path":"2020/10/27/1329-Sort-the-Matrix-Diagonally/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/1329-Sort-the-Matrix-Diagonally/","excerpt":"","text":"123456789101112131415161718192021class Solution(object): def diagonalSort(self, mat): \"\"\" :type mat: List[List[int]] :rtype: List[List[int]] \"\"\" n, m = len(mat), len(mat[0]) res = [] dic = collections.defaultdict(list) for i in range(n): for j in range(m): dic[i-j].append(mat[i][j]) for k in dic: dic[k].sort(reverse=1) for i in range(n): for j in range(m): mat[i][j] = dic[i-j].pop() return mat","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"General","slug":"General","date":"2020-10-27T20:34:11.000Z","updated":"2020-11-05T00:05:33.155Z","comments":true,"path":"2020/10/27/General/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/General/","excerpt":"","text":"同意对角线上的元素特点： i-j相同 对于str转化int/str表示数字的问题： corner case 考虑preceding is zero或者说这个数字本来就是0的情况（many 0 in preceding） Index as a hash key","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"366. Find Leaves of Binary Tree ","slug":"366-Find-Leaves-of-Binary-Tree","date":"2020-10-27T20:11:04.000Z","updated":"2020-10-27T20:26:44.375Z","comments":true,"path":"2020/10/27/366-Find-Leaves-of-Binary-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/366-Find-Leaves-of-Binary-Tree/","excerpt":"","text":"123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def findLeaves(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" dic = collections.defaultdict(list) def order(root): if not root: return 0 left = order(root.left) right = order(root.right) depth = max(left, right) + 1 dic[depth].append(root.val) return depth order(root) res = [value for k, value in dic.items()] return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"797. All Paths From Source to Target ","slug":"797-All-Paths-From-Source-to-Target","date":"2020-10-27T19:48:30.000Z","updated":"2020-10-27T19:49:06.112Z","comments":true,"path":"2020/10/27/797-All-Paths-From-Source-to-Target/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/797-All-Paths-From-Source-to-Target/","excerpt":"","text":"1234567891011121314151617181920212223class Solution(object): def allPathsSourceTarget(self, graph): \"\"\" :type graph: List[List[int]] :rtype: List[List[int]] \"\"\" target = len(graph)-1 res = [] def backtrack(path, node): if node == target: res.append(list(path)) return for nei in graph[node]: path.append(nei) backtrack(path, nei) path.pop() path = [0] backtrack(path, 0) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"373. Find K Pairs with Smallest Sums","slug":"373-Find-K-Pairs-with-Smallest-Sums","date":"2020-10-27T18:16:16.000Z","updated":"2020-10-27T18:39:17.176Z","comments":true,"path":"2020/10/27/373-Find-K-Pairs-with-Smallest-Sums/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/373-Find-K-Pairs-with-Smallest-Sums/","excerpt":"","text":"1234567891011121314151617181920212223class Solution(object): def kSmallestPairs(self, nums1, nums2, k): \"\"\" :type nums1: List[int] :type nums2: List[int] :type k: int :rtype: List[List[int]] \"\"\" queue = [] res = [] def push(i, j): if i &lt; len(nums1) and j &lt; len(nums2): heapq.heappush(queue, (nums1[i] + nums2[j], i, j)) push(0, 0) while queue and len(res) &lt; k: _, i, j = heapq.heappop(queue) push(i, j+1) res.append((nums1[i], nums2[j])) if j == 0: push(i+1, j) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1353. Maximum Number of Events That Can Be Attended ","slug":"1353-Maximum-Number-of-Events-That-Can-Be-Attended","date":"2020-10-27T16:10:27.000Z","updated":"2020-10-27T18:08:33.744Z","comments":true,"path":"2020/10/27/1353-Maximum-Number-of-Events-That-Can-Be-Attended/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/1353-Maximum-Number-of-Events-That-Can-Be-Attended/","excerpt":"","text":"123456789101112131415161718192021222324class Solution(object): def maxEvents(self, events): \"\"\" :type events: List[List[int]] :rtype: int \"\"\" events.sort(reverse=1) h = [] res = d = 0 while events or h: if not h: d = events[-1][0] while events and events[-1][0] &lt;= d: heapq.heappush(h, events.pop()[1]) heapq.heappop(h) res += 1 d += 1 while h and h[0] &lt; d: heapq.heappop(h) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"813. Largest Sum of Averages","slug":"813-Largest-Sum-of-Averages","date":"2020-10-27T14:08:14.000Z","updated":"2020-10-27T15:01:23.790Z","comments":true,"path":"2020/10/27/813-Largest-Sum-of-Averages/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/813-Largest-Sum-of-Averages/","excerpt":"","text":"dp[i][k]表示范围是[i, n-1]的子数组分成k组的最大得分 [i, n-1]范围内的子数组分成k组，那么suppose我们已经知道了任意范围内分成k-1组的最大分数 要求状态k，一定要先求出所有的状态k-1 在范围[i, n-1]多分出一组，实际上就是将其分成两部分 一部分是一组，另一部分是k-1组 就用一个变量j，遍历范围(i, n-1)中的每一个位置 第一部分[i, j)，由于是一组，那么直接求出平均值即可 另一部分由于是k-1组，由于我们已经知道了所有k-1的情况，可以直接从cache中读出来dp[j][k-1] 者相加即可 avg(i, j) + dp[j][k-1]，所以我们可以得出状态转移方程如下： dp[i][k] = max(avg(i, n) + max_{j &gt; i} (avg(i, j) + dp[j][k-1])) 123456789101112131415161718192021class Solution(object): def largestSumOfAverages(self, A, K): \"\"\" :type A: List[int] :type K: int :rtype: float \"\"\" s = [0] for x in A: s.append(s[-1] + x) n = len(A) dp = [[(s[n] - s[i])/float(n-i) if j == 0 else 0 for j in range(K)]for i in range(n)] for k in range(1, K): for i in range(0, n-1): for j in range(i+1, n): dp[i][k] = max(dp[j][k-1] + (s[j] - s[i])/float(j-i), dp[i][k]) return dp[0][-1] Reduce the space123456789101112131415161718192021class Solution(object): def largestSumOfAverages(self, A, K): \"\"\" :type A: List[int] :type K: int :rtype: float \"\"\" s = [0] for x in A: s.append(s[-1] + x) n = len(A) dp = [(s[n] - s[i])/float(n-i) for i in range(n)] for k in range(1, K): for i in range(0, n-1): for j in range(i+1, n): dp[i] = max( dp[j] + (s[j] - s[i])/float(j-i), dp[i]) return dp[0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"959. Regions Cut By Slashes","slug":"959-Regions-Cut-By-Slashes","date":"2020-10-27T13:13:30.000Z","updated":"2020-10-27T13:16:04.895Z","comments":true,"path":"2020/10/27/959-Regions-Cut-By-Slashes/","link":"","permalink":"https://jojoyang666.github.io/2020/10/27/959-Regions-Cut-By-Slashes/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): def regionsBySlashes(self, grid): \"\"\" :type grid: List[str] :rtype: int \"\"\" N = len(grid) dsu = DSU(N * N * 4) for r, row in enumerate(grid): for c, val in enumerate(row): idx = 4 * (r * N + c) if val == ' ': dsu.union(idx + 0, idx + 1) dsu.union(idx + 2, idx + 1) dsu.union(idx + 2, idx + 3) if val == '/': dsu.union(idx + 0, idx + 3) dsu.union(idx + 2, idx + 1) if val == '\\\\': dsu.union(idx + 0, idx + 1) dsu.union(idx + 2, idx + 3) if c &lt; N - 1: dsu.union(idx + 1, idx + 4 + 3) if r &lt; N - 1: dsu.union(idx + 2, idx + 4 * N + 0) return sum(dsu.find(x) == x for x in range(4 * N * N)) class DSU: def __init__(self, n): self.parent = range(n) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): px = self.find(x) py = self.find(y) self.parent[px] = py","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"116. Populating Next Right Pointers in Each Node","slug":"116-Populating-Next-Right-Pointers-in-Each-Node","date":"2020-10-27T04:57:21.000Z","updated":"2020-10-27T05:12:09.939Z","comments":true,"path":"2020/10/26/116-Populating-Next-Right-Pointers-in-Each-Node/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/116-Populating-Next-Right-Pointers-in-Each-Node/","excerpt":"","text":"BFS1234567891011121314151617181920212223242526272829303132333435\"\"\"# Definition for a Node.class Node(object): def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next\"\"\"class Solution(object): def connect(self, root): \"\"\" :type root: Node :rtype: Node \"\"\" if not root: return root Q = collections.deque([root]) while Q: size = len(Q) for i in range(size): node = Q.popleft() if i &lt; size - 1: node.next = Q[0] if node.left: Q.append(node.left) if node.right: Q.append(node.right) return root Follow UP constant space can use recursive way, can treat it as contant 明白有几种connection for next, to each connection how should we connect it –&gt; 注意： 这是perfect binary tree 所以如果node没有left node 那么就说明是最后一层12345678910111213141516171819202122232425262728293031323334\"\"\"# Definition for a Node.class Node(object): def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next\"\"\"class Solution(object): def connect(self, root): \"\"\" :type root: Node :rtype: Node \"\"\" if not root: return root leftmost = root while leftmost.left: head = leftmost while head: # type of connection 1 head.left.next = head.right # type of connection 2 if head.next: head.right.next = head.next.left head = head.next leftmost = leftmost.left return root","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1254. Number of Closed Islands","slug":"1254-Number-of-Closed-Islands","date":"2020-10-27T04:46:56.000Z","updated":"2020-10-27T04:50:38.579Z","comments":true,"path":"2020/10/26/1254-Number-of-Closed-Islands/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/1254-Number-of-Closed-Islands/","excerpt":"","text":"本质上就是找到连续的island 然后排除从边界开始的island 123456789101112131415161718192021222324252627282930class Solution(object): def closedIsland(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(i, j, val): if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and grid[i][j] == 0: grid[i][j] = val dfs(i+1, j, val) dfs(i, j+1, val) dfs(i-1, j, val) dfs(i, j-1, val) for i in xrange(m): for j in xrange(n): if (i == 0 or i == m-1 or j == 0 or j == n-1) and grid[i][j] == 0: dfs(i, j, 1) res = 0 for i in xrange(m): for j in xrange(n): if grid[i][j] == 0: dfs(i, j, 1) res += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1155. Number of Dice Rolls With Target Sum","slug":"1155-Number-of-Dice-Rolls-With-Target-Sum","date":"2020-10-27T04:20:22.000Z","updated":"2020-10-27T04:47:15.931Z","comments":true,"path":"2020/10/26/1155-Number-of-Dice-Rolls-With-Target-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/1155-Number-of-Dice-Rolls-With-Target-Sum/","excerpt":"","text":"DFS + MemoThe general relation is:dp(d, f, target) = dp(d-1, f, target-1) + dp(d-1, f, target-2) + … + dp(d-1, f, target-f) The base case occurs when d = 0. We can make target=0 with 0 dice, but nothing else.So dp(0, f, t) = 0 iff t != 0, and dp(0, f, 0) = 1. 123456789101112131415161718192021222324class Solution(object): def numRollsToTarget(self, d, f, target): \"\"\" :type d: int :type f: int :type target: int :rtype: int \"\"\" memo = &#123;&#125; def dp(d, target): if d == 0: return 0 if target &gt; 0 else 1 if (d, target) in memo: return memo[(d, target)] to_return = 0 for k in range(max(0, target - f), target): to_return += dp(d-1, k) memo[(d, target)] = to_return return to_return return dp(d, target)%(10**9 + 7)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"229. Majority Element II","slug":"229-Majority-Element-II","date":"2020-10-27T03:39:28.000Z","updated":"2020-10-27T03:39:51.406Z","comments":true,"path":"2020/10/26/229-Majority-Element-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/229-Majority-Element-II/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031class Solution(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" if not nums: return [] count1, count2, candidate1, candidate2 = 0, 0, None, None for n in nums: if candidate1 == n: count1 += 1 elif candidate2 == n: count2 += 1 elif count1 == 0: count1 += 1 candidate1 = n elif count2 == 0: count2 += 1 candidate2 = n else: count1 -= 1 count2 -= 1 result = [] for c in [candidate1, candidate2]: if nums.count(c) &gt; len(nums)/3: result.append(c) return result","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Boyer-Moore算法","slug":"Boyer-Moore算法","date":"2020-10-27T03:30:23.000Z","updated":"2020-10-27T03:37:11.478Z","comments":true,"path":"2020/10/26/Boyer-Moore算法/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/Boyer-Moore%E7%AE%97%E6%B3%95/","excerpt":"","text":"基本思想：比较直观的解释：在数组中找到两个不相同的元素并删除它们，不断重复此过程，直到数组中元素都相同，那么剩下的元素就是主要元素。 先随意确定一个候选元素，count是候选元素的计数，当遇到一个跟候选元素不同的元素时，两者数量上抵消一个，count减1。一旦count变成0，就重新找一个候选元素。当遇到一个与候选元素不同的元素时，就要抵消。对于候选元素和当前元素，可能存在两种情况： 1）两者中有一个正好是主要元素； 2）两者都不是主要元素。对于情况1)，抵消过后，主要元素还是主要元素；对于情况2），可以说主要的元素的地位得到了巩固。所以算法最终能找到主要元素。 作者：曾会玩链接：https://www.jianshu.com/p/dfd676b71ef0来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1277. Count Square Submatrices with All Ones","slug":"1277-Count-Square-Submatrices-with-All-Ones","date":"2020-10-27T03:05:36.000Z","updated":"2020-10-27T03:14:18.912Z","comments":true,"path":"2020/10/26/1277-Count-Square-Submatrices-with-All-Ones/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/1277-Count-Square-Submatrices-with-All-Ones/","excerpt":"","text":"123456789101112class Solution(object): def countSquares(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: int \"\"\" for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): matrix[i][j] *= min(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1]) + 1 # return sum([sum(matrix[i]) for i in range(len(matrix))]) return sum(map(sum, matrix))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"752. Open the Lock","slug":"752-Open-the-Lock","date":"2020-10-26T23:54:49.000Z","updated":"2020-10-26T23:55:13.395Z","comments":true,"path":"2020/10/26/752-Open-the-Lock/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/752-Open-the-Lock/","excerpt":"","text":"1234567891011121314151617181920212223242526272829class Solution(object): def openLock(self, deadends, target): \"\"\" :type deadends: List[str] :type target: str :rtype: int \"\"\" def neighbors(node): for i in xrange(4): x = int(node[i]) for d in (-1, 1): y = (x + d)%10 yield node[:i] + str(y) + node[i+1:] dead = set(deadends) queue = collections.deque([('0000', 0)]) seen = &#123;'0000'&#125; while queue: node, depth = queue.popleft() if node == target: return depth if node in dead: continue for nei in neighbors(node): if nei not in seen: seen.add(nei) queue.append((nei, depth + 1)) return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"134. Gas Station","slug":"134-Gas-Station","date":"2020-10-26T22:12:28.000Z","updated":"2020-10-26T22:15:21.360Z","comments":true,"path":"2020/10/26/134-Gas-Station/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/134-Gas-Station/","excerpt":"","text":"实际上是用greedy的方法 一旦不满足就更新cur_index 最终的判定就是你的汽油是否能支持你走完全程 123456789101112131415161718192021class Solution(object): def canCompleteCircuit(self, gas, cost): \"\"\" :type gas: List[int] :type cost: List[int] :rtype: int \"\"\" n = len(gas) total_tank, curr_tank = 0, 0 starting_position = 0 for i in range(n): total_tank += gas[i] - cost[i] curr_tank += gas[i] - cost[i] if curr_tank &lt; 0: starting_position = i + 1 curr_tank = 0 return starting_position if total_tank &gt;= 0 else -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"365. Water and Jug Problem","slug":"365-Water-and-Jug-Problem","date":"2020-10-26T21:25:17.000Z","updated":"2020-10-26T21:30:20.797Z","comments":true,"path":"2020/10/26/365-Water-and-Jug-Problem/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/365-Water-and-Jug-Problem/","excerpt":"","text":"可以用一个公式来表达： z = m * x + n * y m，n为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水 问题就变成了对于任意给定的x,y,z，存不存在m和n使得上面的等式成立 裴蜀定理，ax + by = d的解为 d = gcd(x, y) 只要z % d == 0，上面的等式就有解 裴蜀定理:ax+by=m有整数解时当且仅当m是a及b的最大公约数d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x、y都稱為裴蜀數 1234567891011class Solution(object): def canMeasureWater(self, x, y, z): \"\"\" :type x: int :type y: int :type z: int :rtype: bool \"\"\" return z == 0 or (x + y &gt;= z and z%self.gcd(x, y) == 0) def gcd(self, x, y): return x if y == 0 else self.gcd(y, x%y)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1091. Shortest Path in Binary Matrix ","slug":"1091-Shortest-Path-in-Binary-Matrix","date":"2020-10-26T19:47:13.000Z","updated":"2020-10-26T19:47:34.075Z","comments":true,"path":"2020/10/26/1091-Shortest-Path-in-Binary-Matrix/","link":"","permalink":"https://jojoyang666.github.io/2020/10/26/1091-Shortest-Path-in-Binary-Matrix/","excerpt":"","text":"12345678910111213141516171819class Solution(object): def shortestPathBinaryMatrix(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" n = len(grid) if grid[0][0] or grid[n-1][n-1]: return -1 q = [(0, 0, 1)] for i, j, d in q: if i == n-1 and j == n-1: return d for x, y in ((i-1, j-1), (i+1, j+1), (i-1, j+1), (i+1, j-1), (i-1, j), (i+1, j), (i, j+1), (i, j-1)): if 0&lt;= x &lt; n and 0&lt;= y &lt; n and not grid[x][y]: grid[x][y] = 1 q.append((x, y, d+1)) return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"189. Rotate Array","slug":"189-Rotate-Array","date":"2020-10-25T22:38:54.000Z","updated":"2020-10-25T22:41:07.855Z","comments":true,"path":"2020/10/25/189-Rotate-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/10/25/189-Rotate-Array/","excerpt":"","text":"123456789101112131415161718192021class Solution(object): def rotate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: None Do not return anything, modify nums in-place instead. \"\"\" n = len(nums) k %= n self.reverse(nums, 0, n-1) self.reverse(nums, 0, k-1) self.reverse(nums, k, n-1) def reverse(self, nums, start, end): while start &lt; end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"592. Fraction Addition and Subtraction","slug":"592-Fraction-Addition-and-Subtraction","date":"2020-10-25T21:15:44.000Z","updated":"2020-10-25T21:18:12.929Z","comments":true,"path":"2020/10/25/592-Fraction-Addition-and-Subtraction/","link":"","permalink":"https://jojoyang666.github.io/2020/10/25/592-Fraction-Addition-and-Subtraction/","excerpt":"","text":"用regular expression 来提取 分子 分母 然后用数学来进行分数运算 前面加上一个dummy 分数： 0/1 结果 用/gcd123456789101112131415161718192021222324class Solution(object): def fractionAddition(self, expression): \"\"\" :type expression: str :rtype: str \"\"\" ints = map(int, re.findall('[+-]?\\d+', expression)) A, B = 0, 1 #A分母 B分子 for i in range(0, len(ints), 2): a, b = ints[i], ints[i+1] A = A * b + a * B B = B * b gcd = self.gcd(A, B) A /= gcd B /= gcd return '%d/%d' % (A,B) return \"\" def gcd(self, A, B): return A if B == 0 else self.gcd(B, A%B)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"545. Boundary of Binary Tree","slug":"545-Boundary-of-Binary-Tree","date":"2020-10-25T19:50:40.000Z","updated":"2020-10-27T22:38:39.462Z","comments":true,"path":"2020/10/25/545-Boundary-of-Binary-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/10/25/545-Boundary-of-Binary-Tree/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def boundaryOfBinaryTree(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res = [] if not root: return res def preorder(node, leftbd, rightbd): if not node: return if not node.left and not node.right: res.append(node.val) return if leftbd: res.append(node.val) preorder(node.left, leftbd and node.left, rightbd and not node.right) preorder(node.right, leftbd and not node.left, rightbd and node.right) if rightbd: res.append(node.val) res.append(root.val) preorder(root.left, True, False) preorder(root.right, False, True) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1328. Break a Palindrome","slug":"1328-Break-a-Palindrome","date":"2020-10-25T19:35:58.000Z","updated":"2020-10-25T19:37:17.440Z","comments":true,"path":"2020/10/25/1328-Break-a-Palindrome/","link":"","permalink":"https://jojoyang666.github.io/2020/10/25/1328-Break-a-Palindrome/","excerpt":"","text":"1234567891011class Solution(object): def breakPalindrome(self, palindrome): \"\"\" :type palindrome: str :rtype: str \"\"\" for i in range(len(palindrome)/2): if palindrome[i] != 'a': return palindrome[:i] + 'a' + palindrome[i+1:] # cornor case: 整个string都是a return palindrome[:-1] + 'b' if palindrome[:-1] else ''","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"688. Knight Probability in Chessboard","slug":"688-Knight-Probability-in-Chessboard","date":"2020-10-25T19:20:31.000Z","updated":"2020-10-25T19:25:30.315Z","comments":true,"path":"2020/10/25/688-Knight-Probability-in-Chessboard/","link":"","permalink":"https://jojoyang666.github.io/2020/10/25/688-Knight-Probability-in-Chessboard/","excerpt":"","text":"DP solution:1234567891011121314151617181920212223class Solution(object): def knightProbability(self, N, K, r, c): \"\"\" :type N: int :type K: int :type r: int :type c: int :rtype: float \"\"\" dp = [[0] * N for _ in range(N)] dp[r][c] = 1 for _ in xrange(K): dp2 = [[0] * N for _ in xrange(N)] for r, row in enumerate(dp): for c, val in enumerate(row): for dr,dc in ((2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)): if 0 &lt;= r + dr &lt; N and 0 &lt;= c + dc &lt; N: dp2[r+dr][c+dc] += val/8.0 dp = dp2 return sum(map(sum, dp))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1424. Diagonal Traverse II","slug":"1424-Diagonal-Traverse-II","date":"2020-10-25T06:40:45.000Z","updated":"2020-10-25T06:44:44.647Z","comments":true,"path":"2020/10/24/1424-Diagonal-Traverse-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/24/1424-Diagonal-Traverse-II/","excerpt":"","text":"同一对角线上面的元素： 横坐标和纵坐标之和 相同 不同的对角线上 不同的和不同 但是因为坐标遍历的方向， 我们要reverse 来得到结果1234567891011121314151617class Solution(object): def findDiagonalOrder(self, nums): \"\"\" :type nums: List[List[int]] :rtype: List[int] \"\"\" res = [] for i, row in enumerate(nums): for j, col in enumerate(row): if len(res) &lt;= i + j: res.append([]) res[i + j].append(col) return [a for r in res for a in reversed(r)]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1167. Minimum Cost to Connect Sticks","slug":"1167-Minimum-Cost-to-Connect-Sticks","date":"2020-10-25T06:21:14.000Z","updated":"2020-10-25T06:21:40.374Z","comments":true,"path":"2020/10/24/1167-Minimum-Cost-to-Connect-Sticks/","link":"","permalink":"https://jojoyang666.github.io/2020/10/24/1167-Minimum-Cost-to-Connect-Sticks/","excerpt":"","text":"1234567891011121314class Solution(object): def connectSticks(self, sticks): \"\"\" :type sticks: List[int] :rtype: int \"\"\" heapq.heapify(sticks) res = 0 while len(sticks) &gt; 1: x, y = heapq.heappop(sticks), heapq.heappop(sticks) res += x + y heapq.heappush(sticks, x + y) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"40. Combination Sum II","slug":"40-Combination-Sum-II","date":"2020-10-25T06:02:10.000Z","updated":"2020-10-25T06:12:30.616Z","comments":true,"path":"2020/10/24/40-Combination-Sum-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/24/40-Combination-Sum-II/","excerpt":"","text":"sort是因为提高效率 重复出现的数字要continue 避免重复的结果123456789101112131415161718192021222324class Solution(object): def combinationSum2(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\" candidates.sort() res = [] self.combinationSum2Hlper(candidates, 0, target, [], res) return res def combinationSum2Hlper(self, candidates, start, target, path, res): if not target: res.append(path) return for i in xrange(start, len(candidates)): if i &gt; start and candidates[i] == candidates[i-1]: continue if candidates[i] &gt; target: break self.combinationSum2Hlper(candidates, i + 1, target - candidates[i], path + [candidates[i]], res)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"525. Contiguous Array","slug":"525-Contiguous-Array","date":"2020-10-25T05:30:15.000Z","updated":"2020-10-25T05:45:30.452Z","comments":true,"path":"2020/10/24/525-Contiguous-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/10/24/525-Contiguous-Array/","excerpt":"","text":"用了prefix sum的思想 有重复值出现 就说明了中间的部分满足条件 123456789101112131415161718class Solution(object): def findMaxLength(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" cnt = res = 0 dic = &#123;0:-1&#125; for i, num in enumerate(nums): cnt += 1 if num else -1 if cnt in dic: res = max(res, i - dic[cnt]) else: dic[cnt] = i return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"738. Monotone Increasing Digits","slug":"738-Monotone-Increasing-Digits","date":"2020-10-25T04:23:26.000Z","updated":"2020-10-25T04:47:54.363Z","comments":true,"path":"2020/10/24/738-Monotone-Increasing-Digits/","link":"","permalink":"https://jojoyang666.github.io/2020/10/24/738-Monotone-Increasing-Digits/","excerpt":"","text":"例子是 332，最后一位2小于之前的3，那么此时将前面位减1，先变成322，再往前看，还是小于前面的3，那么再将前面位减1，就变成了 222，此时 222 不是最大的单调递增数，可以将后面两位变成9，于是乎就有了 299， 1234567891011121314151617class Solution(object): def monotoneIncreasingDigits(self, N): \"\"\" :type N: int :rtype: int \"\"\" S = list(str(N)) j = len(S) for i in range(len(S)-1, 0, -1): if S[i] &lt; S[i-1]: S[i-1] = str(int(S[i-1]) - 1) j = i S[j:] = '9' * (len(S) - j) return int(\"\".join(S))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"979. Distribute Coins in Binary Tree","slug":"979-Distribute-Coins-in-Binary-Tree","date":"2020-10-25T03:25:43.000Z","updated":"2020-10-25T03:47:27.923Z","comments":true,"path":"2020/10/24/979-Distribute-Coins-in-Binary-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/10/24/979-Distribute-Coins-in-Binary-Tree/","excerpt":"","text":"每一个node 有一个val表示已此node为根节点的子树还需要多少coin 正数表示 有多余的， 可以像上运输 负数表示需要， 需要父节点像下运输 最终结果就是+上这些绝对值12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def distributeCoins(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" self.ans = 0 def dfs(node): if not node: return 0 L, R = dfs(node.left), dfs(node.right) self.ans += abs(L) + abs(R) return node.val + L + R -1 dfs(root) return self.ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1008. Construct Binary Search Tree from Preorder Traversal","slug":"1008-Construct-Binary-Search-Tree-from-Preorder-Traversal","date":"2020-10-24T04:05:50.000Z","updated":"2020-10-24T04:38:41.230Z","comments":true,"path":"2020/10/23/1008-Construct-Binary-Search-Tree-from-Preorder-Traversal/","link":"","permalink":"https://jojoyang666.github.io/2020/10/23/1008-Construct-Binary-Search-Tree-from-Preorder-Traversal/","excerpt":"","text":"O(n * n) 1234567891011121314151617181920 # Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def bstFromPreorder(self, preorder): \"\"\" :type preorder: List[int] :rtype: TreeNode \"\"\" if not preorder: return None root = TreeNode(preorder[0]) i = bisect.bisect(preorder, preorder[0]) root.left = self.bstFromPreorder(preorder[1:i]) root.right = self.bstFromPreorder(preorder[i:]) return root O(n) Recursive 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def bstFromPreorder(self, preorder): \"\"\" :type preorder: List[int] :rtype: TreeNode \"\"\" return self.buildTree(preorder[::-1], float('inf')) def buildTree(self, preorder, bound): if not preorder or preorder[-1] &gt; bound: return None node = TreeNode(preorder.pop()) node.left = self.buildTree(preorder, node.val) node.right = self.buildTree(preorder, bound) return node Stack 在stack里面的node都是有parent的，又因为是inorder所以 如果值比parent小的话 一定是左节点（也就是再满足的情况下里面的node一定是有左节点的） 因此， 找到第一个大于child的node 1234567891011121314151617181920212223242526272829303132 # Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def bstFromPreorder(self, preorder): \"\"\" :type preorder: List[int] :rtype: TreeNode \"\"\" n = len(preorder) if not n: return None root = TreeNode(preorder[0]) stack = [root] for i in range(1, n): node, child = stack[-1], TreeNode(preorder[i]) while stack and stack[-1].val &lt; child.val: node = stack.pop() if node.val &lt; child.val: node.right = child else: node.left = child stack.append(child) return root","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1395. Count Number of Teams","slug":"1395-Count-Number-of-Teams","date":"2020-10-24T03:23:32.000Z","updated":"2020-10-24T03:30:15.075Z","comments":true,"path":"2020/10/23/1395-Count-Number-of-Teams/","link":"","permalink":"https://jojoyang666.github.io/2020/10/23/1395-Count-Number-of-Teams/","excerpt":"","text":"count how many soldiers on the left and right have less and greater ratings. This soldier can form less[left] * greater[right] + greater[left] * less[right] teams. 12345678910111213141516171819class Solution(object): def numTeams(self, rating): \"\"\" :type rating: List[int] :rtype: int \"\"\" res = 0 for i in range(1, len(rating) - 1): less, greater = [0, 0], [0, 0] for j in range(len(rating)): if rating[i] &lt; rating[j]: greater[j &gt; i] += 1 if rating[i] &gt; rating[j]: less[j &gt; i] += 1 res += less[0] * greater[1] + greater[0] * less[1] return res 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; rating * @return &#123;number&#125; */var numTeams = function(rating) &#123; let res = 0 for (let i = 1; i &lt; rating.length - 1; i++) &#123; const less = [0, 0], greater = [0, 0] for (let j = 0; j &lt; rating.length; j++) &#123; if (rating[i] &lt; rating[j]) &#123; greater[j &gt; i ? 1 : 0]++ &#125; if (rating[i] &gt; rating[j]) &#123; less[j &gt; i ? 1 : 0]++ &#125; &#125; res += greater[0] * less[1] + greater[1] * less[0] &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1244. Design A Leaderboard","slug":"1244-Design-A-Leaderboard","date":"2020-10-24T03:23:02.000Z","updated":"2020-10-27T15:24:32.175Z","comments":true,"path":"2020/10/23/1244-Design-A-Leaderboard/","link":"","permalink":"https://jojoyang666.github.io/2020/10/23/1244-Design-A-Leaderboard/","excerpt":"","text":"巧用counter 12345678910111213141516171819202122232425262728293031323334class Leaderboard(object): def __init__(self): self.A = collections.Counter() def addScore(self, playerId, score): \"\"\" :type playerId: int :type score: int :rtype: None \"\"\" self.A[playerId] += score def top(self, K): \"\"\" :type K: int :rtype: int \"\"\" return sum(v for i, v in self.A.most_common(K)) def reset(self, playerId): \"\"\" :type playerId: int :rtype: None \"\"\" self.A[playerId] = 0# Your Leaderboard object will be instantiated and called as such:# obj = Leaderboard()# obj.addScore(playerId,score)# param_2 = obj.top(K)# obj.reset(playerId)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"338. Counting Bits","slug":"338-Counting-Bits","date":"2020-10-23T23:25:04.000Z","updated":"2020-10-24T00:14:34.544Z","comments":true,"path":"2020/10/23/338-Counting-Bits/","link":"","permalink":"https://jojoyang666.github.io/2020/10/23/338-Counting-Bits/","excerpt":"","text":"分为奇数， 偶数 12345678910111213class Solution(object): def countBits(self, num): \"\"\" :type num: int :rtype: List[int] \"\"\" ans = [0] * (num+ 1) ans[0] = 0 for i in range(num + 1): ans[i] = ans[i&gt;&gt;1] + (i&amp;1) return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"516. Longest Palindromic Subsequence","slug":"516-Longest-Palindromic-Subsequence","date":"2020-10-23T21:51:33.000Z","updated":"2020-10-23T23:25:11.799Z","comments":true,"path":"2020/10/23/516-Longest-Palindromic-Subsequence/","link":"","permalink":"https://jojoyang666.github.io/2020/10/23/516-Longest-Palindromic-Subsequence/","excerpt":"","text":"DP重点： 这是DP的表达式， dp的表达式不是i-1, j-1dp[i][j] = dp[i+1][j-1] + 2time: O(n) space: O(n) 123456789101112131415161718class Solution(object): def longestPalindromeSubseq(self, s): \"\"\" :type s: str :rtype: int \"\"\" n = len(s) dp = [[0] * n for i in range(n)] for i in reversed(range(n)): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"421. Maximum XOR of Two Numbers in an Array","slug":"421-Maximum-XOR-of-Two-Numbers-in-an-Array","date":"2020-10-23T18:42:44.000Z","updated":"2020-10-23T20:43:22.161Z","comments":true,"path":"2020/10/23/421-Maximum-XOR-of-Two-Numbers-in-an-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/10/23/421-Maximum-XOR-of-Two-Numbers-in-an-Array/","excerpt":"","text":"这个题目的思路的大前提是: a ^ b = c &lt;===&gt; a ^ c = b 讲解.123456789101112131415class Solution(object): def findMaximumXOR(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" max_xor = 0 for i in range(31, -1, -1): max_xor &lt;&lt;= 1 cur_xor = max_xor | 1 prefixes = &#123;num &gt;&gt; i for num in nums&#125; max_xor |= any(cur_xor ^p in prefixes for p in prefixes) return max_xor","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Three-way Partitioning","slug":"Three-way-Partitioning","date":"2020-10-23T03:51:22.000Z","updated":"2020-10-23T04:39:33.067Z","comments":true,"path":"2020/10/22/Three-way-Partitioning/","link":"","permalink":"https://jojoyang666.github.io/2020/10/22/Three-way-Partitioning/","excerpt":"","text":"i, j, k –&gt; i &lt;= j &lt;= k Entries from 0 up to (but not including) i are values less than mid –&gt; [0, i) &lt; mid Entries from i up to (but not including) j are values equal to mid –&gt; 【i, j) == mid Entries from j up to (but not inclusing) k are values not yest sorted, and –&gt; [j, k) values not sorted Entries from k to the end of the array are values greater than mid –&gt; [k, end of array] &gt; mid procedure three-way-partition(A : array of values, mid : value): i ← 0 j ← 0 k ← size of A while j &lt; k: if A[j] &lt; mid: swap A[i] and A[j] i ← i + 1 j ← j + 1 else if A[j] &gt; mid: k ← k - 1 swap A[j] and A[k] else: j ← j + 1","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"215. Kth Largest Element in an Array","slug":"215-Kth-Largest-Element-in-an-Array","date":"2020-10-22T20:00:03.000Z","updated":"2020-10-22T20:44:11.960Z","comments":true,"path":"2020/10/22/215-Kth-Largest-Element-in-an-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/10/22/215-Kth-Largest-Element-in-an-Array/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var findKthLargest = function(nums, k) &#123; let left = 0, right = nums.length - 1; while (left &lt;= right) &#123; let pos = partition(nums, left, right); if (pos === k - 1) &#123; return nums[pos] &#125; if (pos &lt; k - 1) &#123; left = pos + 1 &#125; else &#123; right = pos - 1 &#125; &#125;&#125;;const partition = (nums, left, right) =&gt; &#123; let pivot = nums[left], l = left + 1, r = right; while (l &lt;= r) &#123; if (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) &#123; swap(nums, l++, r--); &#125; if (nums[l] &gt;= pivot) &#123; l++; &#125; if (nums[r] &lt;= pivot) &#123; r-- &#125; &#125; swap(nums, left, r); return r;&#125;const swap = (nums, left, right) =&gt; &#123; let tmp = nums[left] nums[left] = nums[right] nums[right] = tmp&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution: def findKthLargest(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" def partition(left, right, pivot_index): pivot = nums[pivot_index] # 1. move pivot to end nums[pivot_index], nums[right] = nums[right], nums[pivot_index] # 2. move all smaller elements to the left store_index = left for i in range(left, right): if nums[i] &lt; pivot: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 # 3. move pivot to its final place nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def select(left, right, k_smallest): \"\"\" Returns the k-th smallest element of list within left..right \"\"\" if left == right: # If the list contains only one element, return nums[left] # return that element # select a random pivot_index between pivot_index = random.randint(left, right) # find the pivot position in a sorted list pivot_index = partition(left, right, pivot_index) # the pivot is in its final sorted position if k_smallest == pivot_index: return nums[k_smallest] # go left elif k_smallest &lt; pivot_index: return select(left, pivot_index - 1, k_smallest) # go right else: return select(pivot_index + 1, right, k_smallest) # kth largest is (n - k)th smallest return select(0, len(nums) - 1, len(nums) - k) 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def findKthLargest(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" def partition(left, right, pivot_index): pivot = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] &gt; pivot: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def select(left, right, K): if left == right: return nums[left] # print left, right pivot_index = random.randint(left, right) pivot_index = partition(left, right, pivot_index) if K == (pivot_index + 1): return nums[pivot_index] elif K &lt;= pivot_index: return select(left, pivot_index-1, K) else: return select(pivot_index + 1, right, K) return select(0, len(nums) - 1 , k)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"324. Wiggle Sort II","slug":"324-Wiggle-Sort-II","date":"2020-10-22T05:52:05.000Z","updated":"2020-10-23T05:24:02.651Z","comments":true,"path":"2020/10/21/324-Wiggle-Sort-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/21/324-Wiggle-Sort-II/","excerpt":"","text":"time: nlogn space: n 1234567891011121314151617181920class Solution(object): def wiggleSort(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\" tmp = sorted(nums) k, j = (len(nums)-1)/2, len(nums)-1 for i in range(len(nums)): if i&amp;1: nums[i] = tmp[j] j -= 1 else: nums[i] = tmp[k] k -=1 return nums time O(n) O(1) space 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution(object): def wiggleSort(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\" median = self.findKthLargest(nums, (len(nums) + 1)/2) left, right, i = 0, len(nums)-1, 0 n = len(nums) def newIndex(i): return (2*i + 1)%(n|1) while i &lt;= right: if nums[newIndex(i)] &gt; median: nums[newIndex(left)], nums[newIndex(i)] = nums[newIndex(i)], nums[newIndex(left)] left += 1 i += 1 elif nums[newIndex(i)] &lt; median: nums[newIndex(right)], nums[newIndex(i)] = nums[newIndex(i)], nums[newIndex(right)] right -= 1 else: i += 1 def findKthLargest(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" def partition(left, right, pivot_index): pivot = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] &gt; pivot: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def select(left, right, K): if left == right: return nums[left] # print left, right pivot_index = random.randint(left, right) pivot_index = partition(left, right, pivot_index) if K == (pivot_index + 1): return nums[pivot_index] elif K &lt;= pivot_index: return select(left, pivot_index-1, K) else: return select(pivot_index + 1, right, K) return select(0, len(nums) - 1 , k) use ‘findKthLargest’ function to get the median element in average O(n) time and O(1) space. the ‘nums’ is partially sorted such that the first half is larger or equal to the median, the second half is smaller or equal to the median, i.e13 6 5 5 4 2 M elements smaller than the ‘median’ are put into the last even slots elements larger than the ‘median’ are put into the first odd slots the medians are put into the remaining slots.Index : 0 1 2 3 4 5Small half: M S SLarge half: L L M M - Median, S-Small, L-Large. In this example, we want to put {13, 6, 5} in index 1,3,5 and {5,4,2} in index {0,2,4} The index mapping, (1 + 2*index) % (n | 1) combined with ‘Color sort’, will do the job. Mapped_idx[Left] should be the position of next larger-than median elementMapped_idx[Right] should be the next smaller-than median element left at first mapping to odd idx–&gt; must be bigger than medianCan you explain why i++ for nums [new_idx(i)] &gt; mid, but not for nums[new_idx(i)] &lt; mid?– cause you don’t know what you will get from right, should keep checking. for left, cause i&gt;=left, all the left is checked. Step 1:Original idx: 0 1 2 3 4 5Mapped idx: 1 3 5 0 2 4Array: 13 6 5 5 4 2 Left i Right nums[Mapped_idx[i]] = nums[1] = 6 &gt; 5, so it is ok to put 6 in the first odd index 1. We increment i and left. Step 2:Original idx: 0 1 2 3 4 5Mapped idx: 1 3 5 0 2 4Array: 13 6 5 5 4 2 Left i Right nums[3] = 5 = 5, so it is ok to put 6 in the index 3. We increment i. Step 3:Original idx: 0 1 2 3 4 5Mapped idx: 1 3 5 0 2 4Array: 13 6 5 5 4 2 Left i Right nums[5] = 2 &lt; 5, so we want to put it to the last even index 4 (pointed by Right). So, we swap nums[Mapped_idx[i]] with nums[Mapped_idx[Right]], i.e. nums[5] with nums[4], and decrement Right. Step 4:Original idx: 0 1 2 3 4 5Mapped idx: 1 3 5 0 2 4Array: 13 6 5 5 2 4 Left i Right nums[5] = 4 &lt; 5, so we want to put it to the second last even index 2. So, we swap nums[5] with nums[2], and decrement Right. Step 5:Original idx: 0 1 2 3 4 5Mapped idx: 1 3 5 0 2 4Array: 13 6 4 5 2 5 Left i Right nums[5] = 5 &lt; 5, it is ok to put it there, we increment i. Step 6:Original idx: 0 1 2 3 4 5Mapped idx: 1 3 5 0 2 4Array: 13 6 4 5 2 5 Left i Right nums[0] = 13 &gt; 5, so, we want to put it to the next odd index which is 3 (pointed by ‘Left’). So, we swap nums[0] with nums[3], and increment ‘Left’ and ‘i’. Step Final:Original idx: 0 1 2 3 4 5Mapped idx: 1 3 5 0 2 4Array: 5 6 4 13 2 5 Left i Righti &gt; Right, we get the final wiggle array 5 6 4 13 2 5 !","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"435. Non-overlapping Intervals","slug":"435-Non-overlapping-Intervals","date":"2020-10-22T05:20:03.000Z","updated":"2020-10-22T05:23:59.783Z","comments":true,"path":"2020/10/21/435-Non-overlapping-Intervals/","link":"","permalink":"https://jojoyang666.github.io/2020/10/21/435-Non-overlapping-Intervals/","excerpt":"","text":"Using Greedy Approach based on end pointssort based on end time not start time 1234567891011121314class Solution(object): def eraseOverlapIntervals(self, intervals): \"\"\" :type intervals: List[List[int]] :rtype: int \"\"\" end, cnt = float('-inf'), 0 for s, e in sorted(intervals, key=lambda x: x[1]): if s &gt;= end: end = e else: cnt += 1 return cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1472. Design Browser History","slug":"1472-Design-Browser-History","date":"2020-10-22T03:00:29.000Z","updated":"2020-10-22T03:01:05.842Z","comments":true,"path":"2020/10/21/1472-Design-Browser-History/","link":"","permalink":"https://jojoyang666.github.io/2020/10/21/1472-Design-Browser-History/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class BrowserHistory(object): def __init__(self, homepage): \"\"\" :type homepage: str \"\"\" self.arr = [homepage] self.cur = 0 self.fwd = 0 #how many urls you can forward def visit(self, url): \"\"\" :type url: str :rtype: None \"\"\" self.cur += 1 self.arr = self.arr[:self.cur] ## previous history(urls which will be displayed after forward) will be deleted self.arr.append(url) self.fwd = 0 def back(self, steps): \"\"\" :type steps: int :rtype: str \"\"\" if steps &lt;= self.cur: self.cur -= steps self.fwd += steps else: self.cur = 0 self.fwd = len(self.arr) - 1 return self.arr[self.cur] def forward(self, steps): \"\"\" :type steps: int :rtype: str \"\"\" if steps &lt;= self.fwd: self.cur += steps self.fwd -= steps else: self.cur += self.fwd self.fwd = 0 return self.arr[self.cur]# Your BrowserHistory object will be instantiated and called as such:# obj = BrowserHistory(homepage)# obj.visit(url)# param_2 = obj.back(steps)# param_3 = obj.forward(steps)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"GCD","slug":"GCD","date":"2020-10-20T19:27:06.000Z","updated":"2020-10-25T21:22:53.065Z","comments":true,"path":"2020/10/20/GCD/","link":"","permalink":"https://jojoyang666.github.io/2020/10/20/GCD/","excerpt":"","text":"12def gcd(self, A, B): return A if B == 0 else self.gcd(B, A%B)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1223. Dice Roll Simulation","slug":"1223-Dice-Roll-Simulation","date":"2020-10-20T18:58:10.000Z","updated":"2020-10-26T19:56:27.496Z","comments":true,"path":"2020/10/20/1223-Dice-Roll-Simulation/","link":"","permalink":"https://jojoyang666.github.io/2020/10/20/1223-Dice-Roll-Simulation/","excerpt":"","text":"1234567891011121314151617class Solution(object): def dieSimulator(self, n, rollMax): \"\"\" :type n: int :type rollMax: List[int] :rtype: int \"\"\" dp = [[1 if i == 1 else 0 for j in range(6)] for i in range(n+1)] for i in range(2, n+1): for j in range(0, 6): k = i - rollMax[j] invalid = max(k, 0) if k &lt;= 1 else sum(dp[k - 1]) - dp[k - 1][j] dp[i][j] = sum(dp[i-1]) - invalid return sum(dp[n])%(10**9+7)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"256. Paint House","slug":"256-Paint-House","date":"2020-10-20T18:26:46.000Z","updated":"2020-10-20T18:27:06.117Z","comments":true,"path":"2020/10/20/256-Paint-House/","link":"","permalink":"https://jojoyang666.github.io/2020/10/20/256-Paint-House/","excerpt":"","text":"12345678910111213class Solution(object): def minCost(self, costs): \"\"\" :type costs: List[List[int]] :rtype: int \"\"\" if not costs: return 0 for i in range(1, len(costs)): costs[i][0] += min(costs[i-1][1], costs[i-1][2]) costs[i][1] += min(costs[i-1][0], costs[i-1][2]) costs[i][2] += min(costs[i-1][1], costs[i-1][0]) return min(costs[-1])","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"787. Cheapest Flights Within K Stops","slug":"787-Cheapest-Flights-Within-K-Stops","date":"2020-10-20T17:21:48.000Z","updated":"2020-10-20T17:59:53.858Z","comments":true,"path":"2020/10/20/787-Cheapest-Flights-Within-K-Stops/","link":"","permalink":"https://jojoyang666.github.io/2020/10/20/787-Cheapest-Flights-Within-K-Stops/","excerpt":"","text":"运用Dijkstra算法， 同时对step和距离进行收缩 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def findCheapestPrice(self, n, flights, src, dst, K): \"\"\" :type n: int :type flights: List[List[int]] :type src: int :type dst: int :type K: int :rtype: int \"\"\" adj_matrix = [[0] * n for _ in range(n)] for s, d, w in flights: adj_matrix[s][d] = w distances = [float('inf') for _ in range(n)] current_stops = [float('inf') for _ in range(n)] distances[src], current_stops[src] = 0, 0# cost, steos, node minHeap = [(0, 0, src)] while minHeap: cost, stops, node = heapq.heappop(minHeap) if node == dst: return cost if stops == K + 1: continue for nei in range(n): #因为路径的最小值go first, 所以有结果的永远是最小的cost if adj_matrix[node][nei] &gt; 0: dU, dv, wUV = cost, distances[nei], adj_matrix[node][nei] if dU + wUV &lt; dv or stops &lt; current_stops[nei]: distances[nei] = dU + wUV heapq.heappush(minHeap, (dU + wUV, stops + 1, nei)) current_stops[nei] = stops return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"264. Ugly Number II","slug":"264-Ugly-Number-II","date":"2020-10-20T15:41:42.000Z","updated":"2020-10-20T15:52:20.084Z","comments":true,"path":"2020/10/20/264-Ugly-Number-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/20/264-Ugly-Number-II/","excerpt":"","text":"通过观察可以知道， 每一个ugly number is coming from previous ugly number *2/3/5, thus, Choose the smallest number among nums[i2] * 2, nums[i3] * 3, and nums[i5] * 5 and add it into nums –&gt; record the right i2/i3/i5 pos 1234567891011121314151617181920212223class Solution(object): def nthUglyNumber(self, n): \"\"\" :type n: int :rtype: int \"\"\" res = [1] i2 = i3 = i5 = 0 while len(res) &lt; n: ugly = min(res[i2]*2, res[i3]*3, res[i5]*5) if ugly == res[i2]*2: i2 += 1 if ugly == res[i3]*3: i3 += 1 if ugly == res[i5]*5: i5 += 1 res.append(ugly) return res[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"718. Maximum Length of Repeated Subarray","slug":"718-Maximum-Length-of-Repeated-Subarray","date":"2020-10-20T15:05:38.000Z","updated":"2020-10-20T15:06:03.559Z","comments":true,"path":"2020/10/20/718-Maximum-Length-of-Repeated-Subarray/","link":"","permalink":"https://jojoyang666.github.io/2020/10/20/718-Maximum-Length-of-Repeated-Subarray/","excerpt":"","text":"1234567891011121314class Solution(object): def findLength(self, A, B): \"\"\" :type A: List[int] :type B: List[int] :rtype: int \"\"\" memo = [[0]*(len(B) + 1) for _ in range(len(A) + 1)] for i in range(len(A) - 1, -1, -1): for j in range(len(B)-1, -1, -1): if A[i] == B[j]: memo[i][j] = memo[i+1][j+1] + 1 return max(max(row) for row in memo)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1239. Maximum Length of a Concatenated String with Unique Characters","slug":"1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters","date":"2020-10-20T14:15:50.000Z","updated":"2020-10-20T14:29:16.051Z","comments":true,"path":"2020/10/20/1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters/","link":"","permalink":"https://jojoyang666.github.io/2020/10/20/1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters/","excerpt":"","text":"Set Operation1234567891011121314151617class Solution(object): def maxLength(self, arr): \"\"\" :type arr: List[str] :rtype: int \"\"\" dp = [set()] for a in arr:# skip the word which has the duplicate chars if len(set(a)) &lt; len(a): continue a = set(a) for c in dp: if a &amp; c: continue dp.append(a|c) return len(max(dp, key=len)) Backtrack123456789101112131415161718192021222324/** * @param &#123;string[]&#125; arr * @return &#123;number&#125; */var maxLength = function(arr) &#123; let max_length = 0 const hasDuplicate = (s) =&gt; &#123; return s.length &gt; new Set([...s]).size &#125; const bactrack = (idx, s) =&gt; &#123; max_length = Math.max(max_length, s.length) for (let i = idx; i &lt; arr.length; i++) &#123; if (!hasDuplicate(arr[i] + s)) &#123; bactrack(i + 1, arr[i] + s) &#125; &#125; &#125; bactrack(0, \"\") return max_length&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1143. Longest Common Subsequence","slug":"1143-Longest-Common-Subsequence","date":"2020-10-20T04:21:25.000Z","updated":"2020-10-20T04:21:46.073Z","comments":true,"path":"2020/10/19/1143-Longest-Common-Subsequence/","link":"","permalink":"https://jojoyang666.github.io/2020/10/19/1143-Longest-Common-Subsequence/","excerpt":"","text":"12345678910111213141516class Solution(object): def longestCommonSubsequence(self, text1, text2): \"\"\" :type text1: str :type text2: str :rtype: int \"\"\" dp = [[0] * (len(text2) + 1) for _ in range(len(text1)+1)] for col in reversed(range(len(text2))): for row in reversed(range(len(text1))): if text1[row] == text2[col]: dp[row][col] = 1 + dp[row+1][col+1] else: dp[row][col] = max(dp[row+1][col], dp[row][col+1]) return dp[0][0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1041. Robot Bounded In Circle","slug":"1041-Robot-Bounded-In-Circle","date":"2020-10-20T03:23:33.000Z","updated":"2020-10-20T03:29:51.368Z","comments":true,"path":"2020/10/19/1041-Robot-Bounded-In-Circle/","link":"","permalink":"https://jojoyang666.github.io/2020/10/19/1041-Robot-Bounded-In-Circle/","excerpt":"","text":"12345678910111213141516171819class Solution(object): def isRobotBounded(self, instructions): \"\"\" :type instructions: str :rtype: bool \"\"\"# north, west, sorth, east x = y = 0 dirctions = [[0, 1], [-1, 0], [0, -1], [1, 0]] idx = 0 for i in instructions: if i == 'L': idx = (idx + 1)%4 elif i == 'R': idx = (idx + 3)%4 else: x += dirctions[idx][0] y += dirctions[idx][1] return (x == 0 and y == 0) or idx != 0 由于指令是循环的，题目只给出了部分指令。那么对于该部分指令的要求是，机器人回到了原点或者不再原点且不面向北。 不再原点且不面向北: 如果题目中的指令结束之后，机器人不在原点，那么说明它相对原点移动了一个向量v。机器人在指令结束后的位置成为了新的原点，题目说机器人的初始状态时是面向北的，那么如果在新的原点上仍然面向北，那么一定还会继续向第一次一样相对新的原点移动相同的向量v，此时机器人距原点的向量是2v。 为什么不面向北就一定能回到原点呢? 这是由于在新的原点新的方向上再次接受相同指令后，机器人移动新向量的长度为|向量v|、方向和v成90度或者180度；多次指令的结果叠加就会抵消第一次移动的v。 方向一定要逆时针/顺时针来给， 来保证每次计算的dir是正确的","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"371. Sum of Two Integers","slug":"371-Sum-of-Two-Integers","date":"2020-10-19T23:06:44.000Z","updated":"2020-10-20T03:23:51.162Z","comments":true,"path":"2020/10/19/371-Sum-of-Two-Integers/","link":"","permalink":"https://jojoyang666.github.io/2020/10/19/371-Sum-of-Two-Integers/","excerpt":"","text":"例子 759+674 如果不考虑进位，可以得到 323 如果只考虑进位，可以得到 1110 把上面两个数字假期 323+1110=1433 就是最终结果了 如果得到上面的第一第二种情况，在二进制下来看，不考虑进位的加，0+0=0，0+1=1, 1+0=1，1+1=0，这就是异或的运算规则 如果只考虑进位的加 0+0=0, 0+1=0, 1+0=0, 1+1=1，而这其实这就是’与’的运算， 第三步在将两者相加时，再递归调用这个算法，终止条件是当进位为0时 Python has no 32-bits limit, and hence its representation of negative integers is entirely different. After each operation we have an invisible &amp; mask, where mask = 0xFFFFFFFF, i.e. bitmask of 32 1-bits. The overflow, i.e. the situation of x &gt; 0x7FFFFFFF (bitmask of 31 1-bits), is managed as x –&gt; ~(x ^ 0xFFFFFFFF). 采用补码表示正数的补码是原码负数的补码是： 原码各位取反 + 1 加法：整数： [A]补 + [B]补 = [A+B]补 （mod 2^(n+1)） 减法：整数： [A-B]补 = [A]补 + [-B]补 （mod 2^(n+1)）小数： [A-B]补 = [A]补 + [-B]补（mod 2）[-B]补的求法就是 [B]补的连同符号位在内，每位求反加一所以 ~(a ^ mask)需要这一步结果可能存在补码， 所以我们需要将补码还原 becasue we were mimcing the java, if it is overflow, it will count from the lowest valuethat’s the reason why we use ~(a ^ mask)Other Bit Summary. 123456789101112class Solution(object): def getSum(self, a, b): \"\"\" :type a: int :type b: int :rtype: int \"\"\" mask = 0xffffffff while b != 0: a, b = (a^b)&amp;mask, ((a&amp;b) &lt;&lt; 1)&amp;mask return a if a &lt; 0x7fffffff else ~(a^mask) Explanation for ~(a^mask)： the integer is not limited to say 32 bits, so you can’t just flip each bit in left part of the bit representation to 1 manually, since the python integer will always get greater (for convinience). In python you have to use the ~ invert operator to get 2er complement. Since ‘a’ actually is already our representation in 2’s complement we need to invert with (a^mask) then invert once more to get python negative number","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Bit Manipulation","slug":"Bit-Manipulation","date":"2020-10-17T15:54:05.000Z","updated":"2020-10-28T21:25:03.716Z","comments":true,"path":"2020/10/17/Bit-Manipulation/","link":"","permalink":"https://jojoyang666.github.io/2020/10/17/Bit-Manipulation/","excerpt":"","text":"优先级 位运算 &lt; 算术运算 按位与、按位或及异或低于比较运算符 ~ 把 的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）。有符号整数的符号位在 ~ 运算中同样会取反。 一些常见数字的二进制 -1 —-&gt; 11111111 11111111 11111111 11111111 判断一个数是不是 2 的非负整数次幂bool isPowerOfTwo(int n) { return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0; } 对 2 的非负整数次幂取模int modPowerOfTwo(int x, int mod) { return x &amp; (mod - 1); } n&gt;&gt;31 取得 n 的符号，若 n 为正数，n&gt;&gt;31 等于 0，若 n 为负数，n&gt;&gt;31 等于 -1 取绝对值1234567int Abs(int n) &#123; return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31); /* n&gt;&gt;31 取得 n 的符号，若 n 为正数，n&gt;&gt;31 等于 0，若 n 为负数，n&gt;&gt;31 等于 -1 若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1) 需要计算 n 和 -1 的补码，然后进行异或运算， 结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值 */&#125; n&gt;&gt;31 取得 n 的符号，若 n 为正数，n&gt;&gt;31 等于 0，若 n 为负数，n&gt;&gt;31 等于 -1123bool isSameSign(int x, int y) &#123; // 有 0 的情况例外 return (x ^ y) &gt;= 0;&#125; 获取一个数二进制的某一位12// 获取 a 的第 b 位，最低位编号为 0int getBit(int a, int b) &#123; return (a &gt;&gt; b) &amp; 1; &#125; 将一个二进制数的某一位设置为012// 将 a 的第 b 位设置为 0 ，最低位编号为 0int unsetBit(int a, int b) &#123; return a &amp; ~(1 &lt;&lt; b); &#125; 将一个二进制数的某一位设置为112// 将 a 的第 b 位设置为 1 ，最低位编号为 0int setBit(int a, int b) &#123; return a | (1 &lt;&lt; b); &#125; 将一个数二进制的某一位取反// 将 a 的第 b 位取反 ，最低位编号为 0 int flapBit(int a, int b) { return a ^ (1 &lt;&lt; b); } 表示集合一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。对应的位运算也就可以看作是对集合进行的操作 正数， 负数的计算机表示 采用补码表示 正数的补码是原码 负数的补码是： 原码各位取反 + 1 Tricksx&amp;-x –&gt; 最右侧为1的位置~x + x = -1加法：整数： [A]补 + [B]补 = [A+B]补 （mod 2^(n+1)） 减法：整数： [A-B]补 = [A]补 + [-B]补 （mod 2^(n+1)）小数： [A-B]补 = [A]补 + [-B]补（mod 2）[-B]补的求法就是 [B]补的连同符号位在内，每位求反加一 Other Info","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"137. Single Number II","slug":"137-Single-Number-II","date":"2020-10-17T02:26:04.000Z","updated":"2020-10-19T17:20:07.620Z","comments":true,"path":"2020/10/16/137-Single-Number-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/16/137-Single-Number-II/","excerpt":"","text":"~x&amp;x = 0 123456789101112class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" seen_once, seen_twice = 0, 0 for num in nums: seen_once = ~seen_twice &amp; (num ^ seen_once) seen_twice = ~seen_once &amp; (seen_twice ^ num) return seen_once 12345678910111213141516class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" ones, twos, threes = 0,0,0 for num in nums: twos |= ones &amp; num ones = ones ^ num threes = twos &amp; ones twos = ~threes &amp; twos ones = ~threes &amp; ones return ones","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"356. Line Reflection","slug":"356-Line-Reflection","date":"2020-10-16T17:13:25.000Z","updated":"2020-10-16T17:31:54.774Z","comments":true,"path":"2020/10/16/356-Line-Reflection/","link":"","permalink":"https://jojoyang666.github.io/2020/10/16/356-Line-Reflection/","excerpt":"","text":"找到所有点的横坐标的最大值和最小值, 那么二者的平均值就是中间直线的横坐标 我们遍历每个点，如果都能找到直线对称的另一个点, 则返回true，反之返回false 12345678910111213141516171819class Solution(object): def isReflected(self, points): \"\"\" :type points: List[List[int]] :rtype: bool \"\"\" min_value, max_value = float('inf'), float('-inf') d = collections.defaultdict(set) for point in points: min_value, max_value = min(min_value, point[0]), max(max_value, point[0]) d[point[0]].add(point[1]) line = min_value + max_value for point in points: another = line - point[0] if another not in d or point[1] not in d[another]: return False return True 12345678910111213141516class Solution(object): def isReflected(self, points): \"\"\" :type points: List[List[int]] :rtype: bool \"\"\" if not points: return True min_p=min([i[0] for i in points]) max_p=max([i[0] for i in points]) d=set() for i in points: d.add(tuple(i)) for i in points: if (min_p+max_p-i[0], i[1]) not in d: return False return True","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"539. Minimum Time Difference","slug":"539-Minimum-Time-Difference","date":"2020-10-16T16:43:53.000Z","updated":"2020-10-16T16:48:24.277Z","comments":true,"path":"2020/10/16/539-Minimum-Time-Difference/","link":"","permalink":"https://jojoyang666.github.io/2020/10/16/539-Minimum-Time-Difference/","excerpt":"","text":"corner case: 最小的也可以和最大的diff 因为可能是来自第二天 123456789class Solution(object): def findMinDifference(self, timePoints): \"\"\" :type timePoints: List[str] :rtype: int \"\"\" minutes = sorted(int(time[:2]) * 60 + int(time[3:]) for time in timePoints) minutes.append(minutes[0] + 24*60)#最小的也可以和最大的diff 因为可能是来自第二天 return min(b - a for a, b in zip(minutes, minutes[1:]))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"969. Pancake Sorting","slug":"969-Pancake-Sorting","date":"2020-10-16T15:17:31.000Z","updated":"2020-10-16T16:07:25.265Z","comments":true,"path":"2020/10/16/969-Pancake-Sorting/","link":"","permalink":"https://jojoyang666.github.io/2020/10/16/969-Pancake-Sorting/","excerpt":"","text":"注意题目的输入特点 有没有什么限制 Find the index i of the next maximum number x.Reverse i + 1 numbers, so that the x will be at A[0]Reverse x numbers, so that x will be at A[x - 1].Repeat this process N times. 12345678910111213141516class Solution(object): def pancakeSort(self, arr): \"\"\" :type arr: List[int] :rtype: List[int] \"\"\" res = [] for x in range(len(arr), 1, -1): idx = arr.index(x) res.extend([idx+1, x])#now x is at idx pos, we need to flip k = idx + 1, so x is at pos 0#then flip k = x, then x is at pos x - 1 arr = arr[:idx:-1] + arr[:idx]# when x is at the right pos, and also we tranverse from back to front, so we do not need to consider pos at x-1 to len(arr)# need to restore the situtation for pos from 0 to x-1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1314. Matrix Block Sum","slug":"1314-Matrix-Block-Sum","date":"2020-10-16T03:37:22.000Z","updated":"2020-10-16T04:10:30.828Z","comments":true,"path":"2020/10/15/1314-Matrix-Block-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/10/15/1314-Matrix-Block-Sum/","excerpt":"","text":"重点我们左上角的r1,c1， 其实是 i - k - 1, j - k - 1(in mat array), 因为我们的和里面要有 i - k, j - k 123456789101112131415161718192021class Solution(object): def matrixBlockSum(self, mat, K): \"\"\" :type mat: List[List[int]] :type K: int :rtype: List[List[int]] \"\"\" m, n = len(mat), len(mat[0]) rangeSum = [[0] * (n+1) for _ in range(m+1)] for i in range(m+1)[1:]: for j in range(n+1)[1:]: rangeSum[i][j] = rangeSum[i-1][j] + rangeSum[i][j-1] - rangeSum[i-1][j-1] + mat[i-1][j-1] ans = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): r1, c1, r2, c2 = max(i - K , 0), max(j - K , 0), min(m, i + K + 1), min(n, j + K + 1) ans[i][j] = rangeSum[r2][c2] + rangeSum[r1][c1] - rangeSum[r2][c1] - rangeSum[r1][c2] return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"range/prefix sum","slug":"range-prefix-sum","date":"2020-10-16T03:32:56.000Z","updated":"2020-10-16T03:35:04.297Z","comments":true,"path":"2020/10/15/range-prefix-sum/","link":"","permalink":"https://jojoyang666.github.io/2020/10/15/range-prefix-sum/","excerpt":"","text":"Range Sum Query 2D - Immutable Range Sum Query - Mutable Range Sum Query 2D - Mutable: Premium Matrix Block Sum","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"983. Minimum Cost For Tickets","slug":"983-Minimum-Cost-For-Tickets","date":"2020-10-16T03:17:13.000Z","updated":"2020-10-16T03:17:59.008Z","comments":true,"path":"2020/10/15/983-Minimum-Cost-For-Tickets/","link":"","permalink":"https://jojoyang666.github.io/2020/10/15/983-Minimum-Cost-For-Tickets/","excerpt":"","text":"12345678910111213141516class Solution(object): def mincostTickets(self, days, costs): \"\"\" :type days: List[int] :type costs: List[int] :rtype: int \"\"\" dp = [0 for i in range(days[-1] + 1)] for i in range(1, days[-1] + 1): if i not in days: dp[i] = dp[i-1] else: dp[i] = min(dp[max(0, i - 7)] + costs[1], dp[max(0, i - 1)] + costs[0], dp[max(0, i-30)] + costs[2]) return dp[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"150. Evaluate Reverse Polish Notation","slug":"150-Evaluate-Reverse-Polish-Notation","date":"2020-10-15T04:18:45.000Z","updated":"2020-10-15T04:27:38.111Z","comments":true,"path":"2020/10/14/150-Evaluate-Reverse-Polish-Notation/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/150-Evaluate-Reverse-Polish-Notation/","excerpt":"","text":"123456789101112131415161718192021222324class Solution(object): def evalRPN(self, tokens): \"\"\" :type tokens: List[str] :rtype: int \"\"\" operations = &#123; \"+\": lambda a, b: a + b, \"-\": lambda a, b: a - b, \"*\": lambda a, b: a * b, \"/\": lambda a, b: int(float(a)/b) #cornor case: 6/-132 it should be 0, but python return -1 &#125; stack = [] for token in tokens: if token in operations: num2 = stack.pop() num1 = stack.pop() num = operations[token](num1, num2) stack.append(num) else: stack.append(int(token)) return stack.pop()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1423. Maximum Points You Can Obtain from Cards","slug":"1423-Maximum-Points-You-Can-Obtain-from-Cards","date":"2020-10-15T03:43:45.000Z","updated":"2020-10-15T04:07:47.245Z","comments":true,"path":"2020/10/14/1423-Maximum-Points-You-Can-Obtain-from-Cards/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/1423-Maximum-Points-You-Can-Obtain-from-Cards/","excerpt":"","text":"Solution 1Problem Tranlation: * find the smallest sum of subarray with length is equal to len(cardPoints) - k 12345678910111213141516171819202122class Solution(object): def maxScore(self, cardPoints, k): \"\"\" :type cardPoints: List[int] :type k: int :rtype: int \"\"\" size = len(cardPoints) - k minSubArraysSum = float('inf') j = curr = 0 for i, v in enumerate(cardPoints): curr += v if i - j + 1 &gt; size: curr -= cardPoints[j] j += 1 if i - j + 1 == size: minSubArraysSum = min(minSubArraysSum, curr) return sum(cardPoints) - minSubArraysSum Solution 2 根据题目的特点， 最左边最多有K个元素， 最右边也最多有K个元素 所以先拿到最左边的和， 然后考虑加入最右侧的元素， 每加入一个， 就要将左侧中最靠近中心的那个元素减去1234567891011121314class Solution(object): def maxScore(self, cardPoints, k): \"\"\" :type cardPoints: List[int] :type k: int :rtype: int \"\"\" s = sum(cardPoints[:k]) res = s for i in range(1, k+1): s += cardPoints[-i] - cardPoints[k-i] res = max(s, res) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"94. Binary Tree Inorder Traversal","slug":"94-Binary-Tree-Inorder-Traversal","date":"2020-10-15T01:53:58.000Z","updated":"2020-10-15T01:58:39.877Z","comments":true,"path":"2020/10/14/94-Binary-Tree-Inorder-Traversal/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/94-Binary-Tree-Inorder-Traversal/","excerpt":"","text":"123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def inorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res = [] self.helper(root, res) return res def helper(self, root, res): if not root: return self.helper(root.left, res) res.append(root.val) self.helper(root.right, res) 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def inorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res, stack = [], [] while True: while root: stack.append(root) root = root.left if not stack: return res root = stack.pop() res.append(root.val) root = root.right","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"556. Next Greater Element III","slug":"556-Next-Greater-Element-III","date":"2020-10-15T01:34:01.000Z","updated":"2020-10-15T01:35:35.776Z","comments":true,"path":"2020/10/14/556-Next-Greater-Element-III/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/556-Next-Greater-Element-III/","excerpt":"","text":"123456789101112131415161718192021222324class Solution(object): def nextGreaterElement(self, n): \"\"\" :type n: int :rtype: int \"\"\" s = list(map(int, str(n))) i = len(s) - 1 while i - 1 &gt;= 0 and s[i-1] &gt;= s[i]: i -= 1 j = i if i == 0: return -1 while j + 1 &lt; len(s) and s[j+1] &gt; s[i-1]: j += 1 s[i-1], s[j] = s[j], s[i-1] s[i:] = reversed(s[i:]) ret = int(''.join(map(str, s))) return ret if ret &lt;= ((1 &lt;&lt; 31) - 1) else -1 1234567891011121314151617181920212223class Solution(object): def nextGreaterElement(self, n): if not n: return -1 s = str(n) arr = [c for c in s] i = len(arr)-1 while i &gt; 0: prev = int(arr[i-1]) if int(arr[i]) &gt; prev: j = i # looking for right position to swap while j &lt; len(arr) and int(arr[j]) &gt; prev: j += 1 arr[i-1], arr[j-1], j = arr[j-1], arr[i-1], len(arr)-1 # reverse array from pivot point til end while i &lt; j: arr[i], arr[j] = arr[j], arr[i] i += 1; j -= 1 res = int(''.join(arr)) # check 32 bit constraint return -1 if res &gt; 2147483647 else res i -= 1 return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"694. Number of Distinct Islands","slug":"694-Number-of-Distinct-Islands","date":"2020-10-14T21:15:48.000Z","updated":"2020-10-14T21:16:18.807Z","comments":true,"path":"2020/10/14/694-Number-of-Distinct-Islands/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/694-Number-of-Distinct-Islands/","excerpt":"","text":"When we start a depth-first search on the top-left square of some island, the path taken by our depth-first search will be the same if and only if the shape is the same. 1234567891011121314151617181920212223242526class Solution(object): def numDistinctIslands(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" seen = set() def explore(r, c, di = 0): if 0&lt;= r &lt; len(grid) and 0 &lt;= c &lt; len(grid[0]) and grid[r][c] and (r,c) not in seen: seen.add((r,c)) shape.append(di) explore(r+1, c, 1) explore(r-1, c, 2) explore(r, c+1, 3) explore(r, c-1, 4)# we need to add 0, 因为有可能有的方向没有这时候要有什么东西做阻断来区别 shape.append(0) shapes = set() for r in xrange(len(grid)): for c in xrange(len(grid[0])): shape = [] explore(r, c) if shape: shapes.add(tuple(shape)) return len(shapes)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"187. Repeated DNA Sequences","slug":"187-Repeated-DNA-Sequences","date":"2020-10-14T19:42:33.000Z","updated":"2020-10-19T21:38:02.047Z","comments":true,"path":"2020/10/14/187-Repeated-DNA-Sequences/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/187-Repeated-DNA-Sequences/","excerpt":"","text":"Linear-time Slice Using Substring + HashSet123456789101112131415class Solution(object): def findRepeatedDnaSequences(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\" L, n = 10, len(s) seen, output = set(), set() for start in range(n - L + 1): tmp = s[start: start + L] if tmp in seen: output.add(tmp) seen.add(tmp) return output 12345678class Solution: # @param s, a string # @return a list of strings def findRepeatedDnaSequences(self, s): sequences = collections.defaultdict(int) #set '0' as the default value for non-existing keys for i in range(len(s)): sequences[s[i:i+10]] += 1#add 1 to the count return [key for key, value in sequences.iteritems() if value &gt; 1] #extract the relevant keys Bit Manipulation 用数字来代表0，1，2，3表示字符A, C, G, T 选用0，1，2，3 是因为可以用00， 01， 10，11的二进制表示 如果要表示10位chars， 则需要20位bits 用18位bits作为掩码， 每遇到一个新的字符， 就将数字左移 两位 和当前数字| 新的数字是否出现过， 若是出现过， 加入到结果当中12345678910111213141516171819202122class Solution(object): def findRepeatedDnaSequences(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\"# 这个方法用于节省内存 res, st = set(), set() d = &#123;'A': 0, 'C': 1, 'G': 2, 'T': 3&#125; cur = 0 for i in range(min(9, len(s))): cur = cur &lt;&lt; 2 | d[s[i]] for i in range(9, len(s)): cur = ((cur &amp; 0x3ffff) &lt;&lt; 2) | d[s[i]] if cur in st: res.add(s[i-9:i+1]) else: st.add(cur) return list(res)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"581. Shortest Unsorted Continuous Subarray","slug":"581-Shortest-Unsorted-Continuous-Subarray","date":"2020-10-14T18:21:22.000Z","updated":"2020-10-14T18:50:27.991Z","comments":true,"path":"2020/10/14/581-Shortest-Unsorted-Continuous-Subarray/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/581-Shortest-Unsorted-Continuous-Subarray/","excerpt":"","text":"Using sort1234567891011121314151617class Solution(object): def findUnsortedSubarray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" snums = list(nums) snums.sort() start, end = len(nums), 0 for i in xrange(len(nums)): if snums[i] != nums[i]: start = min(start, i) end = max(end, i) return end - start + 1 if end - start &gt;= 0 else 0 123def findUnsortedSubarray(self, nums): res = [i for (i, (a, b)) in enumerate(zip(nums, sorted(nums))) if a != b] return 0 if not res else res[-1] - res[0] + 1 Stack12345678910111213141516171819class Solution(object): def findUnsortedSubarray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" stack = [] start, end = len(nums), 0 for i in range(len(nums)): while stack and nums[stack[-1]] &gt; nums[i]: start = min(start, stack.pop()) stack.append(i) for i in range(len(nums))[::-1]: while stack and nums[stack[-1]] &lt; nums[i]: end = max(end, stack.pop()) stack.append(i) return end - start + 1 if end - start &gt; 0 else 0 O(1) space + O(n) time complexity注意题目的重点只有一个sub array 1234567891011121314151617181920212223242526class Solution(object): def findUnsortedSubarray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) &lt; 2: return 0 l, r = 0, len(nums) -1 while l &lt; len(nums) - 1 and nums[l] &lt;= nums[l+1]: l += 1 while r &gt; 0 and nums[r] &gt;= nums[r-1]: r -= 1 if l &gt;= r: return 0 tmp = nums[l:r+1] min_tmp, max_tmp = min(tmp), max(tmp) while l &gt; 0 and nums[l-1] &gt; min_tmp: l -= 1 while r &lt; len(nums)-1 and nums[r+1] &lt; max_tmp: r += 1 return r - l + 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"535. Encode and Decode TinyURL","slug":"535-Encode-and-Decode-TinyURL","date":"2020-10-14T17:12:32.000Z","updated":"2020-10-14T17:46:02.794Z","comments":true,"path":"2020/10/14/535-Encode-and-Decode-TinyURL/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/535-Encode-and-Decode-TinyURL/","excerpt":"","text":"Solution 1Using Simple Counter，如果接受到多次同一url地址，仍然会当做不同的url来处理。计数器编码另一个缺点就是数字会不断的增大，那么编码的长度也就不是确定的了 1234567891011121314151617181920212223242526272829class Codec: def __init__(self): self.i = 0 self.dict = &#123;&#125; def encode(self, longUrl): \"\"\"Encodes a URL to a shortened URL. :type longUrl: str :rtype: str \"\"\" self.dict[self.i] = longUrl tmp = self.i self.i += 1 return \"http://tinyurl.com/\" + str(tmp) def decode(self, shortUrl): \"\"\"Decodes a shortened URL to its original URL. :type shortUrl: str :rtype: str \"\"\" _, _, idx = shortUrl.partition(\"http://tinyurl.com/\") return self.dict[int(idx)] # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(url)) Solution 2It produces short URLs like http://tinyurl.com/KtLa2U, using a random code of six digits or letters.If a long URL is already known, the existing short URL is used and no new entry is generated 1234567891011121314151617181920212223242526272829303132class Codec: alphabet = string.ascii_letters + '0123456789' def __init__(self): self.url2code = &#123;&#125; self.code2url = &#123;&#125; def encode(self, longUrl): \"\"\"Encodes a URL to a shortened URL. :type longUrl: str :rtype: str \"\"\" while longUrl not in self.url2code: code = ''.join(random.choice(Codec.alphabet) for _ in range(6)) if code not in self.code2url: self.code2url[code] = longUrl self.url2code[longUrl] = code return 'http://tinyurl.com/' + self.url2code[longUrl] def decode(self, shortUrl): \"\"\"Decodes a shortened URL to its original URL. :type shortUrl: str :rtype: str \"\"\" return self.code2url[shortUrl[-6:]]# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(url))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"36. Valid Sudoku","slug":"36-Valid-Sudoku","date":"2020-10-14T16:47:42.000Z","updated":"2020-10-14T16:49:54.586Z","comments":true,"path":"2020/10/14/36-Valid-Sudoku/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/36-Valid-Sudoku/","excerpt":"","text":"用三个数组of dict来存储次数 重点是要用 (i/3)*3 + j/3转化成box index12345678910111213141516171819202122232425class Solution(object): def isValidSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: bool \"\"\" rows = [defaultdict(int) for i in range(9)] cols = [defaultdict(int) for i in range(9)] boxes = [defaultdict(int) for i in range(9)] for i in range(9): for j in range(9): num = board[i][j] if num != '.': num = int(num) box_index = (i/3)*3 + j/3 rows[i][num] += 1 cols[j][num] += 1 boxes[box_index][num] += 1 if rows[i][num] &gt; 1 or cols[j][num] &gt; 1 or boxes[box_index][num] &gt; 1: return False return True","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"130. Surrounded Regions","slug":"130-Surrounded-Regions","date":"2020-10-14T16:17:22.000Z","updated":"2020-10-14T16:17:43.159Z","comments":true,"path":"2020/10/14/130-Surrounded-Regions/","link":"","permalink":"https://jojoyang666.github.io/2020/10/14/130-Surrounded-Regions/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031class Solution(object): def solve(self, board): \"\"\" :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. \"\"\" if not board or not board[0]: return self.rows, self.cols = len(board), len(board[0]) borders = list(itertools.product(range(self.rows), [0, self.cols-1])) + list(itertools.product([0, self.rows-1], range(self.cols))) for row, col in borders: self.DFS(board, row, col) for r in range(self.rows): for c in range(self.cols): if board[r][c] == 'O': board[r][c] = 'X' elif board[r][c] == 'E': board[r][c] = 'O' def DFS(self, board, row, col): if board[row][col] != 'O': return board[row][col] = 'E' if col &lt; self.cols - 1: self.DFS(board, row, col+1) if row &lt; self.rows - 1: self.DFS(board, row+1, col) if col &gt; 0: self.DFS(board, row, col-1) if row &gt; 0: self.DFS(board, row-1, col)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"62. Unique Paths","slug":"62-Unique-Paths","date":"2020-10-14T03:34:44.000Z","updated":"2020-10-14T03:35:07.922Z","comments":true,"path":"2020/10/13/62-Unique-Paths/","link":"","permalink":"https://jojoyang666.github.io/2020/10/13/62-Unique-Paths/","excerpt":"","text":"12345678910111213class Solution(object): def uniquePaths(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" dp = [[1] * n for _ in range(m)] for row in range(1, m): for col in range(1, n): dp[row][col] = dp[row-1][col] + dp[row][col-1] return dp[m-1][n-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"201. Bitwise AND of Numbers Range","slug":"201-Bitwise-AND-of-Numbers-Range","date":"2020-10-14T03:27:41.000Z","updated":"2020-10-14T03:30:01.181Z","comments":true,"path":"2020/10/13/201-Bitwise-AND-of-Numbers-Range/","link":"","permalink":"https://jojoyang666.github.io/2020/10/13/201-Bitwise-AND-of-Numbers-Range/","excerpt":"","text":"通过几个例子可以发现， 结果是该数字范围内所有的数的左边共同的部分， 而左边为1最少的和左边为一最多的就是m, n,所以找到一样的数字再右移即可 123456789101112131415class Solution(object): def rangeBitwiseAnd(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" shift = 0 while m != n: m = m &gt;&gt; 1 n = n &gt;&gt; 1 shift += 1 return m &lt;&lt; shift","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"16. 3Sum Closest","slug":"16-3Sum-Closest","date":"2020-10-14T03:11:19.000Z","updated":"2020-10-14T03:17:46.472Z","comments":true,"path":"2020/10/13/16-3Sum-Closest/","link":"","permalink":"https://jojoyang666.github.io/2020/10/13/16-3Sum-Closest/","excerpt":"","text":"Two Pointers (n^2)1234567891011121314151617181920212223242526class Solution(object): def threeSumClosest(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" diff = float('inf') nums.sort() for i in range(len(nums)): lo, hi = i+ 1, len(nums) - 1 while lo &lt; hi: sum = nums[i] + nums[lo] + nums[hi] #diff 不能abs if abs(target - sum) &lt; abs(diff): diff = target - sum if sum &lt; target: lo += 1 else: hi -= 1 if diff == 0: break return target - diff","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"417. Pacific Atlantic Water Flow","slug":"417-Pacific-Atlantic-Water-Flow","date":"2020-10-14T02:51:08.000Z","updated":"2020-10-14T02:51:42.055Z","comments":true,"path":"2020/10/13/417-Pacific-Atlantic-Water-Flow/","link":"","permalink":"https://jojoyang666.github.io/2020/10/13/417-Pacific-Atlantic-Water-Flow/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def pacificAtlantic(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: List[List[int]] \"\"\" if not matrix: return [] self.directions= [(-1, 0), (1, 0), (0, 1), (0, -1)] m, n = len(matrix), len(matrix[0]) p_visited = [[False for _ in range(n)] for _ in range(m)] a_visited = [[False for _ in range(n)] for _ in range(m)] result = [] for i in range(m): # p_visited[i][0] = True # a_visited[i][n-1] = True self.dfs(matrix, i, 0, p_visited, m, n) self.dfs(matrix, i, n-1, a_visited, m, n) for j in range(n): # p_visited[0][j] = True # a_visited[m-1][j] = True self.dfs(matrix, 0, j, p_visited, m, n) self.dfs(matrix, m-1, j, a_visited, m, n) for i in range(m): for j in range(n): if p_visited[i][j] and a_visited[i][j]: result.append([i,j]) return result def dfs(self, matrix, i, j, visited, m, n): # when dfs called, meaning its caller already verified this point visited[i][j] = True for dir in self.directions: x, y = i + dir[0], j + dir[1] if x &lt; 0 or x &gt;= m or y &lt; 0 or y &gt;= n or visited[x][y] or matrix[x][y] &lt; matrix[i][j]: continue self.dfs(matrix, x, y, visited, m, n)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1229. Meeting Scheduler","slug":"1229-Meeting-Scheduler","date":"2020-10-14T00:08:10.000Z","updated":"2020-10-14T02:32:03.231Z","comments":true,"path":"2020/10/13/1229-Meeting-Scheduler/","link":"","permalink":"https://jojoyang666.github.io/2020/10/13/1229-Meeting-Scheduler/","excerpt":"","text":"把所有的list放在一起， 不用区分person 1， person2 的原因是：因为input 对于每个人来说， 不会有overlap存在， 所以只要overlap 那么就必然是两个人的时间overlap了 从pq里面找到最小的start time pop出来， 然后下一个小的元素做比较看会不会overlap 123456789101112131415class Solution(object): def minAvailableDuration(self, slots1, slots2, duration): \"\"\" :type slots1: List[List[int]] :type slots2: List[List[int]] :type duration: int :rtype: List[int] \"\"\" s = list(filter(lambda slot: slot[1] - slot[0] &gt;= duration, slots1 + slots2)) heapq.heapify(s) while len(s) &gt; 1: if heapq.heappop(s)[1] &gt;= s[0][0] + duration: return [s[0][0], s[0][0] + duration] return []","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"609. Find Duplicate File in System","slug":"609-Find-Duplicate-File-in-System","date":"2020-10-11T22:28:09.000Z","updated":"2020-10-11T22:40:36.617Z","comments":true,"path":"2020/10/11/609-Find-Duplicate-File-in-System/","link":"","permalink":"https://jojoyang666.github.io/2020/10/11/609-Find-Duplicate-File-in-System/","excerpt":"","text":"12345678910111213141516class Solution(object): def findDuplicate(self, paths): \"\"\" :type paths: List[str] :rtype: List[List[str]] \"\"\" M = collections.defaultdict(list) for line in paths: data = line.split() root = data[0] for file in data[1:]: name, _, content = file.partition('(') M[content[:-1]].append(root + '/' + name) return [x for x in M.values() if len(x) &gt; 1] Follow UP Imagine you are given a real file system, how will you search files? DFS or BFS ?In general, BFS will use more memory than DFS, however, bfs can take advantage of the locality of files inside directories, and thereofore will probably be faster If the file content is very large(GB level), how will you modify your solutionIn a real life, we will not hash the entire file content. Since it is not practical. Instead, we will first map all the files according to the size. Files with different sizes are guaranteed to be different Hash a small part of the files with equal sizes(using MD5/SHA256) Only if md5 is same, we will compare the files byte ny byte If you can only read the file by 1kb each time, how will you modify your solution?This won’t change the solution. We can create the hash from the 1kb chunks, and then read the entire file if a full byte by byte comparison is required What is the time complexity of your modified solution? What is the most time consuming part and memory consuming part of it? How to optimize? Time complexity is O(n^2 * k) since in worse case we might need to compare every file to all others. k is the file size Comparing the file (by size, by hash and eventually byte by byte) is the most time consuming part. Generating hash for every file will be the most memory consuming part. We follow the above procedure will optimize it, since we compare files by size first, only when sizes differ, we’ll generate and compare hashes, and only when hashes are the same, we’ll compare byte by byte. Also, using better hashing algorithm will also reduce memory/time. How to make sure the duplicated files you find are not false positive? We will use several filters to compare: File size, Hash and byte by byte comparisons. https://stackoverflow.com/questions/14139727/sha-256-or-md5-for-file-integrity","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"384. Shuffle an Array","slug":"384-Shuffle-an-Array","date":"2020-10-11T21:23:08.000Z","updated":"2020-10-11T21:26:04.829Z","comments":true,"path":"2020/10/11/384-Shuffle-an-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/10/11/384-Shuffle-an-Array/","excerpt":"","text":"Corner Case： 就是记得update original 给它新给一个区间段的值， 要不然其实两个指针指向的是同一个object 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def __init__(self, nums): \"\"\" :type nums: List[int] \"\"\" self.array = nums # 这里一定要给original 要新给一个值， 要不然其实array， original指向的是同一个object self.original = list(nums) def reset(self): \"\"\" Resets the array to its original configuration and return it. :rtype: List[int] \"\"\" self.array = self.original self.original = list(self.original) return self.array def shuffle(self): \"\"\" Returns a random shuffling of the array. :rtype: List[int] \"\"\" for i in range(len(self.array)): swap_idx = random.randrange(i, len(self.array)) self.array[i], self.array[swap_idx] = self.array[swap_idx], self.array[i] return self.array# Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.reset()# param_2 = obj.shuffle()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Fisher-Yates Shuffle算法","slug":"Fisher-Yates-Shuffle算法","date":"2020-10-11T21:09:15.000Z","updated":"2020-10-11T21:35:08.050Z","comments":true,"path":"2020/10/11/Fisher-Yates-Shuffle算法/","link":"","permalink":"https://jojoyang666.github.io/2020/10/11/Fisher-Yates-Shuffle%E7%AE%97%E6%B3%95/","excerpt":"","text":"高效和等概率的洗牌算法 一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。 核心思想 从1到n之间随机出一个数和最后一个数n交换 从1到n-1之间随机出一个数和倒数第二个数n-1交换","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"437. Path Sum III","slug":"437-Path-Sum-III","date":"2020-10-11T20:25:02.000Z","updated":"2020-10-11T20:30:11.943Z","comments":true,"path":"2020/10/11/437-Path-Sum-III/","link":"","permalink":"https://jojoyang666.github.io/2020/10/11/437-Path-Sum-III/","excerpt":"","text":"Prefix Sum currPathSum: 表示sum of vals from root node to cur node oldPathSum = currPathSum - target, 在cache里面找到值为oldPathSum 有多少个也就说明了， sum 为target的有多少个 迭代完后不要忘记-1， 说明到了另外的branch， 别的branch是不会考虑当前node的值的 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def pathSum(self, root, sum): \"\"\" :type root: TreeNode :type sum: int :rtype: int \"\"\" cache = collections.defaultdict(int) cache[0] = 1 self.result = 0 self.dfs(root, sum, 0, cache) return self.result def dfs(self, node, target, currPathSum, cache): if not node: return currPathSum += node.val oldPathSum = currPathSum - target self.result += cache[oldPathSum] cache[currPathSum] += 1 self.dfs(node.left, target, currPathSum, cache) self.dfs(node.right, target, currPathSum, cache) cache[currPathSum] -= 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"735. Asteroid Collision","slug":"735-Asteroid-Collision","date":"2020-10-11T19:24:52.000Z","updated":"2020-10-11T19:25:36.199Z","comments":true,"path":"2020/10/11/735-Asteroid-Collision/","link":"","permalink":"https://jojoyang666.github.io/2020/10/11/735-Asteroid-Collision/","excerpt":"","text":"while ... else statement in python 12345678910111213141516171819class Solution(object): def asteroidCollision(self, asteroids): \"\"\" :type asteroids: List[int] :rtype: List[int] \"\"\" stack = [] for asteroid in asteroids: while stack and asteroid &lt; 0 &lt; stack[-1]: if -asteroid &gt; stack[-1]: stack.pop() continue elif -asteroid == stack[-1]: stack.pop() break else: stack.append(asteroid) return stack","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1029. Two City Scheduling","slug":"1029-Two-City-Scheduling","date":"2020-10-11T05:04:14.000Z","updated":"2020-10-11T05:35:29.647Z","comments":true,"path":"2020/10/10/1029-Two-City-Scheduling/","link":"","permalink":"https://jojoyang666.github.io/2020/10/10/1029-Two-City-Scheduling/","excerpt":"","text":"Greedy problems usually look like “Find minimum number of something to do something” or “Find maximum number of something to fit in some conditions”, and typically propose an unsorted input. The idea of greedy algorithm is to pick the locally optimal move at each step, that will lead to the globally optimal solution. IDEA: The problem is to send n persons to city A and n persons to city B with minimum cost. The idea is to send each person to city A. costs = [[10,20],[30,200],[400,50],[30,20]] So, totalCost = 10 + 30 + 400 + 30 = 470 Now, we need to send n persons to city B. Which persons do we need to send city B? Here, we need to minimize the cost. We have already paid money to go to city A.So, Send the persons to city B who get more refund so that our cost will be minimized.So, maintain refunds of each personrefund[i] = cost[i][1] - cost[i][0] So, refunds of each person refund = [10, 170, -350, -10] Here, refund +ve means we need to pay -ve means we will get refund. So, sort the refund array. refund = [-350, -10, 10, 170] Now, get refund for N persons, totalCost += 470 + -350 + -10 = 110 So minimum cost is 110 12345678910111213class Solution(object): def twoCitySchedCost(self, costs): \"\"\" :type costs: List[List[int]] :rtype: int \"\"\" costs.sort(key = lambda x : x[0] - x[1]) total = 0 n = len(costs)/2 for i in range(n): total += costs[i][0] + costs[i + n][1] return total x[0] - x[1] 负数代表， 这些人应该去A， 因为相当于所有人都去了B， 然后从里面选出n个人去A， 那么就是能拿到refund的人去A 也就是负数","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"934. Shortest Bridge","slug":"934-Shortest-Bridge","date":"2020-10-11T04:41:58.000Z","updated":"2020-10-11T04:53:14.603Z","comments":true,"path":"2020/10/10/934-Shortest-Bridge/","link":"","permalink":"https://jojoyang666.github.io/2020/10/10/934-Shortest-Bridge/","excerpt":"","text":"找到一个岛的所有的点后同时向外扩张（BFS） 12345678910111213141516171819202122232425262728293031323334class Solution(object): def shortestBridge(self, A): \"\"\" :type A: List[List[int]] :rtype: int \"\"\" res, step, bfs = 0, 0, deque([]) def dfs(i, j): A[i][j] = -1 bfs.append((i, j)) for x, y in ((1, 0), (-1, 0), (0, 1), (0, -1)): if 0&lt;= i + x &lt; len(A) and 0 &lt;= j + y &lt; len(A[0]) and A[i+x][j+y] == 1: dfs(i+x, j+y) def find(): for i in range(len(A)): for j in range(len(A[0])): if A[i][j]: return i, j dfs(*find()) while bfs: for i in range(len(bfs)): i, j = bfs.popleft() for x, y in ((1, 0), (-1, 0), (0, 1), (0, -1)): if 0&lt;= i + x &lt; len(A) and 0 &lt;= j + y &lt; len(A[0]): if A[i+x][j+y] == 1: return step elif not A[i+x][j+y]: bfs.append((i+x, j+y)) A[i+x][j+y] = -1 step += 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"430. Flatten a Multilevel Doubly Linked List","slug":"430-Flatten-a-Multilevel-Doubly-Linked-List","date":"2020-10-11T04:12:08.000Z","updated":"2020-10-11T04:20:24.167Z","comments":true,"path":"2020/10/10/430-Flatten-a-Multilevel-Doubly-Linked-List/","link":"","permalink":"https://jojoyang666.github.io/2020/10/10/430-Flatten-a-Multilevel-Doubly-Linked-List/","excerpt":"","text":"DFS Recursive12345678910111213141516171819202122232425262728293031323334\"\"\"# Definition for a Node.class Node(object): def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child\"\"\"class Solution(object): def flatten(self, head): \"\"\" :type head: Node :rtype: Node \"\"\" if not head: return head dummy = Node(None, None, head, None) self.flatten_dfs(dummy, head) dummy.next.prev = None return dummy.next def flatten_dfs(self, prev, curr): if not curr: return prev curr.prev = prev prev.next = curr tmpNext = curr.next tail = self.flatten_dfs(curr, curr.child) curr.child = None return self.flatten_dfs(tail, tmpNext) DFS + Iterative123456789101112131415161718192021222324252627282930313233343536373839\"\"\"# Definition for a Node.class Node(object): def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child\"\"\"class Solution(object): def flatten(self, head): \"\"\" :type head: Node :rtype: Node \"\"\" if not head: return dummy = Node(None, None, head, None) stack = [head] prev = dummy while stack: curr = stack.pop() if curr.next: stack.append(curr.next) curr.next = None if curr.child: stack.append(curr.child) curr.child = None prev.next = curr curr.prev = prev prev = curr dummy.next.prev = None return dummy.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"309. Best Time to Buy and Sell Stock with Cooldown","slug":"309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown","date":"2020-10-11T03:16:35.000Z","updated":"2020-10-11T03:55:50.935Z","comments":true,"path":"2020/10/10/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/","link":"","permalink":"https://jojoyang666.github.io/2020/10/10/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/","excerpt":"","text":"1234567891011121314class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" sold, held, reset = float('-inf'), float('-inf'), 0 for price in prices: pre_sold = sold sold = held + price held = max(held, reset - price) reset = max(reset, pre_sold) return max(sold, reset)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","slug":"1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays","date":"2020-10-11T02:35:51.000Z","updated":"2020-10-11T03:01:57.511Z","comments":true,"path":"2020/10/10/1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays/","link":"","permalink":"https://jojoyang666.github.io/2020/10/10/1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays/","excerpt":"","text":"12345678910111213141516171819class Solution(object): def maxSumTwoNoOverlap(self, A, L, M): \"\"\" :type A: List[int] :type L: int :type M: int :rtype: int \"\"\" for i in range(1, len(A)): A[i] += A[i-1] res, Lmax, Mmax = A[L + M - 1], A[L-1], A[M-1] for i in range(L + M, len(A)): Lmax = max(Lmax, A[i - M] - A[i - M - L]) Mmax = max(Mmax, A[i - L] - A[i - M - L]) res = max(res, Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"120. Triangle","slug":"120-Triangle","date":"2020-10-11T01:54:57.000Z","updated":"2020-10-11T02:08:47.684Z","comments":true,"path":"2020/10/10/120-Triangle/","link":"","permalink":"https://jojoyang666.github.io/2020/10/10/120-Triangle/","excerpt":"","text":"123456789101112class Solution(object): def minimumTotal(self, triangle): \"\"\" :type triangle: List[List[int]] :rtype: int \"\"\" dp = triangle[-1] for i in xrange(len(triangle)-2, -1, -1): for j in xrange(len(triangle[i])): dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] return dp[0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"698. Partition to K Equal Sum Subsets","slug":"698-Partition-to-K-Equal-Sum-Subsets","date":"2020-10-10T18:16:45.000Z","updated":"2020-10-10T19:11:20.540Z","comments":true,"path":"2020/10/10/698-Partition-to-K-Equal-Sum-Subsets/","link":"","permalink":"https://jojoyang666.github.io/2020/10/10/698-Partition-to-K-Equal-Sum-Subsets/","excerpt":"","text":"Solution 1Brute Force: Backtracking 几个加速的key point: backtracking 的时候倒序 加入数字， 也就是先考虑最大的值， 这样会减小subset的size 降低recursive的次数 加入if not group: break的判断， 当前group开始是0， 通过这种方式recursive 并没有找到结果， 那么这个group的下一个group开始也是0， 同样的recursive再走一遍 肯定是依旧找不到结果的 所以避免repeat的操作 123456789101112131415161718192021222324252627282930313233class Solution(object): def canPartitionKSubsets(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: bool \"\"\" target, rem = divmod(sum(nums), k) if rem: return False def search(groups): if not nums: return True v = nums.pop() for i, group in enumerate(groups): # print group, groups if group + v &lt;= target: groups[i] += v if search(groups): return True groups[i] -= v if not group: break nums.append(v) return False nums.sort() if nums[-1] &gt; target: return False while nums and nums[-1] == target: nums.pop() k -= 1 return search([0] * k)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"368. Largest Divisible Subset","slug":"368-Largest-Divisible-Subset","date":"2020-10-10T16:34:59.000Z","updated":"2020-10-10T17:40:05.630Z","comments":true,"path":"2020/10/10/368-Largest-Divisible-Subset/","link":"","permalink":"https://jojoyang666.github.io/2020/10/10/368-Largest-Divisible-Subset/","excerpt":"","text":"DP Si % Sj = 0 or Sj % Si = 0. 对于这个条件我们要判断谁大谁小比较难/复杂， 所以我们要对原数组排序， 这样只用考虑后面大的值 用DP解决， dp[i] = set() &lt;- b set b是所有i能整除的数即i%b == 0, 那么一个新数m%i == 0,肯定会有m%b == 0 1234567891011class Solution(object): def largestDivisibleSubset(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" subsets = &#123;-1: set()&#125; for num in sorted(nums): subsets[num] = max([subsets[k] for k in subsets if num%k == 0], key=len) | &#123;num&#125; return list(max(subsets.values(), key=len)) DP with Reduced Space 在法一中， 时间和空间复杂度都是n*n 现在想降低空间复杂度到O(n) dp[i], 表示到nums[i]的最长的subset的长度 然后找到dp中最大的长度， 和结尾的subset的值 倒着遍历dp数组最后， 来一个个找到合适的值123456789101112131415161718192021222324252627class Solution(object): def largestDivisibleSubset(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" if len(nums) == 0: return [] nums.sort() dp = [0] * (len(nums)) for i, num in enumerate(nums): maxSubsetSize = 0 for k in range(0, i): if nums[i] % nums[k] == 0: maxSubsetSize = max(maxSubsetSize, dp[k]) maxSubsetSize += 1 dp[i] = maxSubsetSize maxSize, maxSizeIndex = max([(v, i) for i, v in enumerate(dp)]) ret = [] currSize, currTail = maxSize, nums[maxSizeIndex] for i in range(maxSizeIndex, -1, -1): if currSize == dp[i] and currTail%nums[i] == 0: ret.append(nums[i]) currSize -= 1 currTail = nums[i] return reversed(ret)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"86. Partition List","slug":"86-Partition-List","date":"2020-10-09T22:52:51.000Z","updated":"2020-10-09T22:54:41.704Z","comments":true,"path":"2020/10/09/86-Partition-List/","link":"","permalink":"https://jojoyang666.github.io/2020/10/09/86-Partition-List/","excerpt":"","text":"123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def partition(self, head, x): \"\"\" :type head: ListNode :type x: int :rtype: ListNode \"\"\" before = before_head = ListNode(None) after = after_head = ListNode(None) while head: if head.val &lt; x: before.next = head before = before.next else: after.next = head after= after.next head = head.next after.next = None #Cornor Case: 这个一定要设置为None， 因为如果不改的话可能会有环， 因为这个next的node可能是源list里面的某个node before.next = after_head.next return before_head.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1344. Angle Between Hands of a Clock","slug":"1344-Angle-Between-Hands-of-a-Clock","date":"2020-10-09T22:19:48.000Z","updated":"2020-10-09T22:35:28.619Z","comments":true,"path":"2020/10/09/1344-Angle-Between-Hands-of-a-Clock/","link":"","permalink":"https://jojoyang666.github.io/2020/10/09/1344-Angle-Between-Hands-of-a-Clock/","excerpt":"","text":"MathIt is a math problem 123456789101112131415class Solution(object): def angleClock(self, hour, minutes): \"\"\" :type hour: int :type minutes: int :rtype: float \"\"\" one_minute_angel = 6 one_hour_angel = 30 minutes_angel = minutes * one_minute_angel hour_angel = (hour + float(minutes)/60) * one_hour_angel diff = abs(hour_angel - minutes_angel) # print diff return min(diff, 360 - diff)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"24. Swap Nodes in Pairs","slug":"24-Swap-Nodes-in-Pairs","date":"2020-10-09T21:52:35.000Z","updated":"2020-10-09T22:20:05.167Z","comments":true,"path":"2020/10/09/24-Swap-Nodes-in-Pairs/","link":"","permalink":"https://jojoyang666.github.io/2020/10/09/24-Swap-Nodes-in-Pairs/","excerpt":"","text":"Recursive 凡事有重复逻辑操作，并且 一些结果 要由 其他的重复操作的结果来完成， 那么就可以用recursive的方法来解决 重点：触底条件， 也就是base case 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head or not head.next: return head first = head second = head.next first.next = self.swapPairs(second.next) second.next = first return second Iterative123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" dummy = ListNode(None) dummy.next = head prev_node = dummy while head and head.next: first_node = head second_node = head.next prev_node.next = second_node first_node.next = second_node.next second_node.next = first_node prev_node = first_node head = first_node.next return dummy.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"540. Single Element in a Sorted Array","slug":"540-Single-Element-in-a-Sorted-Array","date":"2020-10-09T04:59:54.000Z","updated":"2020-10-09T21:38:35.800Z","comments":true,"path":"2020/10/08/540-Single-Element-in-a-Sorted-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/10/08/540-Single-Element-in-a-Sorted-Array/","excerpt":"","text":"BST12345678910111213141516171819202122232425class Solution(object): def singleNonDuplicate(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" low, high = 0, len(nums) - 1 while low &lt; high: mid = low + (high - low)/2 halves_are_even = (high - mid) % 2 == 0 if nums[mid + 1] == nums[mid]: #这里不可能越界 if halves_are_even: low = mid + 2 else: high = mid - 1 elif nums[mid - 1] == nums[mid]: #这里不可能越界 if halves_are_even: high = mid - 2 else: low = mid + 1 else: return nums[mid] return nums[low] BST on even indexes onlyreduce the number of condition check 123456789101112131415161718class Solution(object): def singleNonDuplicate(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" low, high = 0, len(nums) - 1 while low &lt; high: mid = low + (high - low)//2 if mid%2 == 1: mid -= 1 if nums[mid] == nums[mid + 1]: low = mid + 2 else: high = mid return nums[high]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"402. Remove K Digits","slug":"402-Remove-K-Digits","date":"2020-10-09T04:03:02.000Z","updated":"2020-10-09T04:21:55.837Z","comments":true,"path":"2020/10/08/402-Remove-K-Digits/","link":"","permalink":"https://jojoyang666.github.io/2020/10/08/402-Remove-K-Digits/","excerpt":"","text":"Greedy + Stack maintain one stack, the result would be the join the value in the stack should maintain a increasing stack cornor case 1, after tranverse the string, k is still there, we should truncate the last remaining chars cornor case 2, do not forget to remove the leading zero solve the conflict between 大小和位置的问题1234567891011121314151617class Solution(object): def removeKdigits(self, num, k): \"\"\" :type num: str :type k: int :rtype: str \"\"\" numStack = [] for digit in num: while k and numStack and numStack[-1] &gt; digit: numStack.pop() k -= 1 numStack.append(digit) finalStack = numStack[:-k] if k else numStack return \"\".join(finalStack).lstrip(\"0\") or \"0\"","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"526. Beautiful Arrangement","slug":"526-Beautiful-Arrangement","date":"2020-10-08T19:14:18.000Z","updated":"2020-10-09T04:03:22.096Z","comments":true,"path":"2020/10/08/526-Beautiful-Arrangement/","link":"","permalink":"https://jojoyang666.github.io/2020/10/08/526-Beautiful-Arrangement/","excerpt":"","text":"Backtracking1234567891011121314151617181920class Solution(object): def countArrangement(self, N): \"\"\" :type N: int :rtype: int \"\"\" return self.cal(1, N, 0, 0) def cal(self, pos, N, mask, count): if (pos &gt; N): count += 1 return count for i in xrange(1, N+1): if (not (mask &amp; 1 &lt;&lt; i)) and (pos % i == 0 or i % pos == 0): mask |= 1 &lt;&lt; i count = self.cal(pos+1, N, mask, count) mask &amp;= ~(1 &lt;&lt; i) return count 1234567891011121314151617181920class Solution(object): def countArrangement(self, N): \"\"\" :type N: int :rtype: int \"\"\" return self.cal(1, N, set(), 0) def cal(self, pos, N, seen, count): if (pos &gt; N): count += 1 return count for i in xrange(1, N+1): if i not in seen and (pos % i == 0 or i % pos == 0): seen.add(i) count = self.cal(pos+1, N, seen, count) seen.remove(i) return count DFS + Memo123456789101112131415161718class Solution(object): def countArrangement(self, N): \"\"\" :type N: int :rtype: int \"\"\" cache = &#123;&#125; def helper(i, X): if i == 1: return 1 key = i, X if key in cache: return cache[key] total = sum(helper(i-1, X[:j] + X[j+1:]) for j, x in enumerate(X) if x % i == 0 or i % x == 0) cache[key] = total return total return helper(N, tuple(range(1, N+1)))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"395. Longest Substring with At Least K Repeating Characters","slug":"395-Longest-Substring-with-At-Least-K-Repeating-Characters","date":"2020-10-08T17:22:40.000Z","updated":"2020-10-08T18:20:17.482Z","comments":true,"path":"2020/10/08/395-Longest-Substring-with-At-Least-K-Repeating-Characters/","link":"","permalink":"https://jojoyang666.github.io/2020/10/08/395-Longest-Substring-with-At-Least-K-Repeating-Characters/","excerpt":"","text":"Solution 1Recursive way, 当遍历到某个位置i, 如果s[i]在整个string中出现的次数少于k,那就可以分段考虑s[start:i], s[i+1:end]这两个分段中得到的结果取最大， 以这种recursive的方法解决他 12345678910111213141516171819class Solution(object): def longestSubstring(self, s, k): \"\"\" :type s: str :type k: int :rtype: int \"\"\" counter = collections.Counter(s) if all(counter[i] &gt;= k for i in counter): return len(s) start, longest = 0, 0 for i in xrange(len(s)): if counter[s[i]] &lt; k: longest = max(longest, self.longestSubstring(s[start:i], k)) start = i + 1 longest = max(longest, self.longestSubstring(s[start:], k)) return longest Solution 2Sliding window 找到s中所有独一无二的字符个数m， 以m作为界限在里面run sliding window 每一个循环/sliding window –&gt;循环m次 start end： sliding window的起点和终点 unique在当前sliding window中独一无二的字符数 uniqueK:在当前window中 有多少个字符出现的次数大于等于k 每一个循环中： 第ith循环, unique &lt;= i 当unique &lt;= i, expanding window, 更新unique, uniqueK unique &gt; i, shrinking window, 更新unique, uniqueK unique == i == uniqueK， 更新结果12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def longestSubstring(self, s, k): \"\"\" :type s: str :type k: int :rtype: int \"\"\" counter = collections.Counter(s) uniqchars = len([i for i in counter if counter[i] &gt;= k]) res = 0 for cur_uniqichars in xrange(1, uniqchars+1): start, end = 0, 0 unique, uniquecharsK = 0, 0 count_map = collections.defaultdict(int) while end &lt; len(s):# expanding the window if unique &lt;= cur_uniqichars: if count_map[s[end]] == 0: unique += 1 count_map[s[end]] += 1 if count_map[s[end]] == k: uniquecharsK += 1 end+=1 else:# shrink the window if count_map[s[start]] == k: uniquecharsK -= 1 count_map[s[start]] -= 1 if count_map[s[start]] == 0: unique -= 1 start += 1 if unique == cur_uniqichars and unique == uniquecharsK: res = max(res, end - start) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"12. Integer to Roman","slug":"12-Integer-to-Roman","date":"2020-10-08T16:01:28.000Z","updated":"2020-10-08T16:22:33.704Z","comments":true,"path":"2020/10/08/12-Integer-to-Roman/","link":"","permalink":"https://jojoyang666.github.io/2020/10/08/12-Integer-to-Roman/","excerpt":"","text":"Solution 1Greedy 123456789101112131415class Solution(object): def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\" digits = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")] roman_digits = [] for value, symbol in digits: if num == 0: break quot, num = divmod(num, value) roman_digits.append(quot * symbol) return \"\".join(roman_digits) Solution 2Hardcode Digits 123456789101112class Solution(object): def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\" thousands = [\"\", \"M\", \"MM\", \"MMM\"] hundreds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"] tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"] ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"] return thousands[num//1000] + hundreds[num%1000//100] + tens[num%100//10] + ones[num%10]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"909. Snakes and Ladders","slug":"909-Snakes-and-Ladders","date":"2020-10-08T15:53:07.000Z","updated":"2020-10-08T15:53:42.023Z","comments":true,"path":"2020/10/08/909-Snakes-and-Ladders/","link":"","permalink":"https://jojoyang666.github.io/2020/10/08/909-Snakes-and-Ladders/","excerpt":"","text":"Min steps –&gt; bfs not dfs 123456789101112131415161718192021222324252627282930class Solution(object): def snakesAndLadders(self, board): \"\"\" :type board: List[List[int]] :rtype: int \"\"\" N = len(board) def get(s): quot, rem = divmod(s-1, N) row = N - 1 - quot col = rem if not quot%2 else N - rem - 1 return row, col dist = &#123;1: 0&#125; queue = collections.deque([1]) while queue: s = queue.popleft() if s == N * N: return dist[s] for s2 in xrange(s+1, min(s+6, N*N)+1): r, c = get(s2) if board[r][c] != -1: s2 = board[r][c] if s2 not in dist: dist[s2] = dist[s] + 1 queue.append(s2) return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"443. String Compression","slug":"443-String-Compression","date":"2020-10-07T04:17:11.000Z","updated":"2020-10-07T04:36:41.950Z","comments":true,"path":"2020/10/06/443-String-Compression/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/443-String-Compression/","excerpt":"","text":"cornor case read -&gt; 当前读到哪儿 write -&gt; 当前写到哪儿 ancor -&gt; 连续字符的起点 -》会大于10所以记得同时更新write的值 1234567891011121314151617class Solution(object): def compress(self, chars): \"\"\" :type chars: List[str] :rtype: int \"\"\" anchor = write = 0 for read, c in enumerate(chars): if read + 1 == len(chars) or chars[read + 1] != c: chars[write] = chars[anchor] write += 1 if read &gt; anchor: for digit in str(read - anchor + 1): chars[write] = digit write += 1 anchor = read + 1 return write","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1152. Analyze User Website Visit Pattern","slug":"1152-Analyze-User-Website-Visit-Pattern","date":"2020-10-07T03:54:39.000Z","updated":"2020-10-07T04:02:10.293Z","comments":true,"path":"2020/10/06/1152-Analyze-User-Website-Visit-Pattern/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/1152-Analyze-User-Website-Visit-Pattern/","excerpt":"","text":"Using many built python functions 题目的意思： 找到sequence sequece: 是一个人按照时间顺序访问的website， 但是sequence 长度是3 返回是很多人都用过这个sequence， 如果次数相同就返回字母顺序上升12345678910111213141516171819class Solution(object): def mostVisitedPattern(self, username, timestamp, website): \"\"\" :type username: List[str] :type timestamp: List[int] :type website: List[str] :rtype: List[str] \"\"\" by_user = defaultdict(list) for time, user, web in sorted(zip(timestamp, username, website)): by_user[user].append(web) cnt = Counter() for sequence in by_user.values(): cnt += Counter(set(combinations(sequence, 3))) return min(cnt, key=lambda k: (-cnt[k], k))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"957. Prison Cells After N Days","slug":"957-Prison-Cells-After-N-Days","date":"2020-10-07T03:16:56.000Z","updated":"2020-10-07T03:55:00.626Z","comments":true,"path":"2020/10/06/957-Prison-Cells-After-N-Days/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/957-Prison-Cells-After-N-Days/","excerpt":"","text":"Fast-forward直觉 这个题目会有周期 -》 hashmap来找到这个周期 1234567891011121314151617class Solution(object): def prisonAfterNDays(self, cells, N): \"\"\" :type cells: List[int] :type N: int :rtype: List[int] \"\"\" seen = &#123;&#125; while N: seen.setdefault(str(cells), N) N -= 1 cells = [0] + [cells[i-1] ^ cells[i+1] ^ 1 for i in range(1, len(cells)-1)] + [0] if str(cells) in seen: N %= (seen[str(cells)] - N) return cells","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"974. Subarray Sums Divisible by K","slug":"974-Subarray-Sums-Divisible-by-K","date":"2020-10-07T02:37:23.000Z","updated":"2020-10-07T02:45:42.051Z","comments":true,"path":"2020/10/06/974-Subarray-Sums-Divisible-by-K/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/974-Subarray-Sums-Divisible-by-K/","excerpt":"","text":"Cornor case: 开始要给P给0， for the case: a single num is equal to the K p(i) = sum(A[0],…, A[i])%k 这样在拿到dict: key is p(i), value: account of p(i), 也就是说有相同余数的， 他们一减 就可以拿到一个(sum of sub array )/k = 0 有多少种这个情况呢吗就是 在count 中取2个， 他们一减就可以拿到一个subarray – v*(v-1)/2个subarray12345678class Solution(object): def subarraysDivByK(self, A, K): P = [0] for x in A: P.append((P[-1] + x) % K) count = collections.Counter(P) return sum(v*(v-1)/2 for v in count.values())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1209. Remove All Adjacent Duplicates in String II","slug":"1209-Remove-All-Adjacent-Duplicates-in-String-II","date":"2020-10-06T23:40:04.000Z","updated":"2020-10-06T23:43:49.884Z","comments":true,"path":"2020/10/06/1209-Remove-All-Adjacent-Duplicates-in-String-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/1209-Remove-All-Adjacent-Duplicates-in-String-II/","excerpt":"","text":"涉及到后进来/后处理的中间值， 可以最后拿到结果的话， 就可以用stack 1234567891011121314151617class Solution(object): def removeDuplicates(self, s, k): \"\"\" :type s: str :type k: int :rtype: str \"\"\" stack = [['#', 0]] for j, c in enumerate(s): if stack[-1][0] == c: stack[-1][1] += 1 else: stack.append([c, 1]) if stack[-1][1] == k: stack.pop() return ''.join(c * cnt for c, cnt in stack)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"55. Jump Game","slug":"55-Jump-Game","date":"2020-10-06T23:13:47.000Z","updated":"2020-10-06T23:14:18.453Z","comments":true,"path":"2020/10/06/55-Jump-Game/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/55-Jump-Game/","excerpt":"","text":"Greedy 1234567891011121314class Solution(object): def canJump(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" m = nums[0] for i, num in enumerate(nums): if i &lt;= m: m = max(m, i + num) else: return False return m &gt;= len(nums)-1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"96. Unique Binary Search Trees","slug":"96-Unique-Binary-Search-Trees","date":"2020-10-06T23:01:49.000Z","updated":"2020-10-06T23:02:41.201Z","comments":true,"path":"2020/10/06/96-Unique-Binary-Search-Trees/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/96-Unique-Binary-Search-Trees/","excerpt":"","text":"n = 2dp[2] = dp[0] * dp[1] (1为根的情况，则左子树一定不存在，右子树可以有一个数字) dp[1] * dp[0] (2为根的情况，则左子树可以有一个数字，右子树一定不存在) 同理可写出 n = 3 的计算方法： dp[3] = dp[0] * dp[2] (1为根的情况，则左子树一定不存在，右子树可以有两个数字) + dp[1] * dp[1] (2为根的情况，则左右子树都可以各有一个数字) + dp[2] * dp[0] (3为根的情况，则左子树可以有两个数字，右子树一定不存在) 12345678910111213class Solution(object): def numTrees(self, n): \"\"\" :type n: int :rtype: int \"\"\" dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]","categories":[],"tags":[]},{"title":"19. Remove Nth Node From End of List","slug":"19-Remove-Nth-Node-From-End-of-List","date":"2020-10-06T21:59:05.000Z","updated":"2020-10-06T22:22:00.276Z","comments":true,"path":"2020/10/06/19-Remove-Nth-Node-From-End-of-List/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/19-Remove-Nth-Node-From-End-of-List/","excerpt":"","text":"one pass means two pointers will be one option 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" dummy = ListNode(None) dummy.next = head first = dummy second = dummy for i in range(n + 1): first = first.next while first: first = first.next second = second.next second.next = second.next.next return dummy.next","categories":[],"tags":[]},{"title":"210. Course Schedule II","slug":"210-Course-Schedule-II","date":"2020-10-06T21:47:06.000Z","updated":"2020-10-06T21:51:09.792Z","comments":true,"path":"2020/10/06/210-Course-Schedule-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/210-Course-Schedule-II/","excerpt":"","text":"不能用这个题目 207. Course Schedule 里面的方法是因为， 这个是用来判断是否存在环的， 也就是说如果里面有若干个独立节点是返回true，但是不知道这个独立节点是谁， 而本题是要图没有环的同时还没有独立节点， 所以要通过知道所有节点的方式来找到入度为0的节点 12345678910111213141516171819202122232425262728class Solution(object): def findOrder(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] \"\"\" adj_list = defaultdict(list) indegree = &#123;&#125; for dest, src in prerequisites: adj_list[src].append(dest) indegree[dest] = indegree.get(dest, 0) + 1 zero_indegree_queue = [k for k in range(numCourses) if k not in indegree] topological_sorted_order = [] while zero_indegree_queue: v = zero_indegree_queue.pop() topological_sorted_order.append(v) if v in adj_list: for nei in adj_list[v]: indegree[nei] -= 1 if indegree[nei] == 0: zero_indegree_queue.append(nei) return topological_sorted_order if len(topological_sorted_order) == numCourses else []","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"207. Course Schedule","slug":"207-Course-Schedule","date":"2020-10-06T16:58:42.000Z","updated":"2020-10-06T16:59:10.353Z","comments":true,"path":"2020/10/06/207-Course-Schedule/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/207-Course-Schedule/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839class GNode(object): def __init__(self): self.inDegrees = 0 self.outNodes = [] class Solution(object): def canFinish(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool \"\"\" graph = defaultdict(GNode) totalDeps = 0 for relation in prerequisites: nextCourse, prevCourse = relation[0], relation[1] graph[prevCourse].outNodes.append(nextCourse) graph[nextCourse].inDegrees += 1 totalDeps += 1 nodeCourses = [] for course, node in graph.items(): if node.inDegrees == 0: nodeCourses.append(course) removedEdges = 0 while nodeCourses: course = nodeCourses.pop() for nextCourse in graph[course].outNodes: graph[nextCourse].inDegrees -= 1 removedEdges += 1 if graph[nextCourse].inDegrees == 0: nodeCourses.append(nextCourse) return True if removedEdges == totalDeps else False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"103. Binary Tree Zigzag Level Order Traversal","slug":"103-Binary-Tree-Zigzag-Level-Order-Traversal","date":"2020-10-06T16:07:34.000Z","updated":"2020-10-06T16:39:14.071Z","comments":true,"path":"2020/10/06/103-Binary-Tree-Zigzag-Level-Order-Traversal/","link":"","permalink":"https://jojoyang666.github.io/2020/10/06/103-Binary-Tree-Zigzag-Level-Order-Traversal/","excerpt":"","text":"Solution 1BFS + reverse the level array according to the condition 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def zigzagLevelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if not root: return [] queue = deque([root]) result, direction = [], 1 while queue: level = [] for i in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level[::direction]) direction *= -1 return result Solution 2BFS + put the value according to the idx, 如果要reverse的情况， 那么实际的位置是在size - 1 - i 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def zigzagLevelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if not root: return [] queue = deque([root]) result, reverse_direction = [], False while queue: size = len(queue) level = [0] * size for i in range(size): node = queue.popleft() idx = size - i - 1 if reverse_direction else i level[idx] = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) reverse_direction = not reverse_direction return result``` # Solution 3DFS1. 取出 res[level] 之后，判断 levle 的奇偶 * 若其为偶数，则将 node-&gt;val 加入 oneLevel 的末尾 * 若为奇数，则加在 oneLevel 的开头```Python# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def zigzagLevelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" res = [] self.dfs(root, 0, res) return res def dfs(self, node, level, res): if not node: return if level == len(res): res.append(deque([])) if level &amp; 1: res[level].appendleft(node.val) else: res[level].append(node.val) self.dfs(node.left, level + 1, res) self.dfs(node.right, level+1, res)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1428. Leftmost Column with at Least a One","slug":"1428-Leftmost-Column-with-at-Least-a-One","date":"2020-10-06T03:47:22.000Z","updated":"2020-10-06T03:49:41.223Z","comments":true,"path":"2020/10/05/1428-Leftmost-Column-with-at-Least-a-One/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/1428-Leftmost-Column-with-at-Least-a-One/","excerpt":"","text":"有点儿two pointer的感觉， 矩阵问题 可以考虑类似这种操作方式来将时间复杂度变成O(m + n) —&gt; 找到范围， 通过一些条件， 来慢慢排除一些值，最后确定一个最终的值 1234567891011121314151617181920212223242526272829303132# \"\"\"# This is BinaryMatrix's API interface.# You should not implement it, or speculate about its implementation# \"\"\"#class BinaryMatrix(object):# def get(self, row, col):# \"\"\"# :type row : int, col : int# :rtype int# \"\"\"## def dimensions:# \"\"\"# :rtype list[]# \"\"\"class Solution(object): def leftMostColumnWithOne(self, binaryMatrix): \"\"\" :type binaryMatrix: BinaryMatrix :rtype: int \"\"\" rows, cols = binaryMatrix.dimensions() cur_row, cur_col = 0, cols - 1 while cur_row &lt; rows and cur_col &gt;= 0: if binaryMatrix.get(cur_row, cur_col) == 0: cur_row += 1 else: cur_col -= 1 return cur_col + 1 if cur_col != cols - 1 else -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"547. Friend Circles","slug":"547-Friend-Circles","date":"2020-10-06T03:01:29.000Z","updated":"2020-10-08T04:31:45.864Z","comments":true,"path":"2020/10/05/547-Friend-Circles/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/547-Friend-Circles/","excerpt":"","text":"Union Find 123456789101112131415161718192021222324252627282930class DSU: def __init__(self, N): self.parent = range(N) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): self.parent[self.find(x)] = self.find(y) class Solution(object): def findCircleNum(self, M): \"\"\" :type M: List[List[int]] :rtype: int \"\"\" n, res = len(M), 0 dsu = DSU(n) for i in range(n): for j in range(n): if M[i][j]: dsu.union(i, j) for i in range(n): if i == dsu.find(i): res += 1 return res 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;number[][]&#125; M * @return &#123;number&#125; */var findCircleNum = function(M) &#123; const n = M.length const parent = [...new Array(n)].map((item, idx) =&gt; idx) for (let i = 0; i &lt; n; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (M[i][j]) &#123; union(parent, i, j) &#125; &#125; &#125; let res = 0 parent.forEach((item, idx) =&gt; &#123; res += item === idx ? 1 : 0 &#125;) return res&#125;;const find = (parent, i) =&gt; &#123; if (parent[i] != i) parent[i] = find(parent, parent[i]) return parent[i]&#125;const union = (parent, x, y) =&gt; &#123; const xr = find(parent, x) const yr = find(parent, y) parent[xr] = yr&#125; Union Find With Rank 12345678910111213141516171819202122232425262728293031323334353637383940class DSU: def __init__(self, N): self.parent = range(N) self.rank = [0] * N def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): xr, yr = self.find(x), self.find(y) if xr != yr: if self.rank[xr] &lt; self.rank[yr]: self.parent[xr] = yr elif self.rank[xr] &gt; self.rank[yr]: self.parent[yr] = xr else: self.parent[yr] = xr self.rank[xr]+=1 class Solution(object): def findCircleNum(self, M): \"\"\" :type M: List[List[int]] :rtype: int \"\"\" n, res = len(M), 0 dsu = DSU(n) for i in range(n): for j in range(n): if M[i][j]: dsu.union(i, j) for i in range(n): if i == dsu.find(i): res += 1 return res 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param &#123;number[][]&#125; M * @return &#123;number&#125; */var findCircleNum = function(M) &#123; const n = M.length const parent = [...new Array(n)].map((item, idx) =&gt; idx) const rank = [...new Array(n)].fill(0) for (let i = 0; i &lt; n; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (M[i][j]) &#123; union(parent, rank, i, j) &#125; &#125; &#125; let res = 0 parent.forEach((item, idx) =&gt; &#123; res += item === idx ? 1 : 0 &#125;) return res&#125;;const find = (parent, i) =&gt; &#123; if (parent[i] != i) parent[i] = find(parent, parent[i]) return parent[i]&#125;const union = (parent, rank, x, y) =&gt; &#123; const xr = find(parent, x) const yr = find(parent, y) if (xr !== yr) &#123;//这个判断不能忘 if (rank[xr] &lt; rank[yr]) &#123; parent[xr] = yr &#125; else if (rank[xr] &gt; rank[yr]) &#123; parent[yr] = xr &#125; else &#123; parent[yr] = xr rank[xr] += 1 &#125; &#125;&#125; DFS 12345678910111213141516class Solution(object): def findCircleNum(self, A): N = len(A) seen = set() def dfs(node): for nei, adj in enumerate(A[node]): if adj and nei not in seen: seen.add(nei) dfs(nei) ans = 0 for i in xrange(N): if i not in seen: dfs(i) ans += 1 return ans 12345678910111213141516171819202122232425/** * @param &#123;number[][]&#125; M * @return &#123;number&#125; */var findCircleNum = function(M) &#123; const seen = new Set() let ans = 0 for (let i = 0; i &lt; M.length; i++) &#123; if (!seen.has(i)) &#123; ans += 1 dfs(seen, M, i) &#125; &#125; return ans&#125;;const dfs = (seen, M, i) =&gt; &#123; M[i].forEach((num, idx) =&gt; &#123; if (num &amp;&amp; !seen.has(idx)) &#123; seen.add(idx) dfs(seen, M, idx) &#125; &#125;)&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"131. Palindrome Partitioning","slug":"131-Palindrome-Partitioning","date":"2020-10-06T00:44:58.000Z","updated":"2020-10-08T03:16:41.764Z","comments":true,"path":"2020/10/05/131-Palindrome-Partitioning/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/131-Palindrome-Partitioning/","excerpt":"","text":"12345678910111213141516171819202122class Solution(object): def partition(self, s): \"\"\" :type s: str :rtype: List[List[str]] \"\"\" res = [] self.dfs(s, [], res) return res def dfs(self, s, path, res): if not s: res.append(path) return # range是1， 到len(s) --&gt; included for i in range(1, len(s)+1): if self.is_palindrome(s[:i]): self.dfs(s[i:], path + [s[:i]], res) def is_palindrome(self, s): return s[::-1] == s 12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;string&#125; s * @return &#123;string[][]&#125; */var partition = function(s) &#123; const res = [] backtracking(s, [], res) return res&#125;;const backtracking = (s, cur, res) =&gt; &#123; if (!s) &#123; if (cur.length) res.push([...cur]) return &#125; for (let i = 0; i &lt; s.length; i++) &#123; if (isPali(s, 0, i)) &#123; cur.push(s.substring(0, i+1)) backtracking(s.substring(i+1), cur, res) cur.pop() &#125; &#125;&#125;const isPali = (s, start, end) =&gt; &#123; while (start &lt; end) &#123; if (s.charAt(start) === s.charAt(end)) &#123; start++; end-- &#125; else &#123; return false &#125; &#125; return true&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"148. Sort List","slug":"148-Sort-List","date":"2020-10-05T22:38:57.000Z","updated":"2020-10-05T22:39:36.045Z","comments":true,"path":"2020/10/05/148-Sort-List/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/148-Sort-List/","excerpt":"","text":"Merge Sort 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def sortList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head or not head.next: return head prev, slow, fast = None, head, head while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next prev.next = None return self.merge(*map(self.sortList, (head, slow))) def merge(self, l1, l2): dummy = tail = ListNode(None) while l1 and l2: if l1.val &lt; l2.val: tail.next, l1 = l1, l1.next else: tail.next, l2 = l2, l2.next tail = tail.next tail.next = l1 or l2 return dummy.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"518. Coin Change 2","slug":"518-Coin-Change-2","date":"2020-10-05T22:03:44.000Z","updated":"2020-10-08T03:36:16.178Z","comments":true,"path":"2020/10/05/518-Coin-Change-2/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/518-Coin-Change-2/","excerpt":"","text":"1234567891011121314class Solution(object): def change(self, amount, coins): \"\"\" :type amount: int :type coins: List[int] :rtype: int \"\"\" dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for x in xrange(coin, amount + 1): dp[x] += dp[x - coin] return dp[-1] 1234567891011var change = function(amount, coins) &#123; const dp = new Array(amount + 1).fill(0) dp[0] = 1 for (const coin of coins) &#123; for (let i = 1; i &lt;= amount; i++) &#123; if (i &gt;= coin) dp[i] += dp[i-coin]//注意这个没有+1 &#125; &#125; return dp[amount]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"445. Add Two Numbers II","slug":"445-Add-Two-Numbers-II","date":"2020-10-05T16:29:26.000Z","updated":"2020-10-08T03:04:44.075Z","comments":true,"path":"2020/10/05/445-Add-Two-Numbers-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/445-Add-Two-Numbers-II/","excerpt":"","text":"这个题目可以发现要走到最后才能算出， 然后根据后面的值 一步步往前传递得到前面的值递归的特点， 所以要用递归同时递归说明了可以用stack来做 Solution 1Stack 12345678910111213141516171819202122232425262728293031323334# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" stack1, stack2 = [], [] while l1: stack1.append(l1.val) l1 = l1.next while l2: stack2.append(l2.val) l2 = l2.next res = ListNode(0) s = 0 while stack1 or stack2: if stack1: s += stack1.pop() if stack2: s += stack2.pop() res.val = s%10 head = ListNode(s/10) head.next = res res = head s = s/10 return res if res.val != 0 else res.next 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; const s1 = [], s2 = [] while (l1) &#123; s1.push(l1.val) l1 = l1.next &#125; while (l2) &#123; s2.push(l2.val) l2 = l2.next &#125; let res = new ListNode(0) while (s1.length || s2.length) &#123; let val = res.val if (s1.length) &#123; val += s1.pop() &#125; if (s2.length) &#123; val += s2.pop() &#125; let node = new ListNode(Math.floor(val/10)) res.val = val%10 node.next = res res = node &#125; return res.val ? res : res.next&#125;; Solution 2 — recursive123456789101112131415161718192021222324252627282930313233343536373839# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" n1, n2 = self.getLength(l1), self.getLength(l2) head = ListNode(1) head.next = self.helper(l1, l2, n1 - n2) if n1 &gt; n2 else self.helper(l2, l1, n2 - n1) if head.next.val &gt; 9: head.next.val %= 10 return head return head.next def getLength(self, l): cnt = 0 while l: cnt += 1 l = l.next return cnt def helper(self, l1, l2, diff): if not l1: return None res = ListNode(l1.val + l2.val) if diff == 0 else ListNode(l1.val) post = self.helper(l1.next, l2.next, 0) if diff == 0 else self.helper(l1.next, l2, diff - 1) if post and post.val &gt; 9: post.val %= 10 res.val += 1 res.next = post return res 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; const n1 = getlength(l1), n2 = getlength(l2) const res = new ListNode(1) if (n1 &gt; n2) &#123; res.next = helper(l1, l2, n1 - n2) &#125; else &#123; res.next = helper(l2, l1, n2 - n1) &#125; if (res.next.val &gt;= 10) &#123; res.val = Math.floor(res.next.val/10) res.next.val %= 10 return res &#125; return res.next &#125;;const helper = (l1, l2, cnt) =&gt; &#123; if (!l1 &amp;&amp; !l2) return null const next = cnt === 0 ? helper(l1.next, l2.next, cnt) : helper(l1.next, l2, cnt - 1) const node = cnt === 0 ? new ListNode(l1.val + l2.val) : new ListNode(l1.val) if (next &amp;&amp; next.val &gt;= 10) &#123; node.val += Math.floor(next.val/10) next.val = next.val%10 &#125; node.next = next return node &#125;const getlength = (l) =&gt; &#123; let res = 0 while (l) &#123; res++ l = l.next &#125; return res&#125; Solution 3计算出linkedlist代表的数字 直接相加 这个方法不好的地方在于 当数字特别大的时候， 表示的方法会like 8.074864864864862e+60, 所以任何时候都要考虑输入的范围 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" n1 = n2 = 0 while l1: n1 = n1 * 10 + l1.val l1 = l1.next while l2: n2 = n2 * 10 + l2.val l2 = l2.next total = str(n1 + n2) prev = dummy = ListNode(0) for c in total: prev.next = ListNode(c) prev = prev.next return dummy.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"48. Rotate Image","slug":"48-Rotate-Image","date":"2020-10-05T11:18:48.000Z","updated":"2020-10-25T22:14:52.490Z","comments":true,"path":"2020/10/05/48-Rotate-Image/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/48-Rotate-Image/","excerpt":"","text":"Solution – Rotate 4 rectangles in one single loop12345678910111213141516171819202122232425class Solution(object): def rotate(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. \"\"\" if not matrix or not matrix[0]: return n = len(matrix) top, left, bottom, right = 0, 0, n-1, n-1 while n &gt; 1: for i in range(0, n-1): tmp = matrix[top][left + i] matrix[top][left + i] = matrix[bottom - i][left] matrix[bottom - i][left] = matrix[bottom][right - i] matrix[bottom][right - i] = matrix[top+i][right] matrix[top+i][right] = tmp left += 1 right -= 1 top += 1 bottom -= 1 n -= 2","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1283. Find the Smallest Divisor Given a Threshold","slug":"1283-Find-the-Smallest-Divisor-Given-a-Threshold","date":"2020-10-05T10:16:19.000Z","updated":"2020-10-05T10:47:56.069Z","comments":true,"path":"2020/10/05/1283-Find-the-Smallest-Divisor-Given-a-Threshold/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/1283-Find-the-Smallest-Divisor-Given-a-Threshold/","excerpt":"","text":"Binary Search 123456789101112131415161718class Solution(object): def smallestDivisor(self, nums, threshold): \"\"\" :type nums: List[int] :type threshold: int :rtype: int \"\"\" # l is 1, not 0 l, r = 1, max(nums) while l &lt; r: m = (l + r)/2 # 因为是五入， 所以就是-1/m + 1 if sum((num + m - 1)/m for num in nums) &lt;= threshold: r = m else: l = m + 1 return r 12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; threshold * @return &#123;number&#125; */var smallestDivisor = function(nums, threshold) &#123; let l = 1, r = Math.max(...nums) while (l &lt; r) &#123; let m = Math.floor((l + r)/2) let sum = 0 for (const num of nums) &#123; sum += Math.ceil(num/m) &#125; if (sum &lt;= threshold) &#123; r = m &#125; else &#123; l = m + 1 &#125; &#125; return r&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"64. Minimum Path Sum","slug":"64-Minimum-Path-Sum","date":"2020-10-05T09:47:11.000Z","updated":"2020-10-08T02:09:06.873Z","comments":true,"path":"2020/10/05/64-Minimum-Path-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/10/05/64-Minimum-Path-Sum/","excerpt":"","text":"Solution 1 – extra space 二维数组的创建：[[0 for j in range(n)] for i in range(m)] [[0] * m] * n不能这么创建 因为这样 n rows指向同一个array 12345678910111213141516171819202122class Solution(object): def minPathSum(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" if len(grid) == 0 or len(grid[0]) == 0: return 0 m, n = len(grid), len(grid[0]) dp = [[0 for j in range(n)] for i in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = grid[i][0] + dp[i-1][0] for i in range(1, n): dp[0][i] = grid[0][i] + dp[0][i-1] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j] , dp[i][j-1]) return dp[m-1][n-1] Solution 2 — constant space123456789101112131415161718192021class Solution(object): def minPathSum(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" if len(grid) == 0 or len(grid[0]) == 0: return 0 m, n = len(grid), len(grid[0]) for i in range(1, m): grid[i][0] += grid[i-1][0] for j in range(1, n): grid[0][j] += grid[0][j-1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1] 1234567891011121314151617181920212223/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var minPathSum = function(grid) &#123; if (grid.length === 0 || grid[0].length === 0) return 0 const m = grid.length, n = grid[0].length for (let i = 1; i &lt; m; i++) grid[i][0] += grid[i - 1][0] for (let i = 1; i &lt; n; i++) grid[0][i] += grid[0][i-1] for (let i = 1; i &lt; m; i++) &#123; for (let j = 1; j &lt; n; j++) &#123; grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]) &#125; &#125; return grid[m-1][n-1]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1396. Design Underground System","slug":"1396-Design-Underground-System","date":"2020-10-05T05:19:33.000Z","updated":"2020-10-05T05:31:07.172Z","comments":true,"path":"2020/10/04/1396-Design-Underground-System/","link":"","permalink":"https://jojoyang666.github.io/2020/10/04/1396-Design-Underground-System/","excerpt":"","text":"一个dict记录登陆时间 在游客出站后， 就立马可以确定分子分母， 所以可以及时更新数值1234567891011121314151617181920212223242526272829303132333435363738394041class UndergroundSystem(object): def __init__(self): self.check_in_data = &#123;&#125; self.journey_data = collections.defaultdict(lambda: [0, 0]) def checkIn(self, id, stationName, t): \"\"\" :type id: int :type stationName: str :type t: int :rtype: None \"\"\" self.check_in_data[id] = [stationName, t] def checkOut(self, id, stationName, t): \"\"\" :type id: int :type stationName: str :type t: int :rtype: None \"\"\" start_station, timestamp = self.check_in_data.pop(id) self.journey_data[(start_station, stationName)][0] += t - timestamp self.journey_data[(start_station, stationName)][1] += 1 def getAverageTime(self, startStation, endStation): \"\"\" :type startStation: str :type endStation: str :rtype: float \"\"\" total_time, total_trips = self.journey_data[(startStation, endStation)] return float(total_time)/float(total_trips)# Your UndergroundSystem object will be instantiated and called as such:# obj = UndergroundSystem()# obj.checkIn(id,stationName,t)# obj.checkOut(id,stationName,t)# param_3 = obj.getAverageTime(startStation,endStation) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var UndergroundSystem = function() &#123; this.check_in_data = &#123;&#125; this.journey_data = &#123;&#125;&#125;;/** * @param &#123;number&#125; id * @param &#123;string&#125; stationName * @param &#123;number&#125; t * @return &#123;void&#125; */UndergroundSystem.prototype.checkIn = function(id, stationName, t) &#123; this.check_in_data[id] = [stationName, t]&#125;;/** * @param &#123;number&#125; id * @param &#123;string&#125; stationName * @param &#123;number&#125; t * @return &#123;void&#125; */UndergroundSystem.prototype.checkOut = function(id, stationName, t) &#123; const [start_station, start_time] = this.check_in_data[id] const journey = `$&#123;start_station&#125; --- $&#123;stationName&#125;` if (!this.journey_data[journey]) &#123; this.journey_data[journey] = [0, 0] &#125; this.journey_data[journey][0] += t - start_time this.journey_data[journey][1] += 1&#125;;/** * @param &#123;string&#125; startStation * @param &#123;string&#125; endStation * @return &#123;number&#125; */UndergroundSystem.prototype.getAverageTime = function(startStation, endStation) &#123; const journey = `$&#123;startStation&#125; --- $&#123;endStation&#125;` const [time, count] = this.journey_data[journey] return time/count &#125;;/** * Your UndergroundSystem object will be instantiated and called as such: * var obj = new UndergroundSystem() * obj.checkIn(id,stationName,t) * obj.checkOut(id,stationName,t) * var param_3 = obj.getAverageTime(startStation,endStation) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"92. Reverse Linked List II","slug":"92-Reverse-Linked-List-II","date":"2020-10-05T01:12:06.000Z","updated":"2020-10-05T01:46:00.803Z","comments":true,"path":"2020/10/04/92-Reverse-Linked-List-II/","link":"","permalink":"https://jojoyang666.github.io/2020/10/04/92-Reverse-Linked-List-II/","excerpt":"","text":"1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def reverseBetween(self, head, m, n): \"\"\" :type head: ListNode :type m: int :type n: int :rtype: ListNode \"\"\" if m == n: return head dummyNode = ListNode(0) dummyNode.next = head prev = dummyNode for i in range(m - 1): prev = prev.next cur = prev.next for i in range(n - m): tmp = cur.next cur.next = tmp.next tmp.next = prev.next prev.next = tmp return dummyNode.next 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;ListNode&#125; */var reverseBetween = function(head, m, n) &#123; if (m === n) &#123; return head &#125; const dummyNode = new ListNode() dummyNode.next = head let prev = dummyNode for (let i = 0; i &lt; m - 1; i++) &#123; prev = prev.next &#125; cur = prev.next for (let i = 0; i &lt; n - m; i++) &#123; tmp = cur.next cur.next = tmp.next tmp.next = prev.next prev.next = tmp &#125; return dummyNode.next&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"442. Find All Duplicates in an Array","slug":"442-Find-All-Duplicates-in-an-Array","date":"2020-10-04T23:54:24.000Z","updated":"2020-10-05T00:16:26.623Z","comments":true,"path":"2020/10/04/442-Find-All-Duplicates-in-an-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/10/04/442-Find-All-Duplicates-in-an-Array/","excerpt":"","text":"Solution 1Bit Mask 1234567891011121314class Solution(object): def findDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" mask, n = 1, len(nums) res = [] for num in nums: if (1 &lt;&lt; num) &amp; mask: res.append(num) else: mask |= (1 &lt;&lt; num) return res Solution 2在原数组上面进行操作， 通过改变原数组的值 input的范围是1 ~ n 所以重复的数a, nums[a-1]必定会遇到两次， 第一次遇到将这个值 * -1， 第二次遇到 因为为负数， 我们就知道已经遇到过， 所以放到结果里面1234567891011121314class Solution(object): def findDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" res = [] for num in nums: if nums[abs(num) - 1] &lt; 0: res.append(abs(num)) else: nums[abs(num) - 1] *= -1 return res 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var findDuplicates = function(nums) &#123; const res = [] for(const num of nums) &#123; if (nums[Math.abs(num) - 1] &lt; 0) &#123; res.push(Math.abs(num)) &#125; else &#123; nums[Math.abs(num) - 1] *= -1 &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"6. ZigZag Conversion","slug":"6-ZigZag-Conversion","date":"2020-10-04T21:59:20.000Z","updated":"2020-10-04T22:04:53.115Z","comments":true,"path":"2020/10/04/6-ZigZag-Conversion/","link":"","permalink":"https://jojoyang666.github.io/2020/10/04/6-ZigZag-Conversion/","excerpt":"","text":"按照规律给rows里面填写chars， 然后再join 12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\" if numRows &lt;= 1: return s i, n = 0, len(s) rows = ['']*n while i &lt; n: for pos in range(numRows): if i &gt;= n: break rows[pos] += s[i] i += 1 for pos in range(numRows-2, 0, -1): if i &gt;= n: break rows[pos] += s[i] i += 1 return ''.join(rows) 123456789101112131415161718192021/** * @param &#123;string&#125; s * @param &#123;number&#125; numRows * @return &#123;string&#125; */var convert = function(s, numRows) &#123; const rows = new Array(numRows).fill(\"\") let i = 0; while (i &lt; s.length) &#123; for (let pos = 0; pos &lt; numRows &amp;&amp; i &lt; s.length; pos++) &#123; rows[pos] += s.charAt(i++) &#125; for (let pos = numRows - 2; pos &gt; 0 &amp;&amp; i &lt; s.length; pos--) &#123; rows[pos] += s.charAt(i++) &#125; &#125; return rows.join(\"\")&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"994. Rotting Oranges","slug":"994-Rotting-Oranges","date":"2020-10-04T21:13:31.000Z","updated":"2020-10-04T21:27:40.685Z","comments":true,"path":"2020/10/04/994-Rotting-Oranges/","link":"","permalink":"https://jojoyang666.github.io/2020/10/04/994-Rotting-Oranges/","excerpt":"","text":"Solution 1In Place 123456789101112131415161718192021222324252627282930313233class Solution(object): def orangesRotting(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" ROWS, COLS = len(grid), len(grid[0]) directions = [[1, 0], [0, 1], [-1, 0], [0, -1]] def runRottlingProcess(timestamp): to_be_continued = False for row in range(ROWS): for col in range(COLS): if grid[row][col] == timestamp: for d in directions: r, c = row + d[0], col + d[1] if ROWS &gt; r &gt;= 0 and COLS &gt; c &gt;= 0: if grid[r][c] == 1: grid[r][c] = timestamp + 1 to_be_continued = True return to_be_continued timestamp = 2 while runRottlingProcess(timestamp): timestamp += 1 for row in grid: for cell in row: if cell == 1: return -1 return timestamp - 2 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var orangesRotting = function(grid) &#123; const m = grid.length, n = grid[0].length const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]] const helper = (timestamp) =&gt; &#123; let toBeContinued = false for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (grid[i][j] === timestamp) &#123; for (const dir of dirs) &#123; let r = i + dir[0], c = j + dir[1] if (r &lt; m &amp;&amp; r &gt;= 0 &amp;&amp; c &lt; n &amp;&amp; c &gt;= 0 &amp;&amp; grid[r][c] === 1) &#123; grid[r][c] = timestamp + 1 toBeContinued = true &#125; &#125; &#125; &#125; &#125; return toBeContinued &#125; let timestamp = 2 while (helper(timestamp)) timestamp++; for (const row of grid) &#123; for (const cell of row) &#123; if (cell === 1) &#123; return -1 &#125; &#125; &#125; return timestamp - 2&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"763. Partition Labels","slug":"763-Partition-Labels","date":"2020-10-04T20:33:09.000Z","updated":"2020-10-04T20:55:17.152Z","comments":true,"path":"2020/10/04/763-Partition-Labels/","link":"","permalink":"https://jojoyang666.github.io/2020/10/04/763-Partition-Labels/","excerpt":"","text":"Figure out the rightmost index first and use it to denote the start of the next section. Reset the left pointer at the start of each new section. Store the difference of right and left pointers + 1 as in the result for each section.123456789101112131415161718class Solution(object): def partitionLabels(self, S): \"\"\" :type S: str :rtype: List[int] \"\"\" rightmost = &#123;c: i for i, c in enumerate(S)&#125; left, right = 0, 0 res = [] for i, c in enumerate(S): right = max(right, rightmost[c]) if i == right: res.append(right - left + 1) left = i + 1 return res 12345678910111213141516171819202122/** * @param &#123;string&#125; S * @return &#123;number[]&#125; */var partitionLabels = function(S) &#123; const rightMost = &#123;&#125; const array = [...S] array.forEach((c, i) =&gt; &#123; rightMost[c] = i &#125;) let res = [], left = 0, right = 0 array.forEach((c, i) =&gt; &#123; right = Math.max(right, rightMost[c]) if (right === i) &#123; res.push(right - left + 1) left = i + 1 &#125; &#125;) return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"322. Coin Change","slug":"322-Coin-Change","date":"2020-10-04T19:08:36.000Z","updated":"2020-10-04T19:33:01.423Z","comments":true,"path":"2020/10/04/322-Coin-Change/","link":"","permalink":"https://jojoyang666.github.io/2020/10/04/322-Coin-Change/","excerpt":"","text":"12345678910111213class Solution(object): def coinChange(self, coins, amount): \"\"\" :type coins: List[int] :type amount: int :rtype: int \"\"\" MAX = float('inf') dp = [0] + [MAX]*amount for i in xrange(1, amount + 1): dp[i] = min(dp[i-c] if i-c &gt;= 0 else MAX for c in coins) + 1 return dp[amount] if dp[amount] != MAX else -1 123456789101112131415161718/** * @param &#123;number[]&#125; coins * @param &#123;number&#125; amount * @return &#123;number&#125; */var coinChange = function(coins, amount) &#123; const dp = new Array(amount+1).fill(Number.MAX_VALUE) dp[0] = 0 for (let i = 1; i &lt;= amount; i++) &#123; for (const coin of coins) &#123; const tmp = i - coin &gt;= 0 ? dp[i - coin] + 1 : Number.MAX_VALUE dp[i] = Math.min(tmp, dp[i]) &#125; &#125; return dp[amount] === Number.MAX_VALUE ? -1 : dp[amount] &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"11. Container With Most Water","slug":"11-Container-With-Most-Water","date":"2020-10-03T22:52:30.000Z","updated":"2020-10-03T23:08:16.792Z","comments":true,"path":"2020/10/03/11-Container-With-Most-Water/","link":"","permalink":"https://jojoyang666.github.io/2020/10/03/11-Container-With-Most-Water/","excerpt":"","text":"12345678910111213141516class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" l, r, res = 0, len(height) - 1, 0 while l &lt; r: res = max(res, (r - l) * min(height[l], height[r])) if height[l] &lt; height[r]: l += 1 else: r -= 1 return res 12345678910111213141516171819/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */var maxArea = function(height) &#123; let l = 0, r = height.length - 1, res = 0 while (l &lt; r) &#123; res = Math.max(res, (r-l)*Math.min(height[l], height[r])) if (height[l] &lt; height[r]) &#123; l++ &#125; else &#123; r-- &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1 on 1 with Manager","slug":"1-on-1-with-Manager","date":"2020-10-03T00:02:42.000Z","updated":"2020-10-03T00:19:24.839Z","comments":true,"path":"2020/10/02/1-on-1-with-Manager/","link":"","permalink":"https://jojoyang666.github.io/2020/10/02/1-on-1-with-Manager/","excerpt":"","text":"How To Talk About the Promotions This procress happens during the whole 1 on 1 process among the one promotion cycle Bring the topic, like how do I / what should I do for the next level? Before this bring topic, 一定要列出 在这个阶段中自己都有什么achievement, gap(对于这个gap不要自己主动说， 要等manager来提) 让manager列出我能到达下个promotion的timeline， manager make plan for me， 自己努力达到那个timeline 1 on 1 在整个1-on-1中， 提出我最近的challenge/achievement是什么， 已经我需要什么help 一定要让manager知道你再做什么 知道你的challenge， 有可能这个challenge 不是你这个level的人可以解决的 要知道自己的goal是什么， 也就是说在这个promotion cycle中， manager 提出了需要这个ability你才能到next level working的时候要向这步走， 如果没有这个机会来提高这个ability， 那么就要向manager来要机会， 不能闷头苦干 Other 每次meeting前一定要设置好agenda， make sure这个meeting解决这些agenda 想要什么意见就要向那个方面的，自己能够到的最好的人要 working closly with manager, know what he need/help, that’s the direction you need to do","categories":[{"name":"Work","slug":"Work","permalink":"https://jojoyang666.github.io/categories/Work/"}],"tags":[]},{"title":"891. Sum of Subsequence Widths","slug":"891-Sum-of-Subsequence-Widths","date":"2020-10-02T01:12:19.000Z","updated":"2020-10-02T22:32:34.529Z","comments":true,"path":"2020/10/01/891-Sum-of-Subsequence-Widths/","link":"","permalink":"https://jojoyang666.github.io/2020/10/01/891-Sum-of-Subsequence-Widths/","excerpt":"","text":"Solution 1 The order of the input does not matter There are i smaller numbers,so there are 2 ^ i sequences in which A[i] is maximum.we should do res += A[i] * (2 ^ i) There are n - i - 1 bigger numbers,so there are 2 ^ (n - i - 1) sequences in which A[i] is minimum.we should do res -= A[i] * (n - i - 1) C(i, 0) + C(i, 1) + C(i, 2) .. C(i, i) == 2 ** i 12def sumSubseqWidths(self, A): return sum(((1 &lt;&lt; i) - (1 &lt;&lt; len(A) - i - 1)) * a for i, a in enumerate(sorted(A))) % (10**9 + 7)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"828. Count Unique Characters of All Substrings of a Given String","slug":"828-Count-Unique-Characters-of-All-Substrings-of-a-Given-String","date":"2020-10-02T01:11:22.000Z","updated":"2020-10-03T20:33:43.929Z","comments":true,"path":"2020/10/01/828-Count-Unique-Characters-of-All-Substrings-of-a-Given-String/","link":"","permalink":"https://jojoyang666.github.io/2020/10/01/828-Count-Unique-Characters-of-All-Substrings-of-a-Given-String/","excerpt":"","text":"123456789101112131415161718class Solution(object): def uniqueLetterString(self, s): \"\"\" :type s: str :rtype: int \"\"\" index = &#123;c: [-1, -1] for c in string.ascii_uppercase&#125; res = 0 for i, c in enumerate(s): k, j = index[c] res += (i - j) * (j - k) index[c] = [j, i] for c in index: k, j = index[c] res += (len(s) - j) * (j - k) return res % (10**9 + 7) 123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @return &#123;number&#125; */var uniqueLetterString = function(s) &#123; const index = &#123;&#125; let res = 0 for (let i = 0; i &lt; 26; i++) &#123; index[String.fromCharCode(i+65)] = [-1, -1] &#125; for (let i = 0; i &lt; s.length; i++) &#123; const c = s.charAt(i) const [j, k] = index[c] res += (k - j) * (i - k) index[c] = [k, i] &#125; for (const c of Object.keys(index)) &#123; const [j, k] = index[c] res += (k - j) * (s.length - k) &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"739. Daily Temperatures","slug":"739-Daily-Temperatures","date":"2020-10-02T01:10:04.000Z","updated":"2020-10-02T16:42:04.851Z","comments":true,"path":"2020/10/01/739-Daily-Temperatures/","link":"","permalink":"https://jojoyang666.github.io/2020/10/01/739-Daily-Temperatures/","excerpt":"","text":"12345678910111213141516class Solution(object): def dailyTemperatures(self, T): \"\"\" :type T: List[int] :rtype: List[int] \"\"\" n = len(T) stack, res = [], [0] * n for i, cur in enumerate(T): while stack and T[stack[-1]] &lt; cur: t = stack.pop() res[t] = i - t stack.append(i) return res` 1234567891011121314151617/** * @param &#123;number[]&#125; T * @return &#123;number[]&#125; */var dailyTemperatures = function(T) &#123; const stack = [] const res = new Array(T.length).fill(0) T.forEach((cur, i) =&gt; &#123; while (stack.length &amp;&amp; T[stack[stack.length-1]] &lt; cur) &#123; let t = stack.pop() res[t] = i - t &#125; stack.push(i) &#125;) return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"42. Trapping Rain Water","slug":"42-Trapping-Rain-Water","date":"2020-10-01T19:24:21.000Z","updated":"2020-11-11T20:48:02.040Z","comments":true,"path":"2020/10/01/42-Trapping-Rain-Water/","link":"","permalink":"https://jojoyang666.github.io/2020/10/01/42-Trapping-Rain-Water/","excerpt":"","text":"Solution 1Stack 1234567891011121314151617181920- ![image](/images/42-Trapping-Rain-Water.png)class Solution(object): def trap(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" stack, res = [], 0 for i, h in enumerate(height): while stack and height[stack[-1]] &lt; h: prev = stack.pop() if stack: w = i - stack[-1] - 1 diff = min(h, height[stack[-1]]) - height[prev] res += diff * w if not stack or height[stack[-1]] &gt;= h: stack.append(i) return res 123456789101112131415161718192021222324/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */var trap = function(height) &#123; const stack = [] let res = 0 height.forEach((h, i) =&gt; &#123; while (stack.length &amp;&amp; height[stack[stack.length-1]] &lt; h) &#123; let t = stack.pop() if (!stack.length) continue let w = i - stack[stack.length-1] - 1 let diff = Math.min(h, height[stack[stack.length-1]]) - height[t] res += diff * w &#125; if(!stack.length || height[stack[stack.length-1]] &gt;= h) &#123; stack.push(i) &#125; &#125;) return res&#125;; Solution 2Two Pointers 12345678910111213141516171819202122class Solution(object): def trap(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" left, right, res = 0, len(height)-1, 0 while left &lt; right: mn = min(height[left], height[right]) if height[left] == mn: left += 1 while left &lt; right and height[left] &lt; mn: res += mn - height[left] left += 1 else: right -= 1 while left &lt; right and height[right] &lt; mn: res += mn - height[right] right -= 1 return res 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */var trap = function(height) &#123; let left = 0, right = height.length -1 , res = 0 while (left &lt; right) &#123; let mn = Math.min(height[left], height[right]) if (height[left] === mn) &#123; left++; while (left &lt; right &amp;&amp; height[left] &lt; mn) &#123; res += mn - height[left++] &#125; &#125; else &#123; right--; while (left &lt; right &amp;&amp; height[right] &lt; mn) &#123; res += mn - height[right--] &#125; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"84. Largest Rectangle in Histogram","slug":"84-Largest-Rectangle-in-Histogram","date":"2020-10-01T19:23:28.000Z","updated":"2020-10-02T01:08:11.731Z","comments":true,"path":"2020/10/01/84-Largest-Rectangle-in-Histogram/","link":"","permalink":"https://jojoyang666.github.io/2020/10/01/84-Largest-Rectangle-in-Histogram/","excerpt":"","text":"12345678910111213141516class Solution(object): def largestRectangleArea(self, heights): \"\"\" :type heights: List[int] :rtype: int \"\"\" stack, res = [], 0 heights = [0] + heights + [0] for i, height in enumerate(heights): while stack and heights[stack[-1]] &gt; height: prev = stack.pop() h = heights[prev] w = i - stack[-1] - 1 res = max(w*h, res) stack.append(i) return res 12345678910111213141516171819/** * @param &#123;number[]&#125; heights * @return &#123;number&#125; */var largestRectangleArea = function(heights) &#123; const Newheights = [0,...heights, 0] let res = 0 stack = [] for (let i = 0; i &lt; Newheights.length; i++) &#123; while (stack.length &amp;&amp; Newheights[stack[stack.length-1]] &gt; Newheights[i]) &#123; h = Newheights[stack.pop()] w = i - stack[stack.length-1] - 1 res = Math.max(res, h * w) &#125; stack.push(i) &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"856. Score of Parentheses","slug":"856-Score-of-Parentheses","date":"2020-10-01T17:45:45.000Z","updated":"2020-10-01T19:21:41.776Z","comments":true,"path":"2020/10/01/856-Score-of-Parentheses/","link":"","permalink":"https://jojoyang666.github.io/2020/10/01/856-Score-of-Parentheses/","excerpt":"","text":"Solution 1 123456789101112131415class Solution(object): def scoreOfParentheses(self, S): \"\"\" :type S: str :rtype: int \"\"\" stack, cur = [], 0 for c in S: if c == '(': stack.append(cur) cur = 0 else: cur = stack.pop() + max(cur*2, 1) return cur 12345678910111213141516171819/** * @param &#123;string&#125; S * @return &#123;number&#125; */var scoreOfParentheses = function(S) &#123; const stack = [] let cur = 0 for (const c of [...S]) &#123; if (c === '(') &#123; stack.push(cur) cur = 0 &#125; else &#123; cur = stack.pop() + Math.max(cur*2, 1) &#125; &#125; return cur&#125;; Solution 2 –&gt; O(1) space 1234567891011121314class Solution(object): def scoreOfParentheses(self, S): \"\"\" :type S: str :rtype: int \"\"\" res, l = 0, 0 for i, c in enumerate(S): l += 1 if c == '(' else -1 if c == ')' and S[i-1] == '(': res += 1 &lt;&lt; l return res 1234567891011121314151617/** * @param &#123;string&#125; S * @return &#123;number&#125; */var scoreOfParentheses = function(S) &#123; let res = 0, l = 0 for (let i = 0; i &lt; S.length; i++) &#123; l += S.charAt(i) === '(' ? 1 : -1 if (S.charAt(i) === ')' &amp;&amp; S.charAt(i-1) === '(') &#123; res += 1 &lt;&lt; l &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"907. Sum of Subarray Minimums","slug":"907-Sum-of-Subarray-Minimums","date":"2020-10-01T04:41:04.000Z","updated":"2020-10-01T05:30:06.252Z","comments":true,"path":"2020/09/30/907-Sum-of-Subarray-Minimums/","link":"","permalink":"https://jojoyang666.github.io/2020/09/30/907-Sum-of-Subarray-Minimums/","excerpt":"","text":"注意Input的特点， input都是正数 Solution 112345678910111213141516171819202122232425262728class Solution(object): def sumSubarrayMins(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" n, mod = len(A), 10**9+7 left, right = [0]*n, [0]*n# left[i] -&gt; the numer of sub subarray ends with A[i], which num[i-k] &gt;= num[i]# right[i] -&gt; the numer of sub subarray starts with A[i], which num[i+k] &gt;= num[i] stack = [] for i, num in enumerate(A): count = 1 while stack and stack[-1][0] &gt; num: count += stack.pop()[1] stack.append([num, count]) left[i] = count stack = [] for i in range(n)[::-1]: count = 1 while stack and stack[-1][0] &gt;= A[i]: #不能同时&gt;=,是因为会有重复值产生 （当再次遍历到相等的地方的时候） count +=stack.pop()[1] stack.append([A[i], count]) right[i] = count return sum(num * l * r for num, l, r in zip(A, left, right))%mod Solution 2Maintain an decreasing stack, like previous thougt left * cur * right 12345678910111213141516class Solution(object): def sumSubarrayMins(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" stack, res = [], 0 A = [0] + A + [0] # cornor case: 最后一个元素和直接单调递减（原数组开始和最后递减） for i, num in enumerate(A): while stack and A[stack[-1]] &gt; num: j = stack.pop() k = stack[-1] res += A[j] * (j - k) * (i - j) stack.append(i) return res%(10**9 + 7) 1234567891011121314151617181920/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var sumSubarrayMins = function(A) &#123; const stack = [] const nums = [0, ...A, 0] let res = 0 nums.forEach((num, idx) =&gt; &#123; while (stack.length &amp;&amp; nums[stack[stack.length-1]] &gt; num) &#123; j = stack.pop() k = stack[stack.length-1] res += nums[j] * (j - k) * (idx - j) &#125; stack.push(idx) &#125;) mod = Math.pow(10, 9) + 7 return res%mod&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"901. Online Stock Span","slug":"901-Online-Stock-Span","date":"2020-10-01T02:51:12.000Z","updated":"2020-10-01T03:32:10.870Z","comments":true,"path":"2020/09/30/901-Online-Stock-Span/","link":"","permalink":"https://jojoyang666.github.io/2020/09/30/901-Online-Stock-Span/","excerpt":"","text":"Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock’s price for the current day. The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6]. Example 1:Input: [“StockSpanner”,”next”,”next”,”next”,”next”,”next”,”next”,”next”], [[],[100],[80],[60],[70],[60],[75],[85]]Output: [null,1,1,1,2,1,4,6]Explanation:First, S = StockSpanner() is initialized. Then:S.next(100) is called and returns 1,S.next(80) is called and returns 1,S.next(60) is called and returns 1,S.next(70) is called and returns 2,S.next(60) is called and returns 1,S.next(75) is called and returns 4,S.next(85) is called and returns 6. Note that (for example) S.next(75) returned 4, because the last 4 prices(including today’s price of 75) were less than or equal to today’s price. 123456789101112131415161718192021class StockSpanner(object): def __init__(self): self.stack = [] def next(self, price): \"\"\" :type price: int :rtype: int \"\"\" res = 1 while self.stack and self.stack[-1][0] &lt;= price: res += self.stack.pop()[1] self.stack.append([price, res]) return res # Your StockSpanner object will be instantiated and called as such:# obj = StockSpanner()# param_1 = obj.next(price) 123456789101112131415161718192021222324var StockSpanner = function() &#123; this.stack = []&#125;;/** * @param &#123;number&#125; price * @return &#123;number&#125; */StockSpanner.prototype.next = function(price) &#123; let res = 1 while (this.stack.length &amp;&amp; this.stack[this.stack.length-1][0] &lt;= price) res += this.stack.pop()[1] this.stack.push([price, res]) return res&#125;;/** * Your StockSpanner object will be instantiated and called as such: * var obj = new StockSpanner() * var param_1 = obj.next(price) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"503. Next Greater Element II","slug":"503-Next-Greater-Element-II","date":"2020-09-30T04:26:50.000Z","updated":"2020-09-30T04:37:30.299Z","comments":true,"path":"2020/09/29/503-Next-Greater-Element-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/29/503-Next-Greater-Element-II/","excerpt":"","text":"12345678910111213class Solution(object): def nextGreaterElements(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" stack, res = [], [-1]*len(nums) for i in range(len(nums))*2: while stack and nums[stack[-1]] &lt; nums[i]: res[stack.pop()] = nums[i] stack.append(i) return res 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var nextGreaterElements = function(nums) &#123; const n = nums.length const res = new Array(n).fill(-1), stack = [] for (let i = 0; i &lt; n * 2; i++) &#123; while (stack.length &amp;&amp; nums[stack[stack.length-1]] &lt; nums[i%n]) &#123; res[stack.pop()] = nums[i%n] &#125; stack.push(i%n) &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"496. Next Greater Element I ","slug":"496-Next-Greater-Element-I","date":"2020-09-30T03:40:58.000Z","updated":"2020-09-30T04:11:43.562Z","comments":true,"path":"2020/09/29/496-Next-Greater-Element-I/","link":"","permalink":"https://jojoyang666.github.io/2020/09/29/496-Next-Greater-Element-I/","excerpt":"","text":"1234567891011121314151617181920class Solution(object): def nextGreaterElement(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" stack, m, res = [], &#123;&#125;, [] for num in nums2: while stack and stack[-1] &lt; num: m[stack.pop()] = num stack.append(num) while stack: m[stack.pop()] = -1 for num in nums1: res.append(m[num]) return res 1234567891011121314151617181920212223242526/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var nextGreaterElement = function(nums1, nums2) &#123; const stack = [], res = [], map = &#123;&#125; for (let num of nums2) &#123; while(stack.length &amp;&amp; stack[stack.length-1] &lt; num) &#123; map[stack.pop()] = num &#125; stack.push(num) &#125; while (stack.length) &#123; map[stack.pop()] = -1 &#125; for (const num of nums1) &#123; res.push(map[num]) &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1130. Minimum Cost Tree From Leaf Values","slug":"1130-Minimum-Cost-Tree-From-Leaf-Values","date":"2020-09-30T00:09:20.000Z","updated":"2020-09-30T16:20:24.918Z","comments":true,"path":"2020/09/29/1130-Minimum-Cost-Tree-From-Leaf-Values/","link":"","permalink":"https://jojoyang666.github.io/2020/09/29/1130-Minimum-Cost-Tree-From-Leaf-Values/","excerpt":"","text":"让大的值比较晚的被用到12345678910111213141516class Solution(object): def mctFromLeafValues(self, arr): \"\"\" :type arr: List[int] :rtype: int \"\"\" stack, res = [float('inf')], 0 for num in arr: while stack[-1] &lt;= num: res += stack.pop() * min(stack[-1], num) stack.append(num) while len(stack) &gt; 2: res += stack.pop() * stack[-1] return res 12345678910111213141516171819/** * @param &#123;number[]&#125; arr * @return &#123;number&#125; */var mctFromLeafValues = function(arr) &#123; const stack = [Number.MAX_VALUE] let res = 0 for (const num of arr) &#123; while (stack[stack.length - 1] &lt;= num) &#123; res += stack.pop() * Math.min(stack[stack.length-1], num) &#125; stack.push(num) &#125; while (stack.length &gt; 2) &#123; res += stack.pop() * stack[stack.length-1] &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"209. Minimum Size Subarray Sum","slug":"209-Minimum-Size-Subarray-Sum","date":"2020-09-29T20:02:55.000Z","updated":"2020-09-30T00:08:24.761Z","comments":true,"path":"2020/09/29/209-Minimum-Size-Subarray-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/09/29/209-Minimum-Size-Subarray-Sum/","excerpt":"","text":"Solution 1 注意这个题目862. Shortest Subarray with Sum at Least K 与不同， 因为其输入都是正数， 不包含负数1234567891011121314151617class Solution(object): def minSubArrayLen(self, s, nums): \"\"\" :type s: int :type nums: List[int] :rtype: int \"\"\" res, left, right, cur = float('inf'), 0, 0, 0 while right &lt; len(nums): cur += nums[right] while cur &gt;= s and left &lt;= right: res = min(res, right - left + 1) cur -= nums[left] left += 1 right += 1 return res if res != float('inf') else 0 123456789101112131415161718/** * @param &#123;number&#125; s * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var minSubArrayLen = function(s, nums) &#123; let res = Number.MAX_VALUE, left = 0, cur = 0 for (let right = 0; right &lt; nums.length; right++) &#123; cur += nums[right] while (cur &gt;= s &amp;&amp; left &lt;= right) &#123; res = Math.min(right - left + 1, res) cur -= nums[left++] &#125; &#125; return res === Number.MAX_VALUE ? 0 : res&#125;; Solution 2 –&gt; solve it in O(nlogn)知道答案的范围， 然后通过binary search来排除 1234567891011121314151617181920212223242526272829303132class Solution(object): def minSubArrayLen(self, s, nums): \"\"\" :type s: int :type nums: List[int] :rtype: int \"\"\" res, left, right = 0, 0, len(nums) while left &lt;= right: mid = (right - left)/2 + left if self.windowExit(mid, nums, s): right = mid - 1 res = mid else: left = mid + 1 # print mid, left, right return res # search if a window of size k can meet the condition sum &gt;= k def windowExit(self, size, nums, s): cur = 0 for i in range(len(nums)): if i &gt;= size: cur -= nums[i-size] cur += nums[i] if cur &gt;= s: return True return False 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;number&#125; s * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var minSubArrayLen = function(s, nums) &#123; let left = 0, right = nums.length, res = 0 while (left &lt;= right) &#123; let mid = Math.floor((right - left)/2) + left if (windowExist(mid, nums, s)) &#123; res = mid right = mid - 1 &#125; else &#123; left = mid + 1 &#125; &#125; return res&#125;;const windowExist = (size, nums, s) =&gt; &#123; let sum = 0 for (let i = 0; i &lt; nums.length; i++) &#123; sum += nums[i] if (i &gt;= size) &#123; sum -= nums[i - size] &#125; if (sum &gt;= s) &#123; return true &#125; &#125; return false&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"862. Shortest Subarray with Sum at Least K","slug":"862-Shortest-Subarray-with-Sum-at-Least-K","date":"2020-09-29T19:52:38.000Z","updated":"2020-09-29T20:01:32.574Z","comments":true,"path":"2020/09/29/862-Shortest-Subarray-with-Sum-at-Least-K/","link":"","permalink":"https://jojoyang666.github.io/2020/09/29/862-Shortest-Subarray-with-Sum-at-Least-K/","excerpt":"","text":"Montonic queue 12345678910111213141516171819202122class Solution(object): def shortestSubarray(self, A, K): \"\"\" :type A: List[int] :type K: int :rtype: int \"\"\" d = collections.deque([[0, 0]]) res, cur = float('inf'), 0 for j, num in enumerate(A): cur += num while d and cur - d[0][1] &gt;= K: res = min(res, j - d[0][0] + 1) d.popleft() while d and d[-1][1] &gt; cur: d.pop() d.append([j+1, cur]) return res if res != float('inf') else -1 12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; A * @param &#123;number&#125; K * @return &#123;number&#125; */var shortestSubarray = function(A, K) &#123; const deque = [[0, 0]] let res = Number.MAX_VALUE, sum = 0 for (let j = 0; j &lt; A.length; j++) &#123; sum += A[j] while(deque.length &gt; 0 &amp;&amp; sum - deque[0][1] &gt;= K) &#123; res = Math.min(res, j - deque[0][0] + 1) deque.shift() &#125; while (deque.length &gt; 0 &amp;&amp; deque[deque.length-1][1] &gt; sum) &#123; deque.pop() &#125; deque.push([j+1, sum]) &#125; return res === Number.MAX_VALUE ? -1 : res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"930. Binary Subarrays With Sum","slug":"930-Binary-Subarrays-With-Sum","date":"2020-09-29T18:21:10.000Z","updated":"2020-09-29T18:51:11.507Z","comments":true,"path":"2020/09/29/930-Binary-Subarrays-With-Sum/","link":"","permalink":"https://jojoyang666.github.io/2020/09/29/930-Binary-Subarrays-With-Sum/","excerpt":"","text":"Solution 1这个题和 1248. Count Number of Nice Subarrays 不太一样的点是： 遇到1后还可能重新开始， 所以需要update S and left， 也就是说可以不算当前的1，但是1248如果遇到了奇数是， 如果subarray有肯定是包括这个1的 123456789101112131415161718192021class Solution(object): def numSubarraysWithSum(self, A, S): \"\"\" :type A: List[int] :type S: int :rtype: int \"\"\" count = left = res = 0 for right in range(len(A)): if A[right] == 1: count = 0 S -= 1 while S &lt;= 0 and left &lt;= right: if S == 0: count += 1 S += A[left] left += 1 res += count return res 12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; A * @param &#123;number&#125; S * @return &#123;number&#125; */var numSubarraysWithSum = function(A, S) &#123; let count = 0, left = 0, res = 0 for (let right = 0; right &lt; A.length; right++) &#123; if (A[right] === 1) &#123; count = 0 S-- &#125; while (left &lt;= right &amp;&amp; S &lt;= 0) &#123; if (S == 0) &#123; count++ &#125; S += A[left++] &#125; res += count &#125; return res&#125;; Solution 2123456789101112131415161718192021class Solution(object): def numSubarraysWithSum(self, A, S): \"\"\" :type A: List[int] :type S: int :rtype: int \"\"\" return self.atMost(A, S) - self.atMost(A, S-1) def atMost(self, A, S): left = res = 0 for right in range(len(A)): if A[right] == 1: S -= 1 while S &lt; 0 and left &lt;= right: S += A[left] left += 1 res += right - left + 1 return res 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; A * @param &#123;number&#125; S * @return &#123;number&#125; */var numSubarraysWithSum = function(A, S) &#123; return atMost(A, S) - atMost(A, S-1)&#125;;const atMost = (A, S) =&gt; &#123; let left = 0, res = 0 for (let right = 0; right &lt; A.length; right++) &#123; S -= A[right] while (S &lt; 0 &amp;&amp; left &lt;= right) &#123; S += A[left++] &#125; res += right - left + 1 &#125; return res&#125; Solution 3HashMap来解决, 存储prefix sum同样适合于负数 123456789101112131415class Solution(object): def numSubarraysWithSum(self, A, S): \"\"\" :type A: List[int] :type S: int :rtype: int \"\"\" count = collections.Counter(&#123;0:1&#125;) res = psum = 0 for num in A: psum += num res += count[psum - S] count[psum] += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1004. Max Consecutive Ones III","slug":"1004-Max-Consecutive-Ones-III","date":"2020-09-29T05:58:34.000Z","updated":"2020-09-29T17:10:36.779Z","comments":true,"path":"2020/09/28/1004-Max-Consecutive-Ones-III/","link":"","permalink":"https://jojoyang666.github.io/2020/09/28/1004-Max-Consecutive-Ones-III/","excerpt":"","text":"1234567891011121314151617class Solution(object): def longestOnes(self, A, K): \"\"\" :type A: List[int] :type K: int :rtype: int \"\"\" left = 0 for right, num in enumerate(A): K -= 1 - num if K &lt; 0: # change at most K, 所以K &gt;= 0的时候， left位置都是相对于当前right位置的合理位置， 如果K &lt; 0, 即对于当前right位置来说， left不是合理位置， 但是对于当前right位置， 合理的最大值， 为previous left位置+1， 所以我们需要update K值， 同时update left值，所以用if rather than while condition # And also K += 1 - A[left] left += 1 # right = len(A) - 1 return right - left + 1 12345678910111213141516171819202122/** * @param &#123;number[]&#125; A * @param &#123;number&#125; K * @return &#123;number&#125; */var longestOnes = function(A, K) &#123; let left = 0, right = 0 while(right &lt; A.length) &#123; const num = A[right] K -= 1 - num if (K &lt; 0) &#123; K += 1 - A[left] left++ &#125; right++ &#125; return right - left&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1234. Replace the Substring for Balanced String","slug":"1234-Replace-the-Substring-for-Balanced-String","date":"2020-09-29T04:59:10.000Z","updated":"2020-09-29T05:39:55.543Z","comments":true,"path":"2020/09/28/1234-Replace-the-Substring-for-Balanced-String/","link":"","permalink":"https://jojoyang666.github.io/2020/09/28/1234-Replace-the-Substring-for-Balanced-String/","excerpt":"","text":"首先输入保证了是4的倍数 我们更加的关注滑动窗口外的counter, 因为只有滑动窗口外的字母count &lt;= n/4时，我们对滑动窗口内部的字符更改， 才能满足条件 i &lt; n,保证其不要越界， 如果i &gt; j只有一个case 就是， counter[c] == n/4, 同时保证了 j == i + 1, 然后退出循环因为all(counter[c] &lt;= n/4 for c in &quot;QWER&quot;)条件不再满足 1234567891011121314151617class Solution(object): def balancedString(self, s): \"\"\" :type s: str :rtype: int \"\"\" counter = collections.Counter(s) res = n = len(s) i = 0 for j in range(n): counter[s[j]] -= 1 while i &lt; n and all(counter[c] &lt;= n/4 for c in \"QWER\"): res = min(res, j - i + 1) counter[s[i]] += 1 i += 1 return res 12345678910111213141516171819202122/** * @param &#123;string&#125; s * @return &#123;number&#125; */var balancedString = function(s) &#123; const counter = &#123;'Q': 0, 'W': 0, 'E': 0, 'R': 0&#125; for(const c of [...s]) &#123; counter[c] += 1 &#125; let res = s.length, i = 0, n = s.length/4 for (let j = 0; j &lt; s.length; j++) &#123; counter[s.charAt(j)] -= 1 while (i &lt; s.length &amp;&amp; counter['Q'] &lt;= n &amp;&amp; counter['E'] &lt;= n &amp;&amp; counter['W'] &lt;= n &amp;&amp; counter['R'] &lt;= n) &#123; res = Math.min(res, j - i + 1) counter[s.charAt(i)] += 1 i++; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1248. Count Number of Nice Subarrays","slug":"1248-Count-Number-of-Nice-Subarrays","date":"2020-09-29T00:15:18.000Z","updated":"2020-09-29T03:45:23.199Z","comments":true,"path":"2020/09/28/1248-Count-Number-of-Nice-Subarrays/","link":"","permalink":"https://jojoyang666.github.io/2020/09/28/1248-Count-Number-of-Nice-Subarrays/","excerpt":"","text":"Solution 112345678910111213141516171819class Solution(object): def numberOfSubarrays(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" return self.atMost(nums, k) - self.atMost(nums, k-1) def atMost(self, nums, k): res, i = 0, 0 for j in range(len(nums)): k -= (nums[j] &amp; 1) while k &lt; 0: k += (nums[i]&amp;1) i += 1 res += j - i + 1 return res 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var numberOfSubarrays = function(nums, k) &#123; return atMost(nums, k) - atMost(nums, k-1)&#125;;const atMost = (nums, k) =&gt; &#123; let res = 0, i = 0, count = &#123;&#125;; nums.forEach((num, j) =&gt; &#123; k -= (num&amp;1) while (k &lt; 0) &#123; k += (nums[i]&amp;1) i++ &#125; res += j - i + 1 &#125;) return res&#125; Solution 21234567891011121314151617181920class Solution(object): def numberOfSubarrays(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" res = count = i = 0 for j, num in enumerate(nums): if num &amp; 1: k -= 1 count = 0 while k == 0: count += 1 k += (nums[i] &amp; 1) i += 1 res += count return res 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var numberOfSubarrays = function(nums, k) &#123; let res = 0, count = 0, left = 0; for (let right = 0; right &lt; nums.length; right++) &#123; const num = nums[right] if ((num&amp;1)) &#123; k--; count = 0; &#125; while (k === 0) &#123; k += (nums[left]&amp;1) left++; count++; &#125; res += count &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"992. Subarrays with K Different Integers","slug":"992-Subarrays-with-K-Different-Integers","date":"2020-09-28T22:51:06.000Z","updated":"2020-09-28T23:29:23.499Z","comments":true,"path":"2020/09/28/992-Subarrays-with-K-Different-Integers/","link":"","permalink":"https://jojoyang666.github.io/2020/09/28/992-Subarrays-with-K-Different-Integers/","excerpt":"","text":"Solution 1Explanition Write/copy a helper function of sliding window, to get the number of subarrays with at most K distinct elements. exactly(K) = atMost(K) - atMost(K-1) Way to understande res += j - i + 1 * you contract the range by incrementing i until the invariant is satisifed that the range [i, j] has k distinct elements * how many new ranges does this new element A[j] contribute? * it contributes exactly the new ranges [i, j], [i+1, j],…, [j-1, j], whicj amounts to j - i + 1 new ranges 1234567891011121314151617181920212223class Solution(object): def subarraysWithKDistinct(self, A, K): \"\"\" :type A: List[int] :type K: int :rtype: int \"\"\" return self.atMost(A, K) - self.atMost(A, K-1) def atMost(self, A, K): count = collections.Counter() res = i = 0 for j in range(len(A)): if count[A[j]] == 0: K -= 1 count[A[j]] += 1 while K &lt; 0: count[A[i]] -= 1 if count[A[i]] == 0: K += 1 i += 1 res += j - i + 1 return res 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[]&#125; A * @param &#123;number&#125; K * @return &#123;number&#125; */var subarraysWithKDistinct = function(A, K) &#123; return atMost(A, K) - atMost(A, K-1)&#125;;const atMost = (A, K) =&gt; &#123; let res = 0, left = 0, count = &#123;&#125;; for (let i = 0; i &lt; A.length; i++) &#123; if (count[A[i]] === undefined) count[A[i]] = 0 if (!count[A[i]]) K-- count[A[i]]++ while (K &lt; 0) &#123; count[A[left]]-- if (count[A[left]] === 0) K++; left++ &#125; res += i - left + 1 &#125; return res&#125;`","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1358. Number of Substrings Containing All Three Characters","slug":"1358-Number-of-Substrings-Containing-All-Three-Characters","date":"2020-09-28T20:06:38.000Z","updated":"2020-09-28T20:32:20.756Z","comments":true,"path":"2020/09/28/1358-Number-of-Substrings-Containing-All-Three-Characters/","link":"","permalink":"https://jojoyang666.github.io/2020/09/28/1358-Number-of-Substrings-Containing-All-Three-Characters/","excerpt":"","text":"Solution 11234567891011121314151617class Solution(object): def numberOfSubstrings(self, s): \"\"\" :type s: str :rtype: int \"\"\" res = i = 0 count = &#123;c: 0 for c in 'abc'&#125; for j in xrange(len(s)): count[s[j]] += 1 while all(count.values()): count[s[i]] -= 1 i += 1 res += i # s[i+1....j] is the minimum sub array which can meet the condition -- have at least one char of abc, thus we need it return res 12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;number&#125; */var numberOfSubstrings = function(s) &#123; const count = &#123;'a': 0, 'b': 0, 'c': 0&#125; let res = 0, i = 0; for (const c of [...s]) &#123; count[c] += 1 while (count['a'] &amp;&amp; count['b'] &amp;&amp; count['c']) &#123; count[s.charAt(i)] -= 1 i++ &#125; res += i &#125; return res&#125;; Solution 2 last will record the position of last occurrence. If the ending index of substring is i,the starting position should be on the left of min(last), in order to have all 3 different letters. And in this case, the starting index can be in range [0, min(last)], min(last) + 1 in total. 基本思想是： 找到minimun subarray, and the start index i, then res += i 123456789101112class Solution(object): def numberOfSubstrings(self, s): \"\"\" :type s: str :rtype: int \"\"\" res, last = 0, [-1] * 3 for j, c in enumerate(s): last[ord(c) - 97] = j res += min(last) + 1 return res 12345678910111213141516/** * @param &#123;string&#125; s * @return &#123;number&#125; */var numberOfSubstrings = function(s) &#123; let res = 0, last = [-1, -1, -1] for (let i = 0; i &lt; s.length; i++) &#123; let c = s.charAt(i) last[c.charCodeAt(0) - 97] = i res += Math.min(...last) + 1 &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Sliding Window/Montonic List","slug":"Sliding-Window-Montonic-List","date":"2020-09-28T17:35:10.000Z","updated":"2020-10-14T18:29:44.095Z","comments":true,"path":"2020/09/28/Sliding-Window-Montonic-List/","link":"","permalink":"https://jojoyang666.github.io/2020/09/28/Sliding-Window-Montonic-List/","excerpt":"","text":"1425. Constrained Subseque 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit 1358. Number of Substrings Containing All Three Characters 992. Subarrays with K Different Integers 1248. Count Number of Nice Subarrays 1234. Replace the Substring for Balanced String 1004. Max Consecutive Ones III 930. Binary Subarrays With Sum 904. Fruit Into Baskets 862. Shortest Subarray with Sum at Least K 209. Minimum Size Subarray Sum 1130. Minimum Cost Tree From Leaf Values 496. Next Greater Element I 503. Next Greater Element II 901. Online Stock Span 907. Sum of Subarray Minimums 856. Score of Parentheses 84. Largest Rectangle in Histogram 42. Trapping Rain Water 739. Daily Temperatures 828. Count Unique Characters of All Substrings of a Given String 891. Sum of Subsequence Widths Two Pointers 11. Container With Most Water 763. Partition Labels 19. Remove Nth Node From End of List Stack 581. Shortest Unsorted Continuous Subarray Montone stack单调栈 首先是栈， 是栈的应用 栈内元素维持了单调性的应用场景 单调栈递增（不减）可以找到左边第一个比当前出栈元素小（包含等于）的元素 单调栈递减（不增）可以找到左边第一个比当前出栈元素大（包含等于）的元素 多画图来模拟出栈入栈的顺序 连续 不能有什么间断 用if还是用while stack里面存的是idx还是值 Javascript中验证stack 是否为空， 一定要用stack.length而不是stack Divide ChocolateCapacity To Ship Packages In N DaysKoko Eating BananasMinimize Max Distance to Gas StationSplit Array Largest Sum","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1425. Constrained Subsequence Sum","slug":"1425-Constrained-Subseque","date":"2020-09-28T17:26:54.000Z","updated":"2020-09-28T23:38:00.099Z","comments":true,"path":"2020/09/28/1425-Constrained-Subseque/","link":"","permalink":"https://jojoyang666.github.io/2020/09/28/1425-Constrained-Subseque/","excerpt":"","text":"Solution res[i] represent the current maximum sum if we count the A[i], thus, the result is the maxmum value in array A deque is a non decreasing array deque is the maximun value from i-k to i12345678910111213141516class Solution(object): def constrainedSubsetSum(self, A, k): deque = collections.deque() for i in xrange(len(A)): A[i] += deque[0] if deque else 0 while deque and A[i] &gt; deque[-1]: deque.pop() if A[i] &gt; 0: deque.append(A[i]) if i &gt;= k and deque and deque[0] == A[i-k]: deque.popleft() return max(A) 12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var constrainedSubsetSum = function(nums, k) &#123; const deque = [] let res = nums[0] for (let i = 0; i &lt; nums.length; i++) &#123; nums[i] += deque &amp;&amp; deque[0] ? deque[0] : 0 res = Math.max(nums[i], res) while (deque &amp;&amp; nums[i] &gt; deque[deque.length-1]) &#123; deque.pop() &#125; if (nums[i] &gt; 0) &#123; deque.push(nums[i]) &#125; if (deque &amp;&amp; i &gt;= k &amp;&amp; deque[0] === nums[i-k]) &#123; deque.shift() &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","slug":"1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit","date":"2020-09-25T21:17:16.000Z","updated":"2020-09-29T05:55:09.064Z","comments":true,"path":"2020/09/25/1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit/","link":"","permalink":"https://jojoyang666.github.io/2020/09/25/1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit/","excerpt":"","text":"Solution 1Two heaps 12345678910111213141516171819class Solution(object): def longestSubarray(self, nums, limit): \"\"\" :type nums: List[int] :type limit: int :rtype: int \"\"\" maxq, minq = [], [] res = i = 0 for j, num in enumerate(nums): heapq.heappush(maxq, [-num, j]) heapq.heappush(minq, [num, j]) while -maxq[0][0] - minq[0][0] &gt; limit: i = min(maxq[0][1], minq[0][1]) + 1 while maxq[0][1] &lt; i: heapq.heappop(maxq) while minq[0][1] &lt; i: heapq.heappop(minq) res = max(res, j - i + 1) return res Solution 2Dual Monotonic Queue 12345678910111213141516171819202122232425262728class Solution(object): def longestSubarray(self, nums, limit): \"\"\" :type nums: List[int] :type limit: int :rtype: int \"\"\" maxd, mind = collections.deque(), collections.deque() res, l = 0, 0 for i, num in enumerate(nums): while maxd and maxd[-1] &lt; num: maxd.pop() while mind and mind[-1] &gt; num: mind.pop() maxd.append(num) mind.append(num) while maxd[0] - mind[0] &gt; limit: if maxd[0] == nums[l]: maxd.popleft() if mind[0] == nums[l]: mind.popleft() l += 1 res = max(res, i - l + 1) return res 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; limit * @return &#123;number&#125; */var longestSubarray = function(nums, limit) &#123; const maxd = [], mind = [] let l = 0, ans = 0 for (let i = 0; i &lt; nums.length; i++) &#123; while(maxd &amp;&amp; maxd[maxd.length-1] &lt; nums[i]) maxd.pop() while(mind &amp;&amp; mind[mind.length-1] &gt; nums[i]) mind.pop() maxd.push(nums[i]) mind.push(nums[i]) while(maxd[0] - mind[0] &gt; limit) &#123; if(maxd &amp;&amp; maxd[0] === nums[l]) maxd.shift() if(mind &amp;&amp; mind[0] === nums[l]) mind.shift() l++; &#125; ans = Math.max(ans, i - l + 1) &#125; return ans&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1048. Longest String Chain","slug":"1048-Longest-String-Chain","date":"2020-09-25T18:59:59.000Z","updated":"2020-09-25T19:27:39.707Z","comments":true,"path":"2020/09/25/1048-Longest-String-Chain/","link":"","permalink":"https://jojoyang666.github.io/2020/09/25/1048-Longest-String-Chain/","excerpt":"","text":"DP 1234567891011class Solution(object): def longestStrChain(self, words): \"\"\" :type words: List[str] :rtype: int \"\"\" dp = &#123;&#125; for w in sorted(words, key=len): dp[w] = max(dp.get(w[:i] + w[i+1:], 0) + 1 for i in xrange(len(w))) return max(dp.values()) 1234567891011121314151617181920/** * @param &#123;string[]&#125; words * @return &#123;number&#125; */var longestStrChain = function(words) &#123; const dp = &#123;&#125; words.sort((a, b) =&gt; a.length - b.length) for (let word of words) &#123; dp[word] = 0 let cnt = 0 for (let i = 0; i &lt; word.length; i++) &#123; const prevWord = word.substring(0, i) + word.substring(i+1) cnt = Math.max((dp[prevWord] === undefined ? 0 : dp[prevWord]) + 1, cnt) &#125; dp[word] = cnt &#125; return Math.max(...Object.values(dp))&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"801. Minimum Swaps To Make Sequences Increasing","slug":"801-Minimum-Swaps-To-Make-Sequences-Increasing","date":"2020-09-25T05:36:26.000Z","updated":"2020-09-25T06:16:13.196Z","comments":true,"path":"2020/09/24/801-Minimum-Swaps-To-Make-Sequences-Increasing/","link":"","permalink":"https://jojoyang666.github.io/2020/09/24/801-Minimum-Swaps-To-Make-Sequences-Increasing/","excerpt":"","text":"DP Solution –&gt; one represents ith swap case, another represents ith not swap Solution 1 O(n) –&gt; space12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; A * @param &#123;number[]&#125; B * @return &#123;number&#125; */var minSwap = function(A, B) &#123; const n = A.length const swap = new Array(n).fill(n), notswap = new Array(n).fill(n) swap[0] = 1 notswap[0] = 0 for (let i = 1; i &lt; A.length; i++) &#123; if (A[i-1] &lt; A[i] &amp;&amp; B[i-1] &lt; B[i]) &#123;// ith of A,B is bigger than (i-1)th of A, B // 但是swap[i]限定了我们必须要交换当前位置i，那么既然当前位置要交换，那么前一个位置i-1也要交换，同时交换才能继续保证同时递增 swap[i] = swap[i-1] + 1 notswap[i] = notswap[i-1] &#125;// 这种case下， 也可以达到increase if (A[i-1] &lt; B[i] &amp;&amp; B[i-1] &lt; A[i]) &#123; swap[i] = Math.min(swap[i], notswap[i-1] + 1) notswap[i] = Math.min(notswap[i], swap[i-1]) &#125; &#125; return Math.min(swap[n-1], notswap[n-1])&#125;; Solution 2 O(1) –&gt; space12345678910111213141516171819202122class Solution(object): def minSwap(self, A, B): \"\"\" :type A: List[int] :type B: List[int] :rtype: int \"\"\" n1, s1 = 0, 1 #s1 means swap, n1 means not swap for i in xrange(1, len(A)): n2 = s2 = float(\"inf\") if A[i-1] &lt; A[i] and B[i-1] &lt; B[i]: n2 = min(n2, n1) s2 = min(s2, s1 + 1) if A[i-1] &lt; B[i] and B[i-1] &lt; A[i]: n2 = min(n2, s1) s2 = min(s2, n1 + 1) n1, s1 = n2, s2 return min(n1, s1) 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; A * @param &#123;number[]&#125; B * @return &#123;number&#125; */var minSwap = function(A, B) &#123; let swap = 1, notswap = 0 for (let i = 1; i &lt; A.length; i++) &#123; let swap1 = A.length, notswap1 = A.length if (A[i-1] &lt; A[i] &amp;&amp; B[i-1] &lt; B[i]) &#123;// ith of A,B is bigger than (i-1)th of A, B // 但是swap[i]限定了我们必须要交换当前位置i，那么既然当前位置要交换，那么前一个位置i-1也要交换，同时交换才能继续保证同时递增 swap1 = Math.min(swap + 1, swap1) notswap1 = Math.min(notswap, notswap1) &#125;// 这种case下， 也可以达到increase if (A[i-1] &lt; B[i] &amp;&amp; B[i-1] &lt; A[i]) &#123; swap1 = Math.min(swap1, notswap + 1) notswap1 = Math.min(notswap1, swap) &#125; swap = swap1 notswap = notswap1 &#125; return Math.min(swap, notswap)&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"722. Remove Comments","slug":"722-Remove-Comments","date":"2020-09-25T04:50:32.000Z","updated":"2020-09-25T05:02:36.720Z","comments":true,"path":"2020/09/24/722-Remove-Comments/","link":"","permalink":"https://jojoyang666.github.io/2020/09/24/722-Remove-Comments/","excerpt":"","text":"12345678910111213141516171819202122232425262728class Solution(object): def removeComments(self, source): \"\"\" :type source: List[str] :rtype: List[str] \"\"\" in_block = False ans = [] for line in source: i = 0 if not in_block: newline = [] while i &lt; len(line): if line[i: i+2] == '/*' and not in_block: in_block = True i += 1 elif line[i: i+2] == '*/' and in_block: in_block = False i += 1 elif not in_block and line[i:i+2] == '//': break elif not in_block: newline.append(line[i]) i += 1 if newline and not in_block: ans.append(\"\".join(newline)) return ans 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;string[]&#125; source * @return &#123;string[]&#125; */var removeComments = function(source) &#123; let in_block = false const res = [] let newline = [] for(const line of source) &#123; let i = 0 newline = !in_block ? [] : newline while (i &lt; line.length) &#123; if (line.substring(i, i+2) === '/*' &amp;&amp; !in_block) &#123; in_block = true i++ &#125; else if (line.substring(i, i+2) === '*/' &amp;&amp; in_block) &#123; in_block = false i++ &#125; else if (line.substring(i, i+2) === '//' &amp;&amp; !in_block) &#123; break &#125; else if (!in_block)&#123; newline.push(line.charAt(i)) &#125; i++; &#125; if (!in_block &amp;&amp; newline.length) &#123; res.push(newline.join(\"\")) &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"299. Bulls and Cows","slug":"299-Bulls-and-Cows","date":"2020-09-24T23:48:48.000Z","updated":"2020-09-25T00:19:34.198Z","comments":true,"path":"2020/09/24/299-Bulls-and-Cows/","link":"","permalink":"https://jojoyang666.github.io/2020/09/24/299-Bulls-and-Cows/","excerpt":"","text":"Solution 1Two Pass 1234567891011121314151617181920212223242526272829303132/** * @param &#123;string&#125; secret * @param &#123;string&#125; guess * @return &#123;string&#125; */var getHint = function(secret, guess) &#123; const map = &#123;&#125; let bulls = 0, cows = 0 for (let i = 0; i &lt; secret.length; i++) &#123; let ch = secret.charAt(i) if (ch === guess.charAt(i)) &#123; bulls++; &#125; else &#123; if (map[ch] === undefined) &#123; map[ch] = 0 &#125; map[ch] = ++map[ch] &#125; &#125; [...guess].forEach((ch, i) =&gt; &#123; if (ch !== secret.charAt(i) &amp;&amp; map[ch]) &#123; cows++ map[ch]= --map[ch] &#125; &#125;) return `$&#123;bulls&#125;A$&#123;cows&#125;B`&#125;; Solution 2One Pass有点儿生产者消费者的感觉 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;string&#125; secret * @param &#123;string&#125; guess * @return &#123;string&#125; */var getHint = function(secret, guess) &#123; const map = &#123;&#125; let bulls = 0, cows = 0 for (let i = 0; i &lt; secret.length; i++) &#123; if (secret.charAt(i) === guess.charAt(i)) &#123; bulls++; &#125; else &#123; if (map[secret.charAt(i)] === undefined) &#123; map[secret.charAt(i)] = 0 &#125; if (map[guess.charAt(i)] === undefined) &#123; map[guess.charAt(i)] = 0 &#125; if (map[secret.charAt(i)] &lt; 0) &#123; cows++ &#125; if (map[guess.charAt(i)] &gt; 0) &#123; cows++ &#125; map[guess.charAt(i)] = --map[guess.charAt(i)] map[secret.charAt(i)] = ++map[secret.charAt(i)] &#125; &#125; return `$&#123;bulls&#125;A$&#123;cows&#125;B`&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"490. The Maze","slug":"490-The-Maze","date":"2020-09-24T22:29:34.000Z","updated":"2020-09-24T22:41:16.043Z","comments":true,"path":"2020/09/24/490-The-Maze/","link":"","permalink":"https://jojoyang666.github.io/2020/09/24/490-The-Maze/","excerpt":"","text":"DFS12345678910111213141516171819202122232425class Solution(object): def hasPath(self, maze, start, destination): \"\"\" :type maze: List[List[int]] :type start: List[int] :type destination: List[int] :rtype: bool \"\"\" m, n, stopped = len(maze), len(maze[0]), set([(start[0], start[1])]) def dfs(x, y): if [x, y] == destination: return True for i, j in (1, 0), (-1, 0), (0, 1), (0, -1): newX, newY = x, y while 0 &lt;= newX + i &lt; m and 0 &lt;= newY + j &lt; n and maze[newX + i][newY + j] != 1: newX += i newY += j if (newX, newY) not in stopped: stopped.add((newX, newY)) if dfs(newX, newY): return True return False return dfs(*start) 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;number[][]&#125; maze * @param &#123;number[]&#125; start * @param &#123;number[]&#125; destination * @return &#123;boolean&#125; */var hasPath = function(maze, start, destination) &#123; const visited = new Set([`$&#123;start[0]&#125;, $&#123;start[1]&#125;`]) const dfs = (x, y) =&gt; &#123; if (x === destination[0] &amp;&amp; y === destination[1]) &#123; return true; &#125; for (const [i, j] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) &#123; let newX = x, newY = y while (newX + i &gt;= 0 &amp;&amp; newX + i &lt; maze.length &amp;&amp; newY + j &gt;= 0 &amp;&amp; newY + j &lt; maze[0].length &amp;&amp; !maze[newX + i][newY + j]) &#123; newX += i newY += j &#125; if (!visited.has(`$&#123;newX&#125;, $&#123;newY&#125;`)) &#123; visited.add(`$&#123;newX&#125;, $&#123;newY&#125;`) if (dfs(newX, newY)) return true &#125; &#125; return false &#125; return dfs(start[0], start[1])&#125;; BFS12345678910111213141516171819202122232425class Solution(object): def hasPath(self, maze, start, destination): Q, n, m = [start], len(maze), len(maze[0]) dirs = ((0, 1), (0, -1), (1, 0), (-1, 0)) while Q: # Use Q.pop() as DFS or Q.popleft() with deque from collections library for better performance. Kudos to @whglamrock i, j = Q.pop(0) maze[i][j] = 2 if i == destination[0] and j == destination[1]: return True for x, y in dirs: row = i + x col = j + y while 0 &lt;= row &lt; n and 0 &lt;= col &lt; m and maze[row][col] != 1: row += x col += y row -= x col -= y if maze[row][col] == 0: Q.append([row, col]) return False 12345678910111213141516171819202122232425262728293031323334353637const hasPath = (maze, start, destination) =&gt; &#123; const m = maze.length; const n = maze[0].length; const queue = [start]; const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]; while (queue.length &gt; 0) &#123; const [x, y] = queue.shift(); if (x === destination[0] &amp;&amp; y === destination[1]) &#123; return true; &#125; for (let [dx, dy] of dirs) &#123; let i = x, j = y; // Keep rolling in the current direction while (i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; maze[i][j] !== 1) &#123; i += dx; j += dy; &#125; // One step back i -= dx; j -= dy; // Check if it's visited if (maze[i][j] !== 0) continue; // Mark as visited maze[i][j] = 2; // Continue rolling(or search) from [i, j] queue.push([i, j]); &#125; &#125; return false;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"817. Linked List Components","slug":"817-Linked-List-Components","date":"2020-09-24T21:39:12.000Z","updated":"2020-09-24T21:46:26.674Z","comments":true,"path":"2020/09/24/817-Linked-List-Components/","link":"","permalink":"https://jojoyang666.github.io/2020/09/24/817-Linked-List-Components/","excerpt":"","text":"123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def numComponents(self, head, G): \"\"\" :type head: ListNode :type G: List[int] :rtype: int \"\"\" Gset = set(G) cur = head ans = 0 while cur: if (cur.val in Gset and getattr(cur.next, 'val', None) not in Gset): ans += 1 cur = cur.next return ans 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number[]&#125; G * @return &#123;number&#125; */var numComponents = function(head, G) &#123; const set = new Set(G) let cur = head let ans = 0 while (cur) &#123; if (set.has(cur.val) &amp;&amp; !set.has(cur.next ? cur.next.val : null)) &#123; ans += 1 &#125; cur = cur.next &#125; return ans&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"729. My Calendar I","slug":"729-My-Calendar-I","date":"2020-09-24T19:50:01.000Z","updated":"2020-09-24T20:37:31.578Z","comments":true,"path":"2020/09/24/729-My-Calendar-I/","link":"","permalink":"https://jojoyang666.github.io/2020/09/24/729-My-Calendar-I/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132class MyCalendar(object): def __init__(self): self.intervals = [] def book(self, start, end): \"\"\" :type start: int :type end: int :rtype: bool \"\"\" if end &lt; start: return False # [0, i] -&gt; val &lt;= start, [i, end of interval] -&gt; val &gt; start i = bisect.bisect(self.intervals, start) if i%2: return False # [0, i] -&gt; val &lt; end, [i, end of interval] -&gt; val &gt;= end j = bisect.bisect_left(self.intervals, end) if i !=j: return False self.intervals[i:i] = [start, end] return True # Your MyCalendar object will be instantiated and called as such:# obj = MyCalendar()# param_1 = obj.book(start,end) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var MyCalendar = function() &#123; this.intervals = []&#125;;/** * @param &#123;number&#125; start * @param &#123;number&#125; end * @return &#123;boolean&#125; */MyCalendar.prototype.book = function(start, end) &#123; if (end &lt; start) &#123; return false; &#125; let i = binarySearch(this.intervals, start) if (i%2) return false let j = binarySearchLeft(this.intervals, end) if (i !== j) &#123; return false &#125; this.intervals = [ ...this.intervals.slice(0, i), start, end, ...this.intervals.slice(i) ]// console.log(this.intervals, start, end) return true&#125;;// [0, i] &lt;= target, target &gt; [i, end of array]const binarySearch = (nums, target) =&gt; &#123; let left = 0, right = nums.length while (left &lt; right) &#123; const mid = left + Math.floor((right - left)/2) if (nums[mid] &lt;= target) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right&#125;// [0, i] &lt; target, target &gt;= [i, end of array]const binarySearchLeft = (nums, target) =&gt; &#123; let left = 0, right = nums.length while (left &lt; right) &#123; const mid = left + Math.floor((right - left)/2) if (nums[mid] &lt; target) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right&#125;/** * Your MyCalendar object will be instantiated and called as such: * var obj = new MyCalendar() * var param_1 = obj.book(start,end) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"400. Nth Digit","slug":"400-Nth-Digit","date":"2020-09-24T18:24:41.000Z","updated":"2020-09-24T18:27:38.431Z","comments":true,"path":"2020/09/24/400-Nth-Digit/","link":"","permalink":"https://jojoyang666.github.io/2020/09/24/400-Nth-Digit/","excerpt":"","text":"1234567891011121314151617/** * @param &#123;number&#125; n * @return &#123;number&#125; */var findNthDigit = function(n) &#123; let start = 1, len = 1, cnt = 9 while (n &gt; cnt * len) &#123; n -= cnt *len cnt *= 10 len++ start *= 10 &#125; start += (n - 1)/len return parseInt(start.toString().charAt((n-1)%len))&#125;; The reason why (n-1) is to keep the correct digits finally in number they correspond to. Eg: if we are trying to find the 192th digit, we know range from 1th digit to 9th digit belongs to numbers from 1 to 9 range from 10th digit to 189th digit belongs to numbers from 10 to 99 So it is obvious that the next number should be 100 and the 192th digit should be the 3rd digit of 100(now n=3). OK, back to the code, if we do not minus 1 from n and then devide the len, the 192th digit would go to the next number which is 101. 前九个数都是1位的，然后10到99总共90个数字都是两位的 100到999这900个数都是三位的，那么这就很有规律 我们可以定义个变量cnt，初始化为9，然后每次循环扩大10倍，再用一个变量len记录当前循环区间数字的位数，","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"723. Candy Crush","slug":"723-Candy-Crush","date":"2020-09-23T23:15:48.000Z","updated":"2020-09-23T23:38:57.861Z","comments":true,"path":"2020/09/23/723-Candy-Crush/","link":"","permalink":"https://jojoyang666.github.io/2020/09/23/723-Candy-Crush/","excerpt":"","text":"123456789101112131415161718192021222324252627class Solution(object): def candyCrush(self, M): \"\"\" :type board: List[List[int]] :rtype: List[List[int]] \"\"\" while True: # 1. check crush = set() for i in range(len(M)): for j in range(len(M[0])): if j &gt; 1 and M[i][j] and M[i][j] == M[i][j - 1] == M[i][j - 2]: crush |= &#123;(i, j), (i, j - 1), (i, j - 2)&#125; if i &gt; 1 and M[i][j] and M[i-1][j] == M[i][j] == M[i-2][j]: crush |= &#123;(i, j), (i-1, j), (i-2, j)&#125; if not crush: break for i, j in crush: M[i][j] = 0 for j in range(len(M[0])): idx = len(M) - 1 for i in reversed(range(len(M))): if M[i][j]: M[idx][j] = M[i][j] idx -= 1 for i in range(idx + 1): M[i][j] = 0 return M 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var candyCrush = function(board) &#123; while (true) &#123; let moreToCrush = false; for (let i = 0; i &lt; board.length; i++) &#123; for (let j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] &gt; 0) &#123; moreToCrush = flagForCrush(board, i, j, board[i][j], 0, true, false) || moreToCrush; moreToCrush = flagForCrush(board, i, j, board[i][j], 0, false, true) || moreToCrush; &#125; &#125; &#125; if (!moreToCrush) break; crush(board); inflictGravity(board); &#125; return board;&#125;;// Try to \"flag\" cells for crushing by performing a pseudo-dfs going right or down the grid.// If in any direction we get at least three, start \"flagging\" the cells by swapping their values to negative// Returns true or false if cells were flaggedvar flagForCrush = function(board, i, j, target, count, right, down) &#123; if (j === board[0].length|| i === board.length || Math.abs(board[i][j]) !== Math.abs(target)) &#123; return count &gt;= 3; &#125; let shouldFlagIndexRight = flagForCrush(board, i, j+1, target, right ? count + 1 : 1, true, false); let shouldFlagIndexDown = flagForCrush(board, i+1, j, target, down ? count + 1 : 1, false, true); if ((shouldFlagIndexRight &amp;&amp; right) || (shouldFlagIndexDown &amp;&amp; down)) &#123; board[i][j] = -Math.abs(board[i][j]); return true; &#125; return false;&#125;;// Scans the grid and changes any cell that is \"flagged\" to zerovar crush = function(board) &#123; for (let i = 0; i &lt; board.length; i++) &#123; for (let j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] &lt; 0) board[i][j] = 0; &#125; &#125;&#125;;// Scans from the bottom of the grid up, swapping zeros with the first non-zero element that occurs above itvar inflictGravity = function(board) &#123; for (let j = 0; j &lt; board[0].length; j++) &#123; let st = board.length - 1; let end = board.length - 2; while (end &gt;= 0) &#123; if (board[st][j] === 0 &amp;&amp; board[end][j] !== 0) &#123; let temp = board[st][j]; board[st][j] = board[end][j]; board[end][j] = temp; st--; &#125; else if (board[st][j] !== 0) &#123; st--; &#125; end--; &#125; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Designing a URL Shortening service like TinyURL","slug":"Designing-a-URL-Shortening-service-like-TinyURL","date":"2020-09-23T17:41:07.000Z","updated":"2020-10-20T22:19:47.650Z","comments":true,"path":"2020/09/23/Designing-a-URL-Shortening-service-like-TinyURL/","link":"","permalink":"https://jojoyang666.github.io/2020/09/23/Designing-a-URL-Shortening-service-like-TinyURL/","excerpt":"","text":"Why do we meed URL shortening? The shortened URL is nearly one-third the size of the actual URL Used for optimizing links across devices tracking individual links to analyze audience campaign performance hiding affiliated original URLs Requirement and Goals of the SystemAsk Questions to find the exact scope of the system that interviewer has in mind Funcational Requirements The generated URL from the original one should be short enough to be easily copied and pasted into applications When users access a short link, our service should redirect them to the original link Users should optionally be able to pick a custom short link for their URL links will expire after a standard default timespan. Users should be able to specify the expiration time Non-Funtional Requirements(性能要求) The system should be highly available. THis is required because, if our service is down, all the URL redirections will start failing URL redirection should happen in real-time with minimal latency Shortened links should not be guessable(not predictable) Extended Requirements Analytics; e.g., how many times a redirection happened? Our service should also be accessible through REST APIs by other services Capacity Estimation and Constraints Overall System will be Read-heavy will be lots of redirection requests compared to new URL shortenings Assume a 100:1 ratio between read and write Traffic estimates Incoming data and outgoing data Storage estimates Bandwidth estimates Memory estimates If want to cache some of the hot URLs that are frequently accessed, how much memory will we need to store them? —&gt; (If we follow the 80-20 rule, meaning 20% of URLs generate 80% of traffic, we would like to cache these 20% hot URLs) since 20K requests/secod, 1.7 billion/day 20K * 3600 seconds * 24 hours = ~1.7 billion To cache 20% of these: 0.2 * 1.7 billion * 500 bytes = ~170GB Note: There will be a lot of duplicate requests(of the same URL), thus, the actual memory usage will be less than 170GB* System APIS After finalized the requirements, to define the system APIS API for creaing URLs createURL(api_dev_key, original_url, custom_alias=None, user_name=None, expire_daye=None) Parameters api_dev_key (string): The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota. original_url (string): Original URL to be shortened. custom_alias (string): Optional custom key for the URL. user_name (string): Optional user name to be used in the encoding. expire_date (string): Optional expiration date for the shortened URL. Returns A successful insertion returns the shortened URL; otherwise, it returns an error code. API for delteing URL deleteURL(api_dev_key, url_key) url_key is a string representing the shortened URL to be retrieved. A successful deletion returns ‘URL Removed’. How do we detect and prevent abuse? —&gt; ratelimit A malicicious use can put us out of business by consuming all URL keys in current design To aviod it, Limit users via their api_dev_key, in other words, api_dev_key can be limited to a certain number of URL creations and redirections per some time period set to a different duration per developer key Database Design Define DB schema in early stages, will help to understand the data flow among various components and later would guide towards data partitioning Obverations about the nature of the data we will store: need to store billions of records Each object we store is small(less than 1K) There are no relationships between records – other than storing which user created a URL Our service is read-heavy Database schema What kind of db shoud we use? NoSQL like: DynamoDB, Cassandra, Riak is better choice NoSQL would also be easier to scale Basic System Design and AlgorithmHow to Generate the short key —&gt; two solutions here Encoding actual URLOverall Compute a unique hash of the given URL using MD5 or SHA256 A reasonable question would be: what should be the length of the short key? 6, 8 or 10 characters using base64 encoding, a 6 letters long key would result in 64^6 = ~68.7 billion possible strings –&gt; assume we use this one, this one will suffice our system using base64 encoding, a 8 letters long key would result in 64^8 = ~281 trillion possible stringsUsing MD5 algorithm produce a 128-bit hash value After base64 encoding, get a string having more than 21 chars Each base64 char encodes 6 bits of the hash value we can take 6(or 8) letters for the key, —&gt; result in key duplication To resolve it, we can choose some other char out of the encoding string or swap some characters What are the diffrent issues with our solution If multiple users enter the same URL, thay can get the same shortened URL which is not acceptable what if parts of the URL are URL-encoded? Workaround for the issues* Solution 1 Append an increasing sequence number to each input URL to make it unqiue Then generate a hash of it Do not need to store this sequence number in db Possible problems: would be an ever-increasing sequence number. can it overflow? Appending an increasing sequence number will also impact the performance of the service Solution 2 Append user id(which should be unique) to the input URL if user has not signed in, we would have to ask the user to choose a uniqueness key Even after this, if we have a conflict, we have to keep generating a key until we get a unique one Generating keys offline Basic Idea standalone Key Generation Service(KGS) that generates randpm six-letter strings beforehand and store them into a db(call it key-DB) simple and fast Can concurrency cause problem? we must guarante the used key cannot be used again if there are multiple servers reading keys concurrently, we might get a scenario where two or more servers try to read the same key from the db, how to solve it? servers uses KGS to read/mark keys in the db KGS can use two tables to store keys one for keys that are not used yet one for all the used keys As soon as KGS gives keys to one of the servers, it can move them to the used keys table KGS can always keep some keys in memory to quickly provide them whenever a server needs them if KGS dies before assigning all the loaded keys to some server, we will be wasting those keys –&gt; which could be acceptable, given the huge number of keys we have KGS also has to make sure not to give the same key to multiple servers it must synchronize(or get a lock on) the data structure holding the keys before removing keys from it and giving them to a server what would be the key-DB size? one byte to store one alpha-numeric character 6 (characters per key) * * 68.7B (unique keys) = 412 GB. Is not KGS a single point of failure? Yes, it is. have a standby replica of KGS Whenever the primary server dies, the standby server can take over to generate and provide keys Can each app server cache some keys form key-DB? Yes, this can surely speed things up Although. if the application server dies before consuming all the keys, we wil end up losing these keys this can be acceptable since we have 68B unique 6-letter keys How would we perforrm a key lookup? look up the key in the db to get the full url if it is in db, issue an ‘HTTP 302 Redirect’ status back to the browser, passing the stored URL in the ‘location’ field of the request if key is not present in the system, issue an ‘HTTP 404 not find’ status back or redirect the user back to the home page Should we impose size limits on custom aliases? service supports custom aliases it is reasonable and desirable to impose a size limit on the custom alias to ensure we have a consistent URL db Let’s assume users can specify a maximum of 16 characters per customer key Data Partitioning and ReplicationRange Based Partitioning Concept Store the URLs in seperate partitions based on the hash key’s first letter Even combine certain less frequency occurring letters into one db partition come up with a static partitioning scheme to always store/find a URL in a predictable manner Probelm leading to unbalanced DB servers For example, we decide to put all URLs starting with the letter ‘E’ into a DB partition, but later we realize that we have too many URLs that start with the letter ‘E.’ Hash-Based Partitioning Concept Take a hash of the object we are storing calculate which partition to use based upon the hash In our case: take the hash of the key or short link to determine the partition in which we store the data object Concept Lead to overloaded partitions, which can be solved using Consistent Hashing. Cache Overall Cache URLs that are frequently accessed Use off-the-shelf solution, like Memcached Store full URLs with their respective hashes Before hitting the backend storage, the application servers can quickly check if the cache has the desired the URL How much cache memory should we have? Start with 20% of daily traffic Based on clients’ usage patterns, we can adjust how many cache servers we need Thus, we need 170GB memory to cache 20% of daily traffic A modern-day server can have 256 GB memory, 170 GB can easily fit into the machine Alternatively, can use a couple of smaller servers to store all these hot URLs which cache eviction policy would best fit our needs? LRU –&gt; discard the least recently used URL first can use a Linked Hash Map or a similar data structure to store our URLs and Hashes, which will also keep track of the URLs that have been accessed recently To further increase the efficiency, we can replicate our caching servers to distribute the load between them Load Balancer(LB) Add a load balancing layer at three places in our system Between Clients and Application servers Between Appliction Servers and database servers Between Application Servers and cache servers Using a simple Round Robin approach Advantage Distributes incoming requests equally among backend servers simple to implement and does not introduce any overhead if a server is dead, LB will take it out of the rotation and will stop sending any traffice to it Disvantage not take the server load into consideration If a server is overloaded or slow, LB will not stop sending new requests to that server Solution a more intelligent LB solution can be placed that periodically queires the backend server about its load and adjusts traffic based on that Purging or DB cleanup If we chose to actively search for expired links to remove them, it would put a lot of pressure on our db. Insteas, we do a lazy clean up whenever a user tries to access an expired link, we can delete the link and return an error to the user A seperate cleanup service can run periodically to remove expired links from our storage and cache This service should be very lighweight and can be scheduled to run only when the user traffic is expected to be low we can have a default expiration time for each link(like: two years) after removing an expired linke, we can put the key back in the key-DB to be reused Should we remove links that have not been visited in some length of time, say 6 months? This could be tricky Since storage is getting cheap, we can decide to keep this links forever TelemetrySome statistics worth tracking: country of the visitor, date and time of access, web page that referred the click, browser, or platform from where the page was accessed. Security and Permissions We can store the permission level (public/private) with each URL in the database. We can also create a separate table to store UserIDs that have permission to see a specific URL. If a user does not have permission and tries to access a URL, we can send an error (HTTP 401) back. Given that we are storing our data in a NoSQL wide-column database like Cassandra, the key for the table storing permissions would be the ‘Hash’ (or the KGS generated ‘key’). The columns will store the UserIDs of those users that have permission to see the URL.","categories":[{"name":"System Design","slug":"System-Design","permalink":"https://jojoyang666.github.io/categories/System-Design/"}],"tags":[]},{"title":"369. Plus One Linked List","slug":"369-Plus-One-Linked-List","date":"2020-09-23T17:17:53.000Z","updated":"2020-09-23T17:41:18.524Z","comments":true,"path":"2020/09/23/369-Plus-One-Linked-List/","link":"","permalink":"https://jojoyang666.github.io/2020/09/23/369-Plus-One-Linked-List/","excerpt":"","text":"Sentinel Head 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def plusOne(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" sentinel = ListNode(0) sentinel.next = head not_nine = sentinel while head: if head.val != 9: not_nine = head head = head.next not_nine.val += 1 not_nine = not_nine.next while not_nine: not_nine.val = 0 not_nine = not_nine.next return sentinel if sentinel.val else sentinel.next 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var plusOne = function(head) &#123; const setinel = new ListNode(0, head) let not_nine = setinel while (head) &#123; if (head.val != 9) not_nine = head head = head.next &#125; not_nine.val += 1 not_nine = not_nine.next while(not_nine) &#123; not_nine.val = 0 not_nine = not_nine.next &#125; return setinel.val ? setinel : setinel.next&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"963. Minimum Area Rectangle II","slug":"963-Minimum-Area-Rectangle-II","date":"2020-09-23T15:29:33.000Z","updated":"2020-09-23T17:18:38.588Z","comments":true,"path":"2020/09/23/963-Minimum-Area-Rectangle-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/23/963-Minimum-Area-Rectangle-II/","excerpt":"","text":"Solution 1Iterate centers 123456789101112131415161718class Solution(object): def minAreaFreeRect(self, points): \"\"\" :type points: List[List[int]] :rtype: float \"\"\" points = [complex(*z) for z in points] seen = collections.defaultdict(list) for P, Q in itertools.combinations(points, 2): center = (P + Q) / 2 radius = abs(center - P) seen[center, radius].append(P) ans = float(\"inf\") for (center, radius), candidates in seen.iteritems(): for P, Q in itertools.combinations(candidates, 2): ans = min(ans, abs(P-Q) * abs(P - (2*center - Q))) return ans if ans &lt; float(\"inf\") else 0 Solution 2Iterate triangles 123456789101112131415161718192021class Solution(object): def minAreaFreeRect(self, points): \"\"\" :type points: List[List[int]] :rtype: float \"\"\" EPS = 1e-7 points = set(map(tuple, points)) ans = float('inf') for p1, p2, p3 in itertools.permutations(points, 3): p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1] if p4 in points: v21 = complex(p2[0] - p1[0], p2[1] - p1[1]) v31 = complex(p3[0] - p1[0], p3[1] - p1[1]) if abs(v21.real * v31.real + v21.imag * v31.imag) &lt; EPS: area = abs(v21) * abs(v31) if area &lt; ans: ans = area return ans if ans &lt; float('inf') else 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"353. Design Snake Game ","slug":"353-Design-Snake-Game","date":"2020-09-23T04:20:09.000Z","updated":"2020-09-23T05:14:00.591Z","comments":true,"path":"2020/09/22/353-Design-Snake-Game/","link":"","permalink":"https://jojoyang666.github.io/2020/09/22/353-Design-Snake-Game/","excerpt":"","text":"Deque 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class SnakeGame(object): def __init__(self, width, height, food): \"\"\" Initialize your data structure here. @param width - screen width @param height - screen height @param food - A list of food positions E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. :type width: int :type height: int :type food: List[List[int]] \"\"\" self.snake = collections.deque([[0, 0]]) self.food = collections.deque(food) self.width = width self.height = height self.direct = &#123;'U': [-1, 0], 'L': [0, -1], 'R': [0, 1], 'D': [1, 0]&#125; def move(self, direction): \"\"\" Moves the snake. @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down @return The game's score after the move. Return -1 if game over. Game over when snake crosses the screen boundary or bites its body. :type direction: str :rtype: int \"\"\" newHead = [self.snake[0][0] + self.direct[direction][0], self.snake[0][1] + self.direct[direction][1]] # notice that the newHead can be equal to self.snake[-1] if newHead[0] &lt; 0 or newHead[0] &gt;= self.height or newHead[1] &lt; 0 or newHead[1] &gt;= self.width or (newHead in self.snake and newHead != self.snake[-1]) : return -1 if self.food and self.food[0] == newHead: self.snake.appendleft(newHead) self.food.popleft() else: self.snake.appendleft(newHead) self.snake.pop() return len(self.snake) - 1# Your SnakeGame object will be instantiated and called as such:# obj = SnakeGame(width, height, food)# param_1 = obj.move(direction) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Initialize your data structure here. @param width - screen width @param height - screen height @param food - A list of food positions E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. * @param &#123;number&#125; width * @param &#123;number&#125; height * @param &#123;number[][]&#125; food */var SnakeGame = function(width, height, food) &#123; this.width = width this.height = height this.food = food this.snake = [[0, 0]]&#125;;/** * Moves the snake. @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down @return The game's score after the move. Return -1 if game over. Game over when snake crosses the screen boundary or bites its body. * @param &#123;string&#125; direction * @return &#123;number&#125; */SnakeGame.prototype.move = function(direction) &#123; const dir = &#123;'U': [-1, 0], 'L': [0, -1], 'D': [1, 0], 'R': [0, 1]&#125; const newHead = [this.snake[0][0] + dir[direction][0], this.snake[0][1] + dir[direction][1]] if (newHead[0] &lt; 0 || newHead[0] &gt;= this.height || newHead[1] &lt; 0 || newHead[1] &gt;= this.width || (ifHas(this.snake, newHead) &amp;&amp; !isEqual(this.snake[this.snake.length-1], newHead))) &#123; return -1 &#125; if (this.food &amp;&amp; isEqual(this.food[0], newHead)) &#123; this.food.shift() this.snake.splice(0, 0, newHead) &#125; else &#123; this.snake.splice(0, 0, newHead) this.snake.pop() &#125; return this.snake.length - 1&#125;;const ifHas = (a, b) =&gt; &#123; let idx = a.findIndex((item) =&gt; &#123; return isEqual(item, b) &#125;) return idx !== -1&#125;const isEqual = (a, b) =&gt; &#123; if (a == b) return true if (!a || !b) return false if (a.length === b.length) &#123; for (let i = 0; i &lt; a.length; i++) &#123; if (a[i] !== b[i]) return false &#125; return true &#125; return false&#125;/** * Your SnakeGame object will be instantiated and called as such: * var obj = new SnakeGame(width, height, food) * var param_1 = obj.move(direction) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"951. Flip Equivalent Binary Trees","slug":"951-Flip-Equivalent-Binary-Trees","date":"2020-09-23T00:32:32.000Z","updated":"2020-09-23T01:54:44.186Z","comments":true,"path":"2020/09/22/951-Flip-Equivalent-Binary-Trees/","link":"","permalink":"https://jojoyang666.github.io/2020/09/22/951-Flip-Equivalent-Binary-Trees/","excerpt":"","text":"Solution 11234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def flipEquiv(self, root1, root2): \"\"\" :type root1: TreeNode :type root2: TreeNode :rtype: bool \"\"\" if root1 is root2: return True if not root1 or not root2 or root1.val != root2.val: return False return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right) or self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)) 123456789101112131415161718192021222324/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root1 * @param &#123;TreeNode&#125; root2 * @return &#123;boolean&#125; */var flipEquiv = function(root1, root2) &#123; if (root1 === root2) &#123; return true; &#125; if (!root1 || !root2 || root1.val !== root2.val) &#123; return false &#125; return (flipEquiv(root1.left, root2.left) &amp;&amp; flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) &amp;&amp; flipEquiv(root1.right, root2.left))&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"applyMiddleware","slug":"applyMiddleware","date":"2020-09-22T22:45:57.000Z","updated":"2020-09-23T05:20:56.545Z","comments":true,"path":"2020/09/22/applyMiddleware/","link":"","permalink":"https://jojoyang666.github.io/2020/09/22/applyMiddleware/","excerpt":"","text":"Function: applyMiddleware(…middleware) Arguments ...middleware Functions that conform to the Redux middleware API Each middleware receives Store‘s dispatch and getState functions as named argument, and returns a function That function will be given the next middleware’s dispath method, and is expected to return a function of actioncalling next(action) with a potentially different argument, or at a different time, or maybe not calling it at all The last middleware in the chain will receive the real store’s dispatch method as the next parameter, thus ending the chain Thus, the middleware signature is ({getState, dispatch}) =&gt; next =&gt; action","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"Redux","slug":"Front-End/Redux","permalink":"https://jojoyang666.github.io/categories/Front-End/Redux/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"Redux","slug":"Redux","permalink":"https://jojoyang666.github.io/tags/Redux/"}]},{"title":"Apollo","slug":"Apollo","date":"2020-09-22T19:09:34.000Z","updated":"2020-09-22T22:34:55.420Z","comments":true,"path":"2020/09/22/Apollo/","link":"","permalink":"https://jojoyang666.github.io/2020/09/22/Apollo/","excerpt":"","text":"Intro A comprehensive state management library for Javascript that enables you to manage both local and remote data with GraphQL Appollo Client Cache – what we can configure Specify custom primary key fields Customize the storage and retrival of individual fields Customize the interpretation of field arguments Define supertype-subtype relationsips for fragment matching Define patterns for pagination Manage client-side local state ApolloClient: encapsulates Apollo’s core client-side API. It backs all available view-layer integrations constructor for ApolloClient accepts an ApolloClientOptions object that supports the required and optional fields listed below Required One: uri: A URI pointing to the backend GraphQL endpoint that Apollo Client will communicate with. Note: One of uri ir link is required; if both are specified, link will take precedence link: You can provide an Apollo link instance to serve as Apollo Client’s network layer cache: Apollo Client uses an Apollo Cache instance to handle its caching strategy GraphQL Client apollo-link-http: a system of modular components for GraphQL networking Is a terminating link that fetches GraphQL results from a GraphQl endpoint over an http connection The http link supports both POST and GET requests with the ability to change the http options on a per query basis This can be used for authentication, persisted queries, dynamic uris, and other granular updates apollo-link-http setContext takes a function that returns either an object or a promise that returns an object to set the new context of a request Receive two arguments: The GraphQL request being executed, and the previous context This link makes it easy to perform async look up of things like authentication tokens and more apollo-cache-inmemory InMemoryCache: is a normalized data store that supports all of Apollo client feactures without the dependency Redux 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; ApolloClient &#125; from \"apollo-client\"import &#123; createHttpLink &#125; from \"apollo-link-http\"import &#123; InMemoryCache &#125; from \"apollo-cache-inmemory\"import &#123; setContext &#125; from \"appollo-link-context\"import fetchPollyfill from \"unfetch\"let httpLink = nulllet httplinkConfig = nullif (!window.fetch) &#123; httpLink = createHttpLink(&#123; uri: \"****\", fetch: fetchPollyfill &#125;) httplinkConfig = createHttpLink(&#123; uri: \"****\", fetch: fetchPollyfill &#125;)&#125; else &#123; httpLink = createHttpLink(&#123; uri: \"****\" &#125;) httplinkConfig = createHttpLink(&#123; uri: \"****\" &#125;)&#125;const authLink = setContext((_, &#123; headers&#125;) =&gt; &#123; return &#123; headers: &#123; ...headers, //other settings &#125; &#125;&#125;)const client = new ApolloClient(&#123; link: authLink.concat(httpLink), cache: new InMemoryCache(&#123; addTypename: false &#125;)&#125;)client.configClient = new ApolloClient(&#123; link: authLink.concat(httplinkConfig); cache: new InMemoryCache(&#123; addTypename: false &#125;)&#125;)&#125;) Apollo MiddlewareIntegrated with Redux 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576export default function apolloMiddleware(graphQlClient) &#123; return (&#123;dispatch, getState&#125;) =&gt; &#123; return next =&gt; (action) =&gt; &#123; if (typeof action === \"function\") &#123; // thunk return action(dispatch, getState) &#125; const &#123; mutation, query, types. variables, fetchPolicy = \"cahce-first\", errorPolicy = \"none\", pollInterval, notifyOnNetworkStatusChange = false, context, ...rest &#125; = action; if (!query &amp;&amp; !mutation) &#123; //no query, no mutation, nothing to do here // return next(action) return Promise.resolve(next(action)) &#125; const [REQUEST, SUCCESS, FAILURE] = types next(&#123;...rest, type: REQUEST, variables: variables&#125;) // graphql mutations if (mutation) &#123; if (variables &amp;&amp; variables.configClient) &#123; return graphQlClient.configClient.mutate(&#123;mutation, variables&#125;).then( result =&gt; next(&#123;...rest, ...result, type: SUCCESS&#125;), error =&gt; next(&#123;...rest, error, type: FAILURE&#125;) ) &#125; else &#123; return graphQlClient.mutate(&#123;mutation, variables&#125;).then( result =&gt; next(&#123;...rest, ...result, type: SUCCESS&#125;), error =&gt; next(&#123;...restm error, type: FAILURE&#125;) ) &#125; &#125; // graphql queries if (variables &amp;&amp; variables.configClient) &#123; return graphQlClient.configClient.query(&#123; query, variables, fetchPolicy, errorPolicy, pollInterval, notifyOnNetworkStatusChange, context &#125;).then( result =&gt; next(&#123;...rest, result: &#123;...result&#125;, type: SUCCESS, variables&#125;), error =&gt; next(&#123;...rest, error, type: FAILURE&#125;) ) &#125; else &#123; return graphQlClient.configClient.query(&#123; query, variables, fetchPolicy, errorPolicy, pollInterval, notifyOnNetworkStatusChange, context &#125;).then( result =&gt; next(&#123;...rest, result: &#123;...result&#125;, type: SUCCESS, variables&#125;), error =&gt; next(&#123;...rest, error, type: FAILURE&#125;) ) &#125; &#125; &#125;&#125;","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"GraphQL","slug":"Front-End/GraphQL","permalink":"https://jojoyang666.github.io/categories/Front-End/GraphQL/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://jojoyang666.github.io/tags/GraphQL/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"}]},{"title":"RectDom","slug":"RectDom","date":"2020-09-22T18:51:21.000Z","updated":"2020-10-02T01:23:10.313Z","comments":true,"path":"2020/09/22/RectDom/","link":"","permalink":"https://jojoyang666.github.io/2020/09/22/RectDom/","excerpt":"","text":"Overall If load react from a &lt;script&gt; tag, these top-level APIs are available on the ReactDOM global unmountComponentAtNode()ReactDOM.unmountComponentAtNode(container) Remove a mounted React component from the DOM and clean up its event heanlders and state If no component was mounted in the container, calling this function does nothing Return true if a component was unmounted and false if there was no component to unmount https://mp.weixin.qq.com/s/BVXLQRL94VvM9tOa62LQKQhttps://mp.weixin.qq.com/s/02PjNVAboA3KwQiffcp-1Q","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"}]},{"title":"System Design Step Guide","slug":"System-Design-Step-Guide","date":"2020-09-22T15:34:59.000Z","updated":"2020-09-22T16:51:43.607Z","comments":true,"path":"2020/09/22/System-Design-Step-Guide/","link":"","permalink":"https://jojoyang666.github.io/2020/09/22/System-Design-Step-Guide/","excerpt":"","text":"Step 1: Requirements clarifications Ask questions about the exact scope of the problem we are solving clarify the ambiguities early should clarify what parts of the system we will be focusing on Example of Twitter should be answered: will users of our service be able to post tweets and follow other people? should we also design to create and display the user’s timeline will tweets contain photos and videos are we focusing on the backend only or are we developing the front end too? will users be able to search tweets do we need to display hot trending topics will there be any push notification for new (or important) tweets Step 2: Back-of-the-envelope estimation estimate the scale of the system we’re going to design help later when we will be focusing on scaling, partitioning, load balancing and caching Common questions: what scale is expected from the system(e.g., number of new tweets, number of tweets views, number of timeline generations per sec., etc.) How much storage will we need? we will have different storage requirements if users can have photos and videos in their tweets what networkd bandwidth usage are we expecting? This will be crucial in deciding how we will manage traffic and balace load between servers Step 3: System interface definition Define what APIs are expected from the system establish the exact contract expected from the system Ensure if we have not gotten any requirements wrongpostTweet(user_id, tweet_data, tweet_location, user_location, timestamp, …)generateTimeline(user_id, current_time, user_location, …)markTweetFavorite(user_id, tweet_id, timestamp, …) Step 4 Defining Data Model claify how data will flow between different components of the system it will guide for data partitioning and management how they will intract with each other, and different aspects of data management like storage, transportation, encryption, etc. Example User: UserID, Name, Email, DoB, CreationData, LastLogin, etc. Tweet: TweetID, Content, TweetLocation, NumberOfLikes, TimeStamp, etc. UserFollow: UserID1, UserID2 FavoriteTweets: UserID, TweetID, TimeStamp Which Database should we use? NoSql like cassandra MySQL-like solution what kind of block should we use to store photos and videos Step 5: High-level design Block diagram with 5-6 boxes represeting the core components of our system enough components that are needed to solve the actual problem from end-to-end For twitter: need multiple application servers to serve all the read/write requests with load balancers in front of them for traffice distributions if we are assuming that we will have a lot more read traffic(compared to write), we can decide to have seperate servers for handling these scenarios On the backend, need efficient database that can store all the tweets and can support a huge number reads a ditributed file storage system for storing photos and videos Step 6: Detailed design Dig deeper into 2/3 major components Interviwer’s feedback should always guide us to what parts of the system need further discussion be able to present different approaces, their cons and pros, and explain why we prefer one approach on the other there is no single answer, the only important thing is to condider tradeoffs between different options while keeping system contraints in mind Example Since we will be storing a massive amount of data, how should we partition our data to distribute it to multiple database? should we try to store all the data of a user on the same database? what issue could it cause? Since users’ timeline will contain the most recent (and relevsnt) tweets, should we try to store our data in such a way that is optimized for scanning the latest tweets how much and at which layer should we introduce cache to speed things up? what components need better load balancing Step 7: Identifying and resolving bottlenecks Discuss as many bottlenecks as possible and different approaches to mitigate them Example Is there any single point of failure in our system? what are we doing to mitigate it? Do we have enough replicas of the data so that if we lose a few servers, we can still serve our users Do we have enough copies of different services running such that a few failures will not cause total system shutdown how are we monitoring the performace of our service? do we get alerts whenever critical fail or their performance degrades","categories":[{"name":"System Design","slug":"System-Design","permalink":"https://jojoyang666.github.io/categories/System-Design/"}],"tags":[]},{"title":"318. Maximum Product of Word Lengths","slug":"318-Maximum-Product-of-Word-Lengths","date":"2020-09-22T14:44:44.000Z","updated":"2020-09-22T15:20:00.871Z","comments":true,"path":"2020/09/22/318-Maximum-Product-of-Word-Lengths/","link":"","permalink":"https://jojoyang666.github.io/2020/09/22/318-Maximum-Product-of-Word-Lengths/","excerpt":"","text":"Bit Mask Solution 112345678910111213141516171819202122232425class Solution(object): def maxProduct(self, words): \"\"\" :type words: List[str] :rtype: int \"\"\" n = len(words) masks = [0] * n lens = [0] * n bit_number = lambda ch : ord(ch) - ord('a') for i in range(n): bitmask = 0 for ch in words[i]: bitmask |= 1 &lt;&lt; bit_number(ch) masks[i] = bitmask lens[i] = len(words[i]) max_val = 0 for i in range(n): for j in range(i+1, n): if masks[i] &amp; masks[j] == 0: max_val = max(max_val, lens[i] * lens[j]) return max_val 12345678910111213141516171819202122232425262728293031/** * @param &#123;string[]&#125; words * @return &#123;number&#125; */var maxProduct = function(words) &#123; const bitmasks = new Array(words.length).fill(0) const lens = new Array(words.length).fill(0) const bitNumber = (a) =&gt; a.charCodeAt(0) - 'a'.charCodeAt(0) words.forEach((word, i) =&gt; &#123; let bit = 0 for (let c of [...word]) &#123; bit |= 1 &lt;&lt; bitNumber(c) &#125; bitmasks[i] = bit lens[i] = word.length &#125;) let res = 0 for (let i = 0; i &lt; words.length; i++) &#123; for (let j = i + 1; j &lt; words.length; j++) &#123; if ((bitmasks[i] &amp; bitmasks[j]) === 0) &#123; res = Math.max(res, lens[i] * lens[j]) &#125; &#125; &#125; return res&#125;; Solution 2123456789101112131415161718192021class Solution(object): def maxProduct(self, words): \"\"\" :type words: List[str] :rtype: int \"\"\" hashmap = defaultdict(int) bit_number = lambda ch : ord(ch) - ord('a') for word in words: bitmask = 0 for ch in word: bitmask |= 1 &lt;&lt; bit_number(ch) hashmap[bitmask] = max(hashmap[bitmask], len(word)) max_prod = 0 for x in hashmap: for y in hashmap: if x &amp; y == 0: max_prod = max(max_prod, hashmap[x] * hashmap[y]) return max_prod 123456789101112131415161718192021222324252627282930/** * @param &#123;string[]&#125; words * @return &#123;number&#125; */var maxProduct = function(words) &#123; const map = &#123;&#125; const bitNumber = (a) =&gt; a.charCodeAt(0) - 'a'.charCodeAt(0) words.forEach((word, i) =&gt; &#123; let bit = 0 for (let c of [...word]) bit |= 1 &lt;&lt; bitNumber(c) if (map[bit] === undefined) &#123; map[bit] = 0 &#125; map[bit] = Math.max(map[bit], word.length) &#125;) let res = 0 for (let i of Object.keys(map)) &#123; for (let j of Object.keys(map)) &#123; if ((i &amp; j) === 0) &#123; res = Math.max(map[i]*map[j], res) &#125; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"946. Validate Stack Sequences","slug":"946-Validate-Stack-Sequences-1","date":"2020-09-22T14:05:34.000Z","updated":"2020-09-22T14:08:55.667Z","comments":true,"path":"2020/09/22/946-Validate-Stack-Sequences-1/","link":"","permalink":"https://jojoyang666.github.io/2020/09/22/946-Validate-Stack-Sequences-1/","excerpt":"","text":"Greedy 123456789101112131415class Solution(object): def validateStackSequences(self, pushed, popped): \"\"\" :type pushed: List[int] :type popped: List[int] :rtype: bool \"\"\" j = 0 stack = [] for x in pushed: stack.append(x) while stack and j &lt; len(popped) and stack[-1] == popped[j]: stack.pop() j += 1 return j == len(popped) 123456789101112131415161718/** * @param &#123;number[]&#125; pushed * @param &#123;number[]&#125; popped * @return &#123;boolean&#125; */var validateStackSequences = function(pushed, popped) &#123; const stack = [] let j = 0 for (let item of pushed) &#123; stack.push(item) while (j &lt; popped.length &amp;&amp; popped[j] === stack[stack.length - 1]) &#123; j++; stack.pop() &#125; &#125; return j === popped.length&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"505. The Maze II","slug":"505-The-Maze-II","date":"2020-09-22T05:15:21.000Z","updated":"2020-09-24T22:36:40.466Z","comments":true,"path":"2020/09/21/505-The-Maze-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/21/505-The-Maze-II/","excerpt":"","text":"Dijistra 123456789101112131415161718192021222324252627class Solution(object): def shortestDistance(self, maze, start, destination): \"\"\" :type maze: List[List[int]] :type start: List[int] :type destination: List[int] :rtype: int \"\"\" m, n, q, stopped = len(maze), len(maze[0]), [(0, start[0], start[1])], &#123;(start[0], start[1]): 0&#125; #dist must be first one in q while q: dist, x, y = heapq.heappop(q) if [x, y] == destination: return dist for i, j in ((1, 0), (-1, 0), (0, 1), (0, -1)): newX, newY, d = x, y, 0 while 0 &lt;= newX + i &lt; m and 0 &lt;= newY + j &lt; n and maze[newX + i][newY + j] != 1: newX += i newY += j d += 1 if (newX, newY) not in stopped or d + dist &lt; stopped[(newX, newY)]: stopped[(newX, newY)] = dist + d heapq.heappush(q, (dist + d, newX, newY)) return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"946-Validate-Stack-Sequences","slug":"946-Validate-Stack-Sequences","date":"2020-09-22T05:13:03.111Z","updated":"2020-09-22T05:17:47.637Z","comments":true,"path":"2020/09/21/946-Validate-Stack-Sequences/","link":"","permalink":"https://jojoyang666.github.io/2020/09/21/946-Validate-Stack-Sequences/","excerpt":"","text":"title: 946. Validate Stack Sequencesdate: 2020-09-21 22:13:03tags:categories: Leetcode","categories":[],"tags":[]},{"title":"457. Circular Array Loop","slug":"457-Circular-Array-Loop","date":"2020-09-21T23:12:34.000Z","updated":"2020-09-22T02:33:26.408Z","comments":true,"path":"2020/09/21/457-Circular-Array-Loop/","link":"","permalink":"https://jojoyang666.github.io/2020/09/21/457-Circular-Array-Loop/","excerpt":"","text":"题目中循环必须是 forward 或是 backward 的。 Solution 112345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var circularArrayLoop = function(nums) &#123; const visited = new Array(nums.length).fill(false) const n = nums.length for (let i = 0; i &lt; nums.length; i++) &#123; if (visited[i]) continue; visited[i] = true let cur = i const map = &#123;&#125; while (true) &#123; let next = (((cur + nums[cur])%n) + n)%n if (next === cur || nums[next] * nums[cur] &lt; 0) break; if (map[next] !== undefined) return true; map[cur] = next; cur = next; visited[next] = true; &#125; &#125; return false;&#125;; 1234567891011121314151617181920212223242526272829class Solution(object): def circularArrayLoop(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" n = len(nums) visited = [False] * n for i in xrange(n): if visited[i]: continue cur = i map = &#123;&#125; while True: visited[cur] = True next = (((cur + nums[cur])%n) + n)%n if cur == next or nums[cur] * nums[next] &lt; 0: break if next in map: return True map[cur] = next cur = next return False Solution 2O(n) time complexity, O(1) space complexity 快慢指针来解决 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var circularArrayLoop = function(nums) &#123; for (let i = 0; i &lt; nums.length; i++) &#123; if (!nums[i]) continue; let slow = i, fast = getIndex(i, nums) //做同方向的排除 while (nums[i] * nums[fast] &gt; 0 &amp;&amp; nums[getIndex(fast, nums)] * nums[i] &gt; 0) &#123; if (slow === fast) &#123;// check if the loop only have one element if (slow === getIndex(fast, nums)) &#123; break &#125; return true; &#125; slow = getIndex(slow, nums) fast = getIndex(getIndex(fast, nums), nums) &#125; // make the visted element to be zero slow = i let val = nums[slow] while (nums[slow] * val &gt; 0) &#123; let next = getIndex(slow, nums) nums[slow] = 0 slow = next &#125; &#125; return false&#125;;const getIndex = (i, nums) =&gt; &#123; const n = nums.length return ((i + nums[i])%n + n)%n;&#125; 1234567891011121314151617181920212223242526272829303132class Solution(object): def circularArrayLoop(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" n = len(nums) def getIndex(i): return ((nums[i] + i)%n + n)%n for i in xrange(n): if nums[i] == 0: continue slow, fast = i, getIndex(i) while nums[i] * nums[fast] &gt; 0 and nums[getIndex(fast)] * nums[i] &gt; 0: if slow == fast: if fast == getIndex(fast): break return True slow = getIndex(slow) fast = getIndex(getIndex(fast)) val = nums[i] slow = i while val * nums[slow] &gt; 0: tmp = getIndex(slow) nums[slow] = 0 slow = tmp return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"900. RLE Iterator","slug":"900-RLE-Iterator","date":"2020-09-19T00:12:23.000Z","updated":"2020-09-19T00:13:28.185Z","comments":true,"path":"2020/09/18/900-RLE-Iterator/","link":"","permalink":"https://jojoyang666.github.io/2020/09/18/900-RLE-Iterator/","excerpt":"","text":"12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; A */var RLEIterator = function(A) &#123; this.A = A this.cur = 0&#125;;/** * @param &#123;number&#125; n * @return &#123;number&#125; */RLEIterator.prototype.next = function(n) &#123; while (this.cur &lt; this.A.length &amp;&amp; n &gt; this.A[this.cur]) &#123; n -= this.A[this.cur] this.cur += 2 &#125; if (this.cur &gt;= this.A.length) return -1 this.A[this.cur] -= n return this.A[this.cur + 1]&#125;;/** * Your RLEIterator object will be instantiated and called as such: * var obj = new RLEIterator(A) * var param_1 = obj.next(n) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"849. Maximize Distance to Closest Person","slug":"849-Maximize-Distance-to-Closest-Person","date":"2020-09-18T22:21:13.000Z","updated":"2020-09-18T22:39:42.885Z","comments":true,"path":"2020/09/18/849-Maximize-Distance-to-Closest-Person/","link":"","permalink":"https://jojoyang666.github.io/2020/09/18/849-Maximize-Distance-to-Closest-Person/","excerpt":"","text":"1234567891011121314151617181920/** * @param &#123;number[]&#125; seats * @return &#123;number&#125; */var maxDistToClosest = function(seats) &#123; let start = 0, res = 0 for (let i = 0; i &lt; seats.length; i++) &#123; if (seats[i]) &#123; if (start === 0) res = Math.max(res, i - start); else &#123; res = Math.max(res, (i - start + 1) &gt;&gt; 1)//连续0的中点 &#125; start = i + 1//如果下个位置依旧有人坐， 那么dist=0没有影响， start真正有有效的值的时候是在没有人做的时候 &#125; &#125; res = Math.max(res, seats.length - start) return res&#125;; 12345678910111213141516class Solution(object): def maxDistToClosest(self, seats): \"\"\" :type seats: List[int] :rtype: int \"\"\" start, res = 0, 0 for i, seat in enumerate(seats): if seat: if start == 0: res = max(res, i - start) else: res = max(res, (i - start + 1)/2) start = i + 1 res = max(res, len(seats) - start) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"659. Split Array into Consecutive Subsequences","slug":"659-Split-Array-into-Consecutive-Subsequences","date":"2020-09-18T19:30:03.000Z","updated":"2020-09-18T21:46:24.885Z","comments":true,"path":"2020/09/18/659-Split-Array-into-Consecutive-Subsequences/","link":"","permalink":"https://jojoyang666.github.io/2020/09/18/659-Split-Array-into-Consecutive-Subsequences/","excerpt":"","text":"重点： 整个array 都能分成几个subsequences123456789101112131415161718192021222324class Solution(object): def isPossible(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" count = collections.Counter(nums) tails = collections.Counter() for num in nums: if count[num] == 0: continue elif tails[num] &gt; 0: tails[num] -= 1 tails[num+1] += 1 elif count[num + 1] &gt; 0 and count[num + 2] &gt; 0: count[num+1] -= 1 count[num+2] -= 1 tails[num+3] += 1 else: return False count[num] -= 1 return True Javascript: 常见错误在foreach中return， foreach相当于一个function在里面return并不是在最后的方程中return 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var isPossible = function(nums) &#123; const counter = &#123;&#125; const tail = &#123;&#125; nums.forEach(num =&gt; &#123; if (counter[num] === undefined) &#123; counter[num] = 0 &#125; counter[num]++; tail[num] = 0 &#125;) for (let num of nums) &#123; if (counter[num] &gt; 0) &#123; if (tail[num]) &#123; tail[num] -= 1 tail[num+1] += 1 &#125; else if (counter[num+1] &gt; 0 &amp;&amp; counter[num+2] &gt; 0) &#123; tail[num+3] += 1 counter[num+1] -= 1 counter[num+2] -= 1 &#125; else &#123; return false &#125; counter[num] -= 1 &#125; &#125; return true&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"320. Generalized Abbreviation","slug":"320-Generalized-Abbreviation","date":"2020-09-18T16:25:34.000Z","updated":"2020-09-18T18:28:28.446Z","comments":true,"path":"2020/09/18/320-Generalized-Abbreviation/","link":"","permalink":"https://jojoyang666.github.io/2020/09/18/320-Generalized-Abbreviation/","excerpt":"","text":"Iterative wayusing bit to represent word123456789101112131415161718192021222324252627/** * @param &#123;string&#125; word * @return &#123;string[]&#125; */var generateAbbreviations = function(word) &#123; const res = [] for (let i = 0; i &lt; Math.pow(2, word.length); i++) &#123; let out = \"\", cnt = 0 for (let j = 0; j &lt; word.length; j++) &#123; if ((i &gt;&gt; j) &amp; 1) cnt++; else &#123; if (cnt !== 0) &#123; out += cnt + ''; cnt = 0; &#125; out += word.charAt(j) &#125; &#125; if (cnt &gt; 0) out += cnt + '' res.push(out) &#125; return res&#125;; 12345678910111213141516171819202122class Solution(object): def generateAbbreviations(self, word): \"\"\" :type word: str :rtype: List[str] \"\"\" res = [] for i in xrange(pow(2, len(word))): cnt, out = 0, \"\" for j in xrange(len(word)): if (i &gt;&gt; j) &amp; 1: cnt+=1 else: if cnt != 0: out += str(cnt) cnt = 0 out += word[j] if cnt &gt; 0: out += str(cnt) res.append(out) return res Recursive way — backtrackiing1234567891011121314151617181920/** * @param &#123;string&#125; word * @return &#123;string[]&#125; */var generateAbbreviations = function(word) &#123; const res = [] helper(word, 0, res) res.push(word) return res&#125;;const helper = (word, pos, res) =&gt; &#123; for (let i = pos; i &lt; word.length; i++) &#123; for (let j = 1; i + j &lt;= word.length; j++) &#123; const t = word.substring(0, i) + j + word.substring(i + j) res.push(t) helper(t, i + 1 + j.toString().length, res) &#125; &#125;&#125; 12345678910111213141516class Solution(object): def generateAbbreviations(self, word): \"\"\" :type word: str :rtype: List[str] \"\"\" res = [] res.append(word) def helper(w, pos): for i in xrange(pos, len(w)): for j in xrange(1, len(w) - i + 1): t = w[0:i] + str(j) + w[i + j:] res.append(t) helper(t, i + 1 + len(str(j))) helper(word, 0) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"406. Queue Reconstruction by Height","slug":"406-Queue-Reconstruction-by-Height","date":"2020-09-17T16:40:09.000Z","updated":"2020-09-17T16:52:17.083Z","comments":true,"path":"2020/09/17/406-Queue-Reconstruction-by-Height/","link":"","permalink":"https://jojoyang666.github.io/2020/09/17/406-Queue-Reconstruction-by-Height/","excerpt":"","text":"sort by the hight(reversed), insert by the index1234567891011class Solution(object): def reconstructQueue(self, people): \"\"\" :type people: List[List[int]] :rtype: List[List[int]] \"\"\" people.sort(key=lambda x: (-x[0], x[1])) output = [] for p in people: output.insert(p[1], p) return output 123456789101112131415161718192021/** * @param &#123;number[][]&#125; people * @return &#123;number[][]&#125; */var reconstructQueue = function(people) &#123; people.sort((a, b) =&gt; &#123; if (a[0] !== b[0]) &#123; return b[0] - a[0] &#125; else &#123; return a[1] - b[1] &#125; &#125;) let res = [] for (const person of people) &#123; // or right in this way: res.splice(person[1], 0, person) res = [...res.slice(0, person[1]), person, ...res.slice(person[1])] &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"362. Design Hit Counter","slug":"362-Design-Hit-Counter","date":"2020-09-17T04:57:32.000Z","updated":"2020-09-17T05:20:40.274Z","comments":true,"path":"2020/09/16/362-Design-Hit-Counter/","link":"","permalink":"https://jojoyang666.github.io/2020/09/16/362-Design-Hit-Counter/","excerpt":"","text":"选择合适的数据结构12345678910111213141516171819202122232425262728293031323334353637/** * Initialize your data structure here. */var HitCounter = function() &#123; this.queue = []&#125;;/** * Record a hit. @param timestamp - The current timestamp (in seconds granularity). * @param &#123;number&#125; timestamp * @return &#123;void&#125; */HitCounter.prototype.hit = function(timestamp) &#123; this.queue.push(timestamp)&#125;;/** * Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). * @param &#123;number&#125; timestamp * @return &#123;number&#125; */HitCounter.prototype.getHits = function(timestamp) &#123; while(this.queue.length &amp;&amp; (timestamp - this.queue[0] &gt;= 300)) &#123; this.queue.shift() &#125; return this.queue.length&#125;;/** * Your HitCounter object will be instantiated and called as such: * var obj = new HitCounter() * obj.hit(timestamp) * var param_2 = obj.getHits(timestamp) */ Follow UpWhat if the number of hits per second could be very large? Does your design scale? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Initialize your data structure here. */var HitCounter = function() &#123; this.times = new Array(300) this.hits = new Array(300)&#125;;/** * Record a hit. @param timestamp - The current timestamp (in seconds granularity). * @param &#123;number&#125; timestamp * @return &#123;void&#125; */HitCounter.prototype.hit = function(timestamp) &#123; let idx = timestamp%300; if (this.times[idx] !== timestamp) &#123; this.times[idx] = timestamp this.hits[idx] = 1 &#125; else &#123; this.hits[idx]++; &#125;&#125;;/** * Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). * @param &#123;number&#125; timestamp * @return &#123;number&#125; */HitCounter.prototype.getHits = function(timestamp) &#123; let res = 0 for (let i = 0; i &lt; 300; i++) &#123; if (timestamp - this.times[i] &lt; 300) &#123; res += this.hits[i] &#125; &#125; return res&#125;;/** * Your HitCounter object will be instantiated and called as such: * var obj = new HitCounter() * obj.hit(timestamp) * var param_2 = obj.getHits(timestamp) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"bfs, dfs, backtracking, Dijkstra","slug":"bfs-dfs-backtracking-Dijkstra","date":"2020-09-16T19:11:13.000Z","updated":"2020-10-08T19:32:42.164Z","comments":true,"path":"2020/09/16/bfs-dfs-backtracking-Dijkstra/","link":"","permalink":"https://jojoyang666.github.io/2020/09/16/bfs-dfs-backtracking-Dijkstra/","excerpt":"","text":"General 可以用掩码token &amp; (1 &lt;&lt; i)和token | (1 &lt;&lt; i)来看这个ith item是否用过， 并且更新他的状态 BFS + DFS add visited set 考虑是否 有重复情况， 如果有可以用memo Backtracking find all the possible solutions used-thing —-&gt; 123used(flag -&gt; true)recursivefuncition()used(flag -&gt; false -&gt; reset to initial funtion) In recursive function: 明确触底条件 Dijkstra 算法特点 bfs解决赋权有向图或者无向图的单源最短路径问题 算法的思路 dis保存源点（s）到各个顶点的最短路径 T: 已经找到了最短路径顶点的集合 初始赋值： dis[s] = 0 s顶点能直接到达的边(s, m) —&gt; dis[m] = w(s, m) s不能到达的点设置为无穷大 从dis中选择最小值， 将该点加入T中 从T中新加入的点来看是否可以到达其他顶点v 并且 看看通过该顶点到其他点v的路径长度， 是否比dis[v]小， 如果是， update dis[v], 然后从dis中选择最小值， 将该点加入T中， 重复改操作， 直到T中包含了图中的所有顶点 Topological sort 判断有向图环是否存在 123456789101112131415161718192021222324252627282930313233343536373839class GNode(object): def __init__(self): self.inDegrees = 0 self.outNodes = [] class Solution(object): def canFinish(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool \"\"\" graph = defaultdict(GNode) totalDeps = 0 for relation in prerequisites: nextCourse, prevCourse = relation[0], relation[1] graph[prevCourse].outNodes.append(nextCourse) graph[nextCourse].inDegrees += 1 totalDeps += 1 nodeCourses = [] for course, node in graph.items(): if node.inDegrees == 0: nodeCourses.append(course) removedEdges = 0 while nodeCourses: course = nodeCourses.pop() for nextCourse in graph[course].outNodes: graph[nextCourse].inDegrees -= 1 removedEdges += 1 if graph[nextCourse].inDegrees == 0: nodeCourses.append(nextCourse) return True if removedEdges == totalDeps else False 得到拓扑排序 12345678910111213141516171819202122232425262728class Solution(object): def findOrder(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] \"\"\" adj_list = defaultdict(list) indegree = &#123;&#125; for dest, src in prerequisites: adj_list[src].append(dest) indegree[dest] = indegree.get(dest, 0) + 1 zero_indegree_queue = [k for k in range(numCourses) if k not in indegree] topological_sorted_order = [] while zero_indegree_queue: v = zero_indegree_queue.pop() topological_sorted_order.append(v) if v in adj_list: for nei in adj_list[v]: indegree[nei] -= 1 if indegree[nei] == 0: zero_indegree_queue.append(nei) return topological_sorted_order if len(topological_sorted_order) == numCourses else []","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1066. Campus Bikes II","slug":"1066-Campus-Bikes-II","date":"2020-09-16T18:24:26.000Z","updated":"2020-09-16T20:02:39.436Z","comments":true,"path":"2020/09/16/1066-Campus-Bikes-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/16/1066-Campus-Bikes-II/","excerpt":"","text":"bfs + pq 12345678910111213141516171819202122232425class Solution(object): def assignBikes(self, workers, bikes): \"\"\" :type workers: List[List[int]] :type bikes: List[List[int]] :rtype: int \"\"\" def dis(i, j): return abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]) h = [[0, 0, 0]] seen = set() while True: cost, i, taken = heapq.heappop(h) if (i, taken) in seen: continue seen.add((i, taken)) if i == len(workers): return cost for j in xrange(len(bikes)): if taken &amp; (1 &lt;&lt; j) == 0: heapq.heappush(h, [cost + dis(i, j), i + 1, taken | (1 &lt;&lt; j)]) backtracking 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[][]&#125; workers * @param &#123;number[][]&#125; bikes * @return &#123;number&#125; */var assignBikes = function(workers, bikes) &#123; const used = new Set() let res = Infinity; const calDist = (i, j) =&gt; &#123; return Math.abs(workers[i][0] - bikes[j][0]) + Math.abs(workers[i][1] - bikes[j][1]) &#125; const go = (i, dis) =&gt; &#123; if (i === workers.length) &#123; res = Math.min(res, dis) return; &#125; bikes.forEach((bike, idx) =&gt; &#123; if (!used.has(bike)) &#123; const dist = calDist(i, idx) used.add(bike) go(i + 1, dis + dist) used.delete(bike) &#125; &#125;) &#125; go(0, 0) return res&#125;; Dijistra 12345678910111213141516171819202122232425262728class Solution(object): def assignBikes(self, workers, bikes): \"\"\" :type workers: List[List[int]] :type bikes: List[List[int]] :rtype: int \"\"\" def dist(i, j): return abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]) h = [[0, 0, 0]] optimal = defaultdict(lambda: float('inf')) while True: cost, i, taken = heapq.heappop(h) if i == len(workers): return cost for j, bike in enumerate(bikes): if taken &amp; (1 &lt;&lt; j) == 0: new_cost = cost + dist(i, j) new_taken = taken | (1 &lt;&lt; j) if new_cost &lt; optimal[(i+1, new_taken)]: optimal[(i+1, new_taken)] = new_cost heapq.heappush(h, [new_cost, i + 1, new_taken])","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"833. Find And Replace in String","slug":"833-Find-And-Replace-in-String","date":"2020-09-16T03:21:10.000Z","updated":"2020-09-16T05:17:18.345Z","comments":true,"path":"2020/09/15/833-Find-And-Replace-in-String/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/833-Find-And-Replace-in-String/","excerpt":"","text":"reverse sort: 因为一旦replace， 会影响后面的结果所以要reverse sorted 123456789101112131415class Solution(object): def findReplaceString(self, S, indexes, sources, targets): \"\"\" :type S: str :type indexes: List[int] :type sources: List[str] :type targets: List[str] :rtype: str \"\"\" S = list(S) for i, x, y in sorted(zip(indexes, sources, targets), reverse = True): if all(i + k &lt; len(S) and S[i + k] == x[k] for k in xrange(len(x))): S[i:i+len(x)] = list(y) return \"\".join(S) 1234567891011121314151617181920/** * @param &#123;string&#125; S * @param &#123;number[]&#125; indexes * @param &#123;string[]&#125; sources * @param &#123;string[]&#125; targets * @return &#123;string&#125; */var findReplaceString = function(S, indexes, sources, targets) &#123; const array = indexes.map((item, idex) =&gt; [item, idex]) array.sort((a, b) =&gt; b[0] - a[0]) for (const [index, i] of array) &#123; const source = sources[i] if (S.substring(index, index + source.length) === source) &#123; S = S.substring(0, index) + targets[i] + S.substring(index + source.length) &#125; &#125; return S&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"731. My Calendar II","slug":"731-My-Calendar-II","date":"2020-09-16T02:57:02.000Z","updated":"2020-09-16T03:04:31.589Z","comments":true,"path":"2020/09/15/731-My-Calendar-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/731-My-Calendar-II/","excerpt":"","text":"filtered by overlaps list add overlap list contents12345678910111213141516171819202122232425262728class MyCalendarTwo(object): def __init__(self): self.overlaps = [] self.calender = [] def book(self, start, end): \"\"\" :type start: int :type end: int :rtype: bool \"\"\" for i, j in self.overlaps: if start &lt; j and end &gt; i: return False for i, j in self.calender: if start &lt; j and end &gt; i: self.overlaps.append((max(start, i), min(end, j))) self.calender.append((start, end)) return True # Your MyCalendarTwo object will be instantiated and called as such:# obj = MyCalendarTwo()# param_1 = obj.book(start,end) 12345678910111213141516171819202122232425262728293031323334var MyCalendarTwo = function() &#123; this.overlaps = [] this.calender = []&#125;;/** * @param &#123;number&#125; start * @param &#123;number&#125; end * @return &#123;boolean&#125; */MyCalendarTwo.prototype.book = function(start, end) &#123; for (const [i, j] of this.overlaps) &#123; if (start &lt; j &amp;&amp; end &gt; i) &#123; return false; &#125; &#125; for (const [i, j] of this.calender) &#123; if (start &lt; j &amp;&amp; end &gt; i) &#123; this.overlaps.push([Math.max(start, i), Math.min(j, end)]) &#125; &#125; this.calender.push([start, end]) return true&#125;;/** * Your MyCalendarTwo object will be instantiated and called as such: * var obj = new MyCalendarTwo() * var param_1 = obj.book(start,end) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"274. H-Index","slug":"274-H-Index","date":"2020-09-15T23:02:41.000Z","updated":"2020-09-15T23:03:07.253Z","comments":true,"path":"2020/09/15/274-H-Index/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/274-H-Index/","excerpt":"","text":"12345678910111213/** * @param &#123;number[]&#125; citations * @return &#123;number&#125; */var hIndex = function(citations) &#123; citations.sort((a, b) =&gt; b - a) for (let i = 0; i &lt; citations.length; i++) &#123; if (citations[i] &lt;= i) return i; &#125; return citations.length&#125;","categories":[],"tags":[]},{"title":"837. New 21 Game","slug":"837-New-21-Game","date":"2020-09-15T20:54:36.000Z","updated":"2020-09-15T21:13:21.288Z","comments":true,"path":"2020/09/15/837-New-21-Game/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/837-New-21-Game/","excerpt":"","text":"Thinking: 12345678910111213141516171819class Solution(object): def new21Game(self, N, K, W): \"\"\" :type N: int :type K: int :type W: int :rtype: float \"\"\" dp = [0.0] * (N + W + 1) for k in xrange(K, N + 1): dp[k] = 1.0 S = min(N - K + 1, W) for k in xrange(K - 1, -1, -1): dp[k] = S/float(W) S += dp[k] - dp[k + W] return dp[0] 1234567891011121314151617181920212223/** * @param &#123;number&#125; N * @param &#123;number&#125; K * @param &#123;number&#125; W * @return &#123;number&#125; */var new21Game = function(N, K, W) &#123; const dp = new Array(N + W + 1).fill(0.0) for (let i = K; i &lt; N + 1; i++) &#123; dp[i] = 1 &#125; let S = Math.min(N - K + 1, W); for (let i = K - 1; i &gt;= 0; i--) &#123; dp[i] = S/W S += dp[i] - dp[i+W] &#125; return dp[0]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"911. Online Election","slug":"911-Online-Election","date":"2020-09-15T14:40:02.000Z","updated":"2020-09-15T15:31:56.674Z","comments":true,"path":"2020/09/15/911-Online-Election/","link":"","permalink":"https://jojoyang666.github.io/2020/09/15/911-Online-Election/","excerpt":"","text":"Counter + Binary Search 1234567891011121314151617181920212223242526272829303132class TopVotedCandidate(object): def __init__(self, persons, times): \"\"\" :type persons: List[int] :type times: List[int] \"\"\" self.A = [] count = collections.Counter() leader, m = None, 0 for p, t in itertools.izip(persons, times): count[p] += 1 c = count[p] if c &gt;= m: if p != leader: leader = p self.A.append((t, leader)) if c &gt; m: m = c def q(self, t): \"\"\" :type t: int :rtype: int \"\"\" i = bisect.bisect(self.A, (t, float('inf'))) return self.A[i-1][1]# Your TopVotedCandidate object will be instantiated and called as such:# obj = TopVotedCandidate(persons, times)# param_1 = obj.q(t) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;number[]&#125; persons * @param &#123;number[]&#125; times */var TopVotedCandidate = function(persons, times) &#123; const map = &#123;&#125; this.A = [] let m = 0, leader = null;//must set to null, not 0 for (let i = 0; i &lt; persons.length; i++) &#123; const person = persons[i] if (map[person] === undefined) &#123; map[person] = 0 &#125; map[person] = map[person] + 1; if (map[person] &gt;= m) &#123; if (person !== leader) &#123; leader = person this.A.push([times[i], leader]) &#125; if (map[person] &gt; m) &#123; m = map[person] &#125; &#125; &#125;&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */TopVotedCandidate.prototype.q = function(t) &#123; let idx = binarySearch(this.A, t) - 1 return this.A[idx][1]&#125;;//find num &gt; targetconst binarySearch = (nums, target) =&gt; &#123; let left = 0, right = nums.length; while (left &lt; right) &#123; let mid = (right + left) &gt;&gt; 1 if (nums[mid][0] &lt;= target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return right&#125;/** * Your TopVotedCandidate object will be instantiated and called as such: * var obj = new TopVotedCandidate(persons, times) * var param_1 = obj.q(t) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"259. 3Sum Smaller","slug":"259-3Sum-Smaller","date":"2020-09-15T03:11:54.000Z","updated":"2020-09-15T03:12:39.068Z","comments":true,"path":"2020/09/14/259-3Sum-Smaller/","link":"","permalink":"https://jojoyang666.github.io/2020/09/14/259-3Sum-Smaller/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var threeSumSmaller = function(nums, target) &#123; nums.sort((a, b) =&gt; a - b); let sum = 0; for (let i = 0; i &lt; nums.length - 2; i++) &#123; sum += twoSumSmaller(nums, i + 1, target - nums[i]) &#125; return sum&#125;;const twoSumSmaller = (nums, startIndex, target) =&gt; &#123; let sum = 0, left = startIndex, right = nums.length - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] &lt; target) &#123; sum += right - left left++; &#125; else &#123; right--; &#125; &#125; return sum;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"846. Hand of Straights","slug":"846-Hand-of-Straights","date":"2020-09-14T17:08:24.000Z","updated":"2020-09-15T02:28:47.802Z","comments":true,"path":"2020/09/14/846-Hand-of-Straights/","link":"","permalink":"https://jojoyang666.github.io/2020/09/14/846-Hand-of-Straights/","excerpt":"","text":"Greedy 1234567891011121314151617181920class Solution(object): def isNStraightHand(self, hand, W): \"\"\" :type hand: List[int] :type W: int :rtype: bool \"\"\" count = collections.Counter(hand) while count: m = min(count) for k in xrange(m, m + W): v = count[k] if not v: return False if v == 1: del count[k] else: count[k] = v - 1 return True 123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; hand * @param &#123;number&#125; W * @return &#123;boolean&#125; */var isNStraightHand = function(hand, W) &#123; if (hand.length%W) return false hand.sort((a, b) =&gt; a - b) const map = new Map(); for (let card of hand) &#123; if (!map.has(card)) &#123; map.set(card, 0) &#125; map.set(card, map.get(card) + 1) &#125; for (let [key, value] of map) &#123; if (value &gt; 0) &#123; for (let i = key; i &lt; key + W; i++) &#123; if ((map.get(i) || 0) &lt; value) &#123; return false &#125; map.set(i, map.get(i) - value) &#125; &#125; &#125; return true&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1146. Snapshot Array","slug":"1146-Snapshot-Array","date":"2020-09-13T21:35:43.000Z","updated":"2020-09-13T22:23:58.855Z","comments":true,"path":"2020/09/13/1146-Snapshot-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/09/13/1146-Snapshot-Array/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839class SnapshotArray(object): def __init__(self, length): \"\"\" :type length: int \"\"\" self.A = [[[-1, 0]] for _ in xrange(length)] self.snap_id = 0 def set(self, index, val): \"\"\" :type index: int :type val: int :rtype: None \"\"\" self.A[index].append([self.snap_id, val]) def snap(self): \"\"\" :rtype: int \"\"\" self.snap_id += 1 return self.snap_id - 1 def get(self, index, snap_id): \"\"\" :type index: int :type snap_id: int :rtype: int \"\"\" i = bisect.bisect(self.A[index], [snap_id+1])-1 return self.A[index][i][1]# Your SnapshotArray object will be instantiated and called as such:# obj = SnapshotArray(length)# obj.set(index,val)# param_2 = obj.snap()# param_3 = obj.get(index,snap_id) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @param &#123;number&#125; length */var SnapshotArray = function(length) &#123; this.snap_id = 0 this.A = [...new Array(length)].map(() =&gt; [[-1, 0]]) &#125;;/** * @param &#123;number&#125; index * @param &#123;number&#125; val * @return &#123;void&#125; */SnapshotArray.prototype.set = function(index, val) &#123; this.A[index].push([this.snap_id, val])&#125;;/** * @return &#123;number&#125; */SnapshotArray.prototype.snap = function() &#123; this.snap_id += 1 return this.snap_id - 1&#125;;/** * @param &#123;number&#125; index * @param &#123;number&#125; snap_id * @return &#123;number&#125; */SnapshotArray.prototype.get = function(index, snap_id) &#123; let idx = binarySearch(this.A[index], snap_id + 1) - 1// this is becasue there may be multiple times set the value at the same index and snap_id,we need latest one return this.A[index][idx][1]&#125;;/** * Your SnapshotArray object will be instantiated and called as such: * var obj = new SnapshotArray(length) * obj.set(index,val) * var param_2 = obj.snap() * var param_3 = obj.get(index,snap_id) */const binarySearch = (A, value) =&gt; &#123; let left = 0, right = A.length while (left &lt; right) &#123; let mid = (left + right) &gt;&gt; 1; if (A[mid][0] &lt; value) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right&#125;","categories":[],"tags":[]},{"title":"221. Maximal Square","slug":"221-Maximal-Square","date":"2020-09-12T00:33:54.000Z","updated":"2020-09-12T00:34:52.919Z","comments":true,"path":"2020/09/11/221-Maximal-Square/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/221-Maximal-Square/","excerpt":"","text":"Solution 1这种方法的机理就是就是把数组中每一个点都当成正方形的左顶点来向右下方扫描，来寻找最大正方形。具体的扫描方法是，确定了左顶点后，再往下扫的时候，正方形的竖边长度就确定了，只需要找到横边即可，这时候我们使用直方图的原理，从其累加值能反映出上面的值是否全为1 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;character[][]&#125; matrix * @return &#123;number&#125; */var maximalSquare = function(matrix) &#123; let res = 0; for (let i = 0; i &lt; matrix.length; i++) &#123; const v = new Array(matrix[i].length).fill(0) for (let j = i; j &lt; matrix.length; j++) &#123; for (let k = 0; k &lt; matrix[i].length; k++) &#123; if (matrix[j][k] === '1') v[k]++; &#125; res = Math.max(res, getSquareArea(v, j - i + 1)) &#125; &#125; return res;&#125;;const getSquareArea = (v, k) =&gt; &#123; if (v.length &lt; k) return 0; let count = 0; for (let i = 0; i &lt; v.length; i++) &#123; if (v[i] !== k) count = 0 else count++ if (count === k) return k * k &#125; return 0&#125;","categories":[],"tags":[]},{"title":"279. Perfect Squares","slug":"279-Perfect-Squares","date":"2020-09-11T21:54:05.000Z","updated":"2020-09-11T23:44:02.179Z","comments":true,"path":"2020/09/11/279-Perfect-Squares/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/279-Perfect-Squares/","excerpt":"","text":"Solution 1dp 123456789101112131415/** * @param &#123;number&#125; n * @return &#123;number&#125; */var numSquares = function(n) &#123; const dp = new Array(n+1).fill(Number.MAX_VALUE) dp[0] = 0 for (let i = 0; i &lt;= n; i++) &#123; for (let j = 1; j * j + i &lt;= n; j++) &#123; dp[i + j * j] = Math.min(dp[i + j * j], dp[i] + 1) &#125; &#125; return dp[n]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"562. Longest Line of Consecutive One in Matrix","slug":"562-Longest-Line-of-Consecutive-One-in-Matrix","date":"2020-09-11T21:12:53.000Z","updated":"2020-09-11T21:44:33.587Z","comments":true,"path":"2020/09/11/562-Longest-Line-of-Consecutive-One-in-Matrix/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/562-Longest-Line-of-Consecutive-One-in-Matrix/","excerpt":"","text":"Solution 1DP SolutionThree Dimensional dp Array 1234567891011121314151617181920212223242526272829/** * @param &#123;number[][]&#125; M * @return &#123;number&#125; */var longestLine = function(M) &#123; if (!M.length || !M[0].length) return 0; const m = M.length, n = M[0].length const dp = [...new Array(m)].map(item =&gt; [...new Array(n)].map(() =&gt; new Array(4).fill(0))) let res = 0 for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (!M[i][j]) continue; for (let k = 0; k &lt; 4; k++) &#123; dp[i][j][k] = 1 &#125; if (j &gt; 0) dp[i][j][0] += dp[i][j-1][0]//horizontal if (i &gt; 0) dp[i][j][1] += dp[i-1][j][1]//vertical if (i &gt; 0 &amp;&amp; j &lt; n - 1) dp[i][j][2] += dp[i - 1][j + 1][2]; // diagonal if (i &gt; 0 &amp;&amp; j &gt; 0) dp[i][j][3] += dp[i - 1][j - 1][3]; // anti-diagonal res = Math.max(res, Math.max(dp[i][j][0], dp[i][j][1])) res = Math.max(res, Math.max(dp[i][j][2], dp[i][j][3])) &#125; &#125; return res&#125;; Solution2dfs 1234567891011121314151617181920212223242526272829/** * @param &#123;number[][]&#125; M * @return &#123;number&#125; */var longestLine = function(M) &#123; const dirs = [[1, 0], [0, 1], [-1, 1], [-1, -1]] let res = 0; if (!M.length || !M[0].length) return 0; const m = M.length, n = M[0].length for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (M[i][j] == 0) continue; for (const dir of dirs) &#123; let x = i, y = j, cnt = 0; while (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; M[x][y] ===1) &#123; cnt++; x += dir[0] y += dir[1] &#125; res = Math.max(res, cnt) &#125; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"544. Output Contest Matches","slug":"544-Output-Contest-Matches","date":"2020-09-11T20:45:07.000Z","updated":"2020-09-11T20:53:19.313Z","comments":true,"path":"2020/09/11/544-Output-Contest-Matches/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/544-Output-Contest-Matches/","excerpt":"","text":"Solution 1dfs 1234567891011121314151617181920/** * @param &#123;number&#125; n * @return &#123;string&#125; */var findContestMatch = function(n) &#123; const res = [...new Array(n)].map((item, idx) =&gt; idx+1) helper(n, res) return res[0]&#125;;const helper = (n, res) =&gt; &#123; if (n === 1) return; for (let i = 0; i &lt; n; i++) &#123; res[i] = `($&#123;res[i]&#125;,$&#123;res[n-i-1]&#125;)` &#125; return helper(n&gt;&gt;1, res)&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"294. Flip Game II","slug":"294-Flip-Game-II","date":"2020-09-11T19:58:30.000Z","updated":"2020-09-11T20:00:41.444Z","comments":true,"path":"2020/09/11/294-Flip-Game-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/294-Flip-Game-II/","excerpt":"","text":"Solution 112345678910111213/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var canWin = function(s) &#123; for(let i = 1; i &lt; s.length; i++) &#123; if (s.charAt(i) === '+' &amp;&amp; s.charAt(i-1) === '+' &amp;&amp; !canWin(s.substring(0, i-1) + '--' + s.substring(i+1))) &#123; return true; &#125; &#125; return false&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"280. Wiggle Sort","slug":"280-Wiggle-Sort","date":"2020-09-11T16:32:04.000Z","updated":"2020-09-11T16:39:36.875Z","comments":true,"path":"2020/09/11/280-Wiggle-Sort/","link":"","permalink":"https://jojoyang666.github.io/2020/09/11/280-Wiggle-Sort/","excerpt":"","text":"Solution 1 Sort + swamp 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var wiggleSort = function(nums) &#123; nums.sort((a, b) =&gt; a - b) const swap = (nums, i, j) =&gt; &#123; let tmp = nums[i] nums[i] = nums[j] nums[j] = tmp &#125; for (let i = 2; i &lt; nums.length; i += 2) &#123; swap(nums, i, i - 1) &#125;&#125;; Solution 2当i为奇数时，nums[i] &gt;= nums[i - 1]当i为偶数时，nums[i] &lt;= nums[i - 1] 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var wiggleSort = function(nums) &#123; const swap = (nums, i, j) =&gt; &#123; let tmp = nums[i] nums[i] = nums[j] nums[j] = tmp &#125; for (let i = 1; i &lt; nums.length; i++) &#123; if((i%2 === 1 &amp;&amp; nums[i] &lt; nums[i-1]) || (i%2 === 0 &amp;&amp; nums[i] &gt; nums[i-1])) &#123; swap(nums, i, i-1) &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1087. Brace Expansion","slug":"1087-Brace-Expansion","date":"2020-09-10T21:03:39.000Z","updated":"2020-09-15T02:28:45.061Z","comments":true,"path":"2020/09/10/1087-Brace-Expansion/","link":"","permalink":"https://jojoyang666.github.io/2020/09/10/1087-Brace-Expansion/","excerpt":"","text":"Solution 1Backtracking 123456789101112131415161718192021class Solution(object): def expand(self, S): \"\"\" :type S: str :rtype: List[str] \"\"\" self.res = [] def helper(s, word): if not s: self.res.append(word) else: if s[0] == '&#123;': i = s.find('&#125;') for letter in s[1:i].split(','): helper(s[i+1:], word + letter) else: helper(s[1:], word + s[0]) helper(S, \"\") self.res.sort() return self.res 1234567891011121314151617181920212223242526/** * @param &#123;string&#125; S * @return &#123;string[]&#125; */var expand = function(S) &#123; const res = [] helper(S, \"\", res) res.sort() return res&#125;;const helper = (s, word, res) =&gt; &#123; if (!s) &#123; res.push(word) return; &#125; if (s.charAt(0) === '&#123;') &#123; let idx = s.indexOf('&#125;') for (let letter of s.substring(1, idx).split(',')) &#123; helper(s.substring(idx + 1), word + letter, res) &#125; &#125; else &#123; helper(s.substring(1), word + s.charAt(0), res) &#125;&#125; Solution 2Python built in method 123456789class Solution(object): def expand(self, S): \"\"\" :type S: str :rtype: List[str] \"\"\" A = S.replace('&#123;', ' ').replace('&#125;', ' ').strip().split(' ') B = [sorted(a.split(',')) for a in A] return [''.join(c) for c in itertools.product(*B)]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"524. Longest Word in Dictionary through Deleting","slug":"524-Longest-Word-in-Dictionary-through-Deleting","date":"2020-09-10T06:05:45.000Z","updated":"2020-09-10T19:50:34.331Z","comments":true,"path":"2020/09/09/524-Longest-Word-in-Dictionary-through-Deleting/","link":"","permalink":"https://jojoyang666.github.io/2020/09/09/524-Longest-Word-in-Dictionary-through-Deleting/","excerpt":"","text":"Solution 1123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @param &#123;string[]&#125; d * @return &#123;string&#125; */var findLongestWord = function(s, d) &#123; let res = \"\" for (let str of d) &#123; let i = 0; for (let c of [...s]) &#123; if (i &lt; str.length &amp;&amp; c === str.charAt(i)) i++; &#125; if (i === str.length &amp;&amp; str.length &gt;= res.length) &#123; if (str.length &gt; res.length || str &lt; res) &#123; res = str &#125; &#125; &#125; return res&#125;; Solution 21234567891011121314151617class Solution(object): def findLongestWord(self, s, d): \"\"\" :type s: str :type d: List[str] :rtype: str \"\"\" heap = [(-len(word), word) for word in d] heapq.heapify(heap) while heap: word = heapq.heappop(heap)[1] it = iter(s) if all(c in it for c in word): return word return '' Solution 3123456789101112class Solution(object): def findLongestWord(self, s, d): \"\"\" :type s: str :type d: List[str] :rtype: str \"\"\" for x in sorted(d, key=lambda x: (-len(x), x)): it = iter(s) if all(c in it for c in x): return x return '' Solution 412345678910111213class Solution(object): def findLongestWord(self, s, d): \"\"\" :type s: str :type d: List[str] :rtype: str \"\"\" def isSubsequence(x): it = iter(s) return all(c in it for c in x) d.sort(key=lambda x : (-len(x), x)) return next(itertools.ifilter(isSubsequence, d), '')","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"777. Swap Adjacent in LR String","slug":"777-Swap-Adjacent-in-LR-String","date":"2020-09-10T03:50:48.000Z","updated":"2020-09-10T05:36:14.938Z","comments":true,"path":"2020/09/09/777-Swap-Adjacent-in-LR-String/","link":"","permalink":"https://jojoyang666.github.io/2020/09/09/777-Swap-Adjacent-in-LR-String/","excerpt":"","text":"Solution 1 一种是把 “XL” 变成 “LX”，另一种是把 “RX” 变成 “XR”。 每次分别找到 start 和 end 中非X的字符，如果二者不相同的话，直接返回 false，想想问什么？这是因为不论是L还是R，其只能跟X交换位置，L和R之间是不能改变相对顺序的，所以如果分别将 start 和 end 中所有的X去掉后的字符串不相等的话，那么就永远无法让 start 和 end 相等了。 这个判断完之后，就来验证L只能前移，R只能后移这个限制条件吧，当i指向 start 中的L时，那么j指向 end 中的L必须要在前面，所以如果i小于j的话，就不对了，同理，当i指向 start 中的R，那么j指向 end 中的R必须在后面，所以i大于j就是错的123456789101112131415161718192021222324252627282930/** * @param &#123;string&#125; start * @param &#123;string&#125; end * @return &#123;boolean&#125; */var canTransform = function(start, end) &#123; let n = start.length, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; while (i &lt; n &amp;&amp; start.charAt(i) === 'X') i++; while (j &lt; n &amp;&amp; end.charAt(j) === 'X') j++; if (start.charAt(i) !== end.charAt(j)) return false; if ((start.charAt(i) === 'L' &amp;&amp; i &lt; j) || (start.charAt(i) === 'R' &amp;&amp; i &gt; j)) return false; i++; j++; &#125; while (i &lt; n) &#123; if (start.charAt(i) !== 'X') return false; i++; &#125; while (j &lt; n) &#123; if (end.charAt(j) !== 'X') return false j++ &#125; return true&#125;; Solution 2 ，这里使用两个计数器 cntL 和 cntR，分别来统计L和R出现的次数，统计方法时，start 中出现了L或R，计数器自增1，end 中出现了L或R，计数器自减1。 注意检测的顺序很重要，由于 start 中的R必须在 end 中的R前面，所以要先检测 start 中的R，同理，由于 end 中的L必须要在 start 中的L前面，所以要先检测 end 中的L，那么四个 if 写完后，如果 cntL 或者 cntR 中有任何一个小于0了，说明限制条件被打破了，返回 false，或者当二者都大于0的时候，说明此时不匹配了，参见上面解法中对于去掉所有的X的解释，一个道理，说明L和R的相对顺序不同了，那么也是 false。最终 for 循环退出后，如果 cntL 和 cntR 均为0的时候，才返回 true，否则就是 false，参见代码如下：1234567891011121314151617181920212223/** * @param &#123;string&#125; start * @param &#123;string&#125; end * @return &#123;boolean&#125; */var canTransform = function(start, end) &#123; let len = start.length, cntL = 0, cntR = 0; for (let i = 0; i &lt; len; i++) &#123; if (start.charAt(i) === 'R') cntR++; if (end.charAt(i) === 'L') cntL++; if (cntL * cntR !== 0) return false if (end.charAt(i) === 'R') cntR--; if (start.charAt(i) === 'L') cntL--; if (cntL &lt; 0 || cntR &lt; 0) return false &#125; return cntL === 0 &amp;&amp; cntR === 0&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1055. Shortest Way to Form String","slug":"1055-Shortest-Way-to-Form-String","date":"2020-09-07T00:21:20.000Z","updated":"2020-09-09T04:27:14.281Z","comments":true,"path":"2020/09/06/1055-Shortest-Way-to-Form-String/","link":"","permalink":"https://jojoyang666.github.io/2020/09/06/1055-Shortest-Way-to-Form-String/","excerpt":"","text":"Solution 1 Greedy123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; const map = new Array(26).fill(false) for (let i = 0; i &lt; source.length; i++) &#123; map[source.charCodeAt(i) - 97] = true; &#125; let j = 0, res = 1 for (let i = 0; i &lt; target.length; i++, j++) &#123; if (!map[target.charCodeAt(i) - 97]) &#123; return -1; &#125; while (j &lt; source.length &amp;&amp; target.charAt(i) !== source.charAt(j)) &#123; j++ &#125; if (j &gt;= source.length) &#123; j = -1 res++; i-- &#125; &#125; return res&#125;; Solution2/Follow up1 Can you implement it with O(1) space, which means whithout set –&gt; iterate src completely, it j not move, then we can return -1 12345678910111213141516171819202122232425/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; let res = 0; for (let i = 0; i &lt; target.length; ) &#123; let OriI = i; for (let j = 0; j &lt; source.length; j++) &#123; if (source.charAt(j) === target.charAt(i)) &#123; i++; &#125; &#125; if (i === OriI) &#123; return -1; &#125; res++; &#125; return res;&#125;; Solution 3/Follow up2 what’s the time complexity for above solutions. O(MN). could u make it better?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; const idx = [...new Array(26)].map(item =&gt; []) let res = 1; for (let i = 0; i &lt; source.length; i++) &#123; idx[source.charCodeAt(i) - 97].push(i) &#125; let j = 0 for (let i = 0; i &lt; target.length; ) &#123; const tar = idx[target.charCodeAt(i) - 97] if (!tar.length) return -1; let k = find(tar, j) if (k === tar.length) &#123; res++; j = 0; &#125; else &#123; j = tar[k] + 1 i++ &#125; &#125; return res;&#125;;const find = (nums, target) =&gt; &#123; let left = 0, right = nums.length; while (left &lt; right) &#123; let mid = (left + right) &gt;&gt; 1; if(nums[mid] &lt; target ) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return right;&#125; Solution 4 / Follow Up 3 could u improve it more?in binary search solution we will have a map like a -&gt;{1,3,7,16} (total src length is 20), so we need binary search.if we can flatten them, i mean for each pos in 20 length, we just save the next idx, we can use O 1 to find the next J.a -&gt; {1,1,3,3,7,7,7,7,16,16,16,16,16,16,16,16,16,0,0,0} 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; const len = source.length; const idx = [...new Array(26)].map(() =&gt; new Array(len).fill(0)) //idx[i][j]: i所代表的char, 在source的j位置， 他的下一个位置是j+1 for (let i = 0; i &lt; len; i++) &#123; idx[source.charCodeAt(i) - 97][i] = i + 1 &#125; for (let i = 0; i &lt; 26; i++) &#123; for (let j = source.length - 1, pre = 0; j &gt;= 0; j--) &#123; if (!idx[i][j]) &#123; idx[i][j] = pre; // source 在 j-1位置， 没有i所代表的字符 &#125; else &#123; pre = idx[i][j] &#125; &#125; &#125; let res = 1, j = 0; for (let i = 0; i &lt; target.length; i++) &#123; if (j === len) &#123; j = 0; res++; &#125; if (!idx[target.charCodeAt(i) - 97][0]) return -1; j = idx[target.charCodeAt(i) - 97][j] if (j === 0) &#123; res++; //在这个位置找不到next pos which &gt; j所以source++ i--; &#125; &#125; return res&#125;; Solution 5 / Follow Up 4 could u improve it more? if we assume which can copy a array to another array with 26 length in constant time. could u implement it with O(M + N)12345678910111213141516171819202122232425262728293031323334/** * @param &#123;string&#125; source * @param &#123;string&#125; target * @return &#123;number&#125; */var shortestWay = function(source, target) &#123; const len = source.length; const idx = [...new Array(len)].map(() =&gt; new Array(26).fill(0)) idx[len-1][source.charCodeAt(len-1) - 97] = len for (let i = len - 2; i &gt;= 0; i--) &#123; idx[i] = [...idx[i+1]] idx[i][source.charCodeAt(i) - 97] = i + 1 &#125; let j = 0, res = 1 for (let i = 0; i &lt; target.length; i++) &#123; if (j === len) &#123; j = 0; res++; &#125; j = idx[j][target.charCodeAt(i) - 97] if (!idx[0][target.charCodeAt(i) - 97]) return -1; if (!j) &#123; res++; i--; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"289. Game of Life","slug":"289-Game-of-Life","date":"2020-09-04T17:14:42.000Z","updated":"2020-09-04T18:45:36.500Z","comments":true,"path":"2020/09/04/289-Game-of-Life/","link":"","permalink":"https://jojoyang666.github.io/2020/09/04/289-Game-of-Life/","excerpt":"","text":"Solution 1 -&gt; constant space 状态机 Code12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;number[][]&#125; board * @return &#123;void&#125; Do not return anything, modify board in-place instead. */var gameOfLife = function(board) &#123; const neighbors = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]] for (let row = 0; row &lt; board.length; row++) &#123; for (let col = 0; col &lt; board[row].length; col++) &#123; let live_count = 0 for (let nei of neighbors) &#123; const r = row + nei[0] const c = col + nei[1] if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; board.length &amp;&amp; c &lt; board[row].length &amp;&amp; (board[r][c] === 1 || board[r][c] === 2)) &#123; live_count++; &#125; &#125; if (board[row][col] === 1 &amp;&amp; (live_count &lt; 2 || live_count &gt; 3)) &#123; board[row][col] = 2 &#125; else if (board[row][col] === 0 &amp;&amp; (live_count === 3)) &#123; board[row][col] = 3 &#125; &#125; &#125; for (let row = 0; row &lt; board.length; row++) &#123; for (let col = 0; col &lt; board[row].length; col++) &#123; board[row][col] %= 2 &#125; &#125; return board&#125;; Solution 2Infinite Board 1234567891011121314151617class Solution(object): def gameOfLifeInfinite(self, live): ctr = collections.Counter((I, J) for i, j in live for I in range(i-1, i+2) for J in range(j-1, j+2) if I != i or J != j) return &#123;ij for ij in ctr if ctr[ij] == 3 or ctr[ij] == 2 and ij in live&#125; def gameOfLife(self, board): \"\"\" :type board: List[List[int]] :rtype: None Do not return anything, modify board in-place instead. \"\"\" live = &#123;(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live&#125; live = self.gameOfLifeInfinite(live) for i, row in enumerate(board): for j in range(len(row)): row[j] = int((i, j) in live)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1110. Delete Nodes And Return Forest","slug":"1110-Delete-Nodes-And-Return-Forest","date":"2020-09-03T22:06:01.000Z","updated":"2020-09-03T22:16:51.257Z","comments":true,"path":"2020/09/03/1110-Delete-Nodes-And-Return-Forest/","link":"","permalink":"https://jojoyang666.github.io/2020/09/03/1110-Delete-Nodes-And-Return-Forest/","excerpt":"","text":"123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def delNodes(self, root, to_delete): \"\"\" :type root: TreeNode :type to_delete: List[int] :rtype: List[TreeNode] \"\"\" to_delete_set = set(to_delete) res = [] def helper(root, is_root): if not root: return None root_deleted = root.val in to_delete_set if is_root and not root_deleted: res.append(root) root.left = helper(root.left, root_deleted) root.right = helper(root.right, root_deleted) return root if not root_deleted else None helper(root, True) return res 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number[]&#125; to_delete * @return &#123;TreeNode[]&#125; */var delNodes = function(root, to_delete) &#123; const res = [] helper(root, true, new Set(to_delete), res) return res&#125;;const helper = (root, is_root, to_delete, res) =&gt; &#123; if (!root) &#123; return null; &#125; const if_deleted = to_delete.has(root.val) if (is_root &amp;&amp; !if_deleted) &#123; res.push(root) &#125; root.left = helper(root.left, if_deleted, to_delete, res) root.right = helper(root.right, if_deleted, to_delete, res) return if_deleted ? null : root;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"809. Expressive Words","slug":"809-Expressive-Words","date":"2020-09-03T21:10:22.000Z","updated":"2020-09-03T21:44:11.508Z","comments":true,"path":"2020/09/03/809-Expressive-Words/","link":"","permalink":"https://jojoyang666.github.io/2020/09/03/809-Expressive-Words/","excerpt":"","text":"Solution 112345678910111213141516class Solution(object): def expressiveWords(self, S, words): def RLE(S): return zip(*[(k, len(list(grp))) for k, grp in itertools.groupby(S)]) if not S: return 0 R, count = RLE(S) ans = 0 for word in words: R2, count2 = RLE(word) if R2 != R: continue ans += all(c1 &gt;= max(c2, 3) or c1 == c2 for c1, c2 in zip(count, count2)) return ans explain: 12zip(*[(k, len(list(grp))) for k, grp in itertools.groupby(S)]) S = “heeellooo” result: [(‘h’, ‘e’, ‘l’, ‘o’), (1, 3, 2, 3)] Solution21234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; S * @param &#123;string[]&#125; words * @return &#123;number&#125; */var expressiveWords = function(S, words) &#123; const m = S.length let res = 0 for (const word of words) &#123; let i = 0, j = 0; for (; i &lt; m; i++) &#123; if (j &lt; word.length &amp;&amp; S.charAt(i) === word.charAt(j)) &#123; j++ &#125; else if (i &gt; 0 &amp;&amp; i + 1 &lt; m &amp;&amp; S.charAt(i-1) === S.charAt(i) &amp;&amp; S.charAt(i) === S.charAt(i+1)) &#123; i++; &#125; else if ( !(i &gt; 1 &amp;&amp; S.charAt(i-2) === S.charAt(i) &amp;&amp; S.charAt(i-1) === S.charAt(i))) &#123; break &#125; &#125; if (i === m &amp;&amp; j === word.length) &#123; res++; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Graph","slug":"Graph","date":"2020-09-03T19:51:10.000Z","updated":"2020-09-03T19:52:10.252Z","comments":true,"path":"2020/09/03/Graph/","link":"","permalink":"https://jojoyang666.github.io/2020/09/03/Graph/","excerpt":"","text":"Coming from 737. Sentence Similarity II123456789101112131415161718192021222324252627282930class Solution(object): def areSentencesSimilarTwo(self, words1, words2, pairs): \"\"\" :type words1: List[str] :type words2: List[str] :type pairs: List[List[str]] :rtype: bool \"\"\" if len(words1) != len(words2): return False graph = collections.defaultdict(list) for w1, w2 in pairs: graph[w1].append(w2) graph[w2].append(w1) for w1, w2 in zip(words1, words2): stack, seen = [w1], &#123;w1&#125; while stack: word = stack.pop() if word == w2: break for nei in graph[word]: if nei not in seen: seen.add(nei) stack.append(nei) else: return False return True","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"UNION FIND","slug":"UNION-FIND","date":"2020-09-03T18:38:26.000Z","updated":"2020-09-03T19:30:49.800Z","comments":true,"path":"2020/09/03/UNION-FIND/","link":"","permalink":"https://jojoyang666.github.io/2020/09/03/UNION-FIND/","excerpt":"","text":"1234567891011class DSU: def __init__(self, N): self.parent = range(N) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): self.parent[self.find(x)] = self.find(y) 1234567891011121314151617181920212223242526272829303132const UnionFind = (N) =&gt; &#123; const parent = [...new Array(N)].map((ele, index) =&gt; index) const find = (x) =&gt; &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]) &#125; return parent[x]; &#125; const union = (x, y) =&gt; &#123; parent[find(x)] = find(y) &#125; const unionWithRank = (x, y) =&gt; &#123; let xr = find(x), yr = find(y) if (xr !== yr) &#123; if (rank[xr] &lt; rank[yr]) &#123; parent[xr] = yr &#125; else if (rank[xr] &gt; rank[yr]) &#123; parent[yr] = xr &#125; else &#123; parent[yr] = xr rank[xr]++ &#125; &#125; &#125; return &#123;find, union&#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"737. Sentence Similarity II","slug":"737-Sentence-Similarity-II","date":"2020-09-03T03:27:11.000Z","updated":"2020-09-03T20:05:09.641Z","comments":true,"path":"2020/09/02/737-Sentence-Similarity-II/","link":"","permalink":"https://jojoyang666.github.io/2020/09/02/737-Sentence-Similarity-II/","excerpt":"","text":"Solution 1Union Find 12345678910111213141516171819202122232425262728293031323334class Solution(object): def areSentencesSimilarTwo(self, words1, words2, pairs): \"\"\" :type words1: List[str] :type words2: List[str] :type pairs: List[List[str]] :rtype: bool \"\"\" if len(words1) != len(words2): return False index = &#123;&#125; count = itertools.count() dsu = DSU(2 * len(pairs)) for pair in pairs: for p in pair: if p not in index: index[p] = next(count) dsu.union(index[pair[0]], index[pair[1]]) return all(w1 == w2 or w1 in index and w2 in index and dsu.find(index[w1]) == dsu.find(index[w2]) for w1, w2 in zip(words1, words2)) class DSU: def __init__(self, N): self.parent = range(N) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): self.parent[self.find(x)] = self.find(y) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @param &#123;string[]&#125; words1 * @param &#123;string[]&#125; words2 * @param &#123;string[][]&#125; pairs * @return &#123;boolean&#125; */var areSentencesSimilarTwo = function(words1, words2, pairs) &#123; if (words1.length !== words2.length) return false; const UF = UnionFind(2 * pairs.length) const map = &#123;&#125; let idx = 0 for (let pair of pairs) &#123; for (let p of pair) &#123; if (map[p] === undefined) map[p] = idx++; &#125; UF.union(map[pair[0]], map[pair[1]]) &#125; for (let i = 0; i &lt; words1.length; i++) &#123; const w1 = words1[i], w2 = words2[i] if (w1 !== w2) &#123; if (map[w1] === undefined || map[w2] === undefined || UF.find(map[w1]) !== UF.find(map[w2])) &#123; return false; &#125; &#125; &#125; return true&#125;; const UnionFind = (N) =&gt; &#123; const parent = [...new Array(N)].map((ele, index) =&gt; index) const rank = new Array(N).fill(0) const find = (x) =&gt; &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]) &#125; return parent[x]; &#125; const union = (x, y) =&gt; &#123; let xr = find(x), yr = find(y) if (xr !== yr) &#123; if (rank[xr] &lt; rank[yr]) &#123; parent[xr] = yr &#125; else if (rank[xr] &gt; rank[yr]) &#123; parent[yr] = xr &#125; else &#123; parent[yr] = xr rank[xr]++ &#125; &#125; &#125; return &#123;find, union&#125;&#125; Solution 2DFS/graph 123456789101112131415161718192021222324252627282930class Solution(object): def areSentencesSimilarTwo(self, words1, words2, pairs): \"\"\" :type words1: List[str] :type words2: List[str] :type pairs: List[List[str]] :rtype: bool \"\"\" if len(words1) != len(words2): return False graph = collections.defaultdict(list) for w1, w2 in pairs: graph[w1].append(w2) graph[w2].append(w1) for w1, w2 in zip(words1, words2): stack, seen = [w1], &#123;w1&#125; while stack: word = stack.pop() if word == w2: break for nei in graph[word]: if nei not in seen: seen.add(nei) stack.append(nei) else: return False return True 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @param &#123;string[]&#125; words1 * @param &#123;string[]&#125; words2 * @param &#123;string[][]&#125; pairs * @return &#123;boolean&#125; */var areSentencesSimilarTwo = function(words1, words2, pairs) &#123; if (words1.length !== words2.length) return false; const graph = &#123;&#125; for (const [w1, w2] of pairs) &#123; if (graph[w1] === undefined) graph[w1] = [] if (graph[w2] === undefined) graph[w2] = [] graph[w1].push(w2) graph[w2].push(w1) &#125; for (let i = 0; i &lt; words1.length; i++) &#123; const w1 = words1[i], w2 = words2[i] const stack = [w1], seen = new Set([w1]) let find = false while (stack.length &gt; 0) &#123; const word = stack.pop() if (word === w2) &#123; find = true break &#125; if (graph[word]) &#123;// checking if existence for(const nei of graph[word]) &#123; if (!seen.has(nei)) &#123; seen.add(nei) stack.push(nei) &#125; &#125; &#125; &#125; if (!find) &#123; return false &#125; &#125; return true&#125;;","categories":[],"tags":[]},{"title":"351. Android Unlock Patterns","slug":"351-Android-Unlock-Patterns","date":"2020-09-02T15:36:10.000Z","updated":"2020-09-02T19:38:28.651Z","comments":true,"path":"2020/09/02/351-Android-Unlock-Patterns/","link":"","permalink":"https://jojoyang666.github.io/2020/09/02/351-Android-Unlock-Patterns/","excerpt":"","text":"Solution 112345678910111213141516171819202122232425262728293031323334class Solution(object): def numberOfPatterns(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" skip = &#123;&#125; skip[(1,7)] = 4 skip[(1,3)] = 2 skip[(1,9)] = 5 skip[(2,8)] = 5 skip[(3,7)] = 5 skip[(3,9)] = 6 skip[(4,6)] = 5 skip[(7,9)] = 8 self.res = 0 def dfs(used, last): if len(used) &gt;= m: self.res += 1 if len(used) &gt;= n: return for j in range(1, 10): if j not in used: edge = (min(j, last), max(j, last)) if edge not in skip or skip[edge] in used: dfs(used + [j], j) for i in range(1, 10): dfs([i], i) return self.res 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var numberOfPatterns = function(m, n) &#123; let res = 0 const skip = &#123;&#125; skip[\"1 -&gt; 7\"] = 4 skip[\"1 -&gt; 3\"] = 2 skip[\"1 -&gt; 9\"] = 5 skip[\"2 -&gt; 8\"] = 5 skip[\"3 -&gt; 7\"] = 5 skip[\"3 -&gt; 9\"] = 6 skip[\"4 -&gt; 6\"] = 5 skip[\"7 -&gt; 9\"] = 8 const dfs = (used, last) =&gt; &#123; if (used.size &gt;= m) &#123; res += 1 &#125; if (used.size &gt;= n) &#123; return &#125; for (let i = 1; i &lt;= 9; i++) &#123; if (!used.has(i)) &#123; edge = Math.min(i, last) + \" -&gt; \" + Math.max(i, last) if (!skip[edge] || used.has(skip[edge])) &#123; used.add(i) dfs(used, i) used.delete(i) &#125; &#125; &#125; &#125; for (let i = 1; i &lt;= 9; i++) &#123; const used = new Set() used.add(i) dfs(used, i) &#125; return res&#125;; Notes: Backtrack after comeback from the dfs, never forget to remove value from the set Solution 2 Idea: used 是一个9位的 mask，每位对应一个数字，如果为1表示存在，0表示不存在 (i1, j1) 是之前的位置，(i, j) 是当前的位置，所以滑动是从 (i1, j1) 到 (i, j) 中间点为 ((i1+i)/2, (j1+j)/2)，这里的I和J分别为 i1+i 和 j1+j，还没有除以2，所以I和J都是整数 如果 I%2 或者 J%2 不为0，说明中间点的坐标不是整数，即中间点不存在，如果中间点存在，如果中间点被使用了，则这条线也是成立的，可以调用递归1234567891011121314151617181920212223class Solution(object): def numberOfPatterns(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" return self.count(m, n, 0, 1, 1) def count(self, m, n, used, i1, j1): res = int(m &lt;= 0) if n &lt;= 0: return 1; for i in range(3): for j in range(3): I, J, used2 = i1 + i, j1 + j, used | (1 &lt;&lt; (i * 3 + j)) if used2 &gt; used and (I%2 == 1 or J%2 == 1 or used2 &amp; (1 &lt;&lt; (I/2 * 3 + J/2))): res += self.count(m - 1, n - 1, used2, i, j) return res *Notes: There is no logical operator(|| / ! / &amp;&amp;) in python, using (or / not / and) instead * 1234567891011121314151617181920212223242526272829/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var numberOfPatterns = function(m, n) &#123; return count(m, n, 0, 1, 1)&#125;;const count = (m, n, used, i1, j1) =&gt; &#123; let res = m &lt;= 0 ? 1 : 0; if (n &lt;= 0) &#123; return 1; &#125; for (let i = 0; i &lt; 3; i++) &#123; for (let j = 0; j &lt; 3; j++) &#123; const I = i1 + i, J = j1 + j, used2 = used | (1 &lt;&lt; (i * 3 + j)) if (used2 &gt; used &amp;&amp; (I % 2 || J % 2 || used2 &amp; (1 &lt;&lt; Math.floor((I/2) * 3 + Math.floor(J/2))))) &#123; res += count(m-1, n-1, used2, i, j) &#125; &#125; &#125; return res&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"686. Repeated String Match","slug":"686-Repeated-String-Match","date":"2020-09-01T22:49:44.000Z","updated":"2020-09-01T22:50:33.802Z","comments":true,"path":"2020/09/01/686-Repeated-String-Match/","link":"","permalink":"https://jojoyang666.github.io/2020/09/01/686-Repeated-String-Match/","excerpt":"","text":"12345const repeatedStringMatch = (A, B) =&gt; &#123; const count = Math.ceil(B.length / A.length) const str = A.repeat(count) return str.includes(B) ? count : (str + A).includes(B) ? count + 1 : -1 &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"947. Most Stones Removed with Same Row or Column","slug":"947-Most-Stones-Removed-with-Same-Row-or-Column","date":"2020-09-01T22:02:02.000Z","updated":"2020-09-01T22:03:15.342Z","comments":true,"path":"2020/09/01/947-Most-Stones-Removed-with-Same-Row-or-Column/","link":"","permalink":"https://jojoyang666.github.io/2020/09/01/947-Most-Stones-Removed-with-Same-Row-or-Column/","excerpt":"","text":"Solution 112345678910111213141516171819202122232425262728293031323334class Solution(object): def removeStones(self, stones): \"\"\" :type stones: List[List[int]] :rtype: int \"\"\" graph = collections.defaultdict(list) for i, x in enumerate(stones): for j in xrange(i): y = stones[j] if x[0] == y[0] or x[1] == y[1]: graph[i].append(j) graph[j].append(i) N = len(stones) ans = 0 seen = [False] * N for i in xrange(N): if not seen[i]: stack = [i] seen[i] = True while stack: ans += 1 node = stack.pop() for nei in graph[node]: if not seen[nei]: stack.append(nei) seen[nei] = True ans -= 1 return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"228. Summary Ranges","slug":"228-Summary-Ranges","date":"2020-09-01T21:51:35.000Z","updated":"2020-09-01T21:59:49.255Z","comments":true,"path":"2020/09/01/228-Summary-Ranges/","link":"","permalink":"https://jojoyang666.github.io/2020/09/01/228-Summary-Ranges/","excerpt":"","text":"Solution123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums * @return &#123;string[]&#125; */var summaryRanges = function(nums) &#123; let i = 0; const res = [] while (i &lt; nums.length) &#123; let diff = 0; while (i + diff &lt; nums.length &amp;&amp; nums[i+diff] - nums[i] === diff) diff++; if (diff &lt;= 1) &#123; res.push(nums[i]+\"\") &#125; else &#123; res.push(`$&#123;nums[i]&#125;-&gt;$&#123;nums[i+diff-1]&#125;`) &#125; i += diff; &#125; return res;&#125;; 对于连续/sorted的问题： 可以考虑用diff","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"904. Fruit Into Baskets","slug":"904-Fruit-Into-Baskets","date":"2020-09-01T17:48:14.000Z","updated":"2020-09-01T21:50:03.863Z","comments":true,"path":"2020/09/01/904-Fruit-Into-Baskets/","link":"","permalink":"https://jojoyang666.github.io/2020/09/01/904-Fruit-Into-Baskets/","excerpt":"","text":"Solution 11234567891011121314151617class Solution(object): def totalFruit(self, tree): \"\"\" :type tree: List[int] :rtype: int \"\"\" ans = i = 0 count = collections.Counter() for j, x in enumerate(tree): count[x] += 1 while len(count) &gt;= 3: count[tree[i]] -= 1 if count[tree[i]] == 0: del count[tree[i]] i += 1 ans = max(ans, j - i + 1) return ans collections.Counter(): dict subclass for counting hashable objects123456789101112131415161718var totalFruit = function(tree) &#123; let ans = 0, left = 0; let map = &#123;&#125; for (let i = 0; i &lt; tree.length; i++) &#123; map[tree[i]] = map[tree[i]] === undefined ? 1 : map[tree[i]] + 1 while (Object.keys(map).length &gt;= 3) &#123; map[tree[left]] -= 1 if (map[tree[left]] === 0) &#123; delete map[tree[left]] &#125; left++; &#125; ans = Math.max(i-left+1, ans) &#125; return ans&#125;; Javascript: undefined + ==&gt; NAN","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"939. Minimum Area Rectangle","slug":"939-Minimum-Area-Rectangle","date":"2020-08-28T22:39:09.000Z","updated":"2020-09-14T17:09:36.583Z","comments":true,"path":"2020/08/28/939-Minimum-Area-Rectangle/","link":"","permalink":"https://jojoyang666.github.io/2020/08/28/939-Minimum-Area-Rectangle/","excerpt":"","text":"Solution 1 Sorted by column12345678910111213141516171819202122class Solution(object): def minAreaRect(self, points): \"\"\" :type points: List[List[int]] :rtype: int \"\"\" columns = collections.defaultdict(list) for x, y in points: columns[x].append(y) lastx = &#123;&#125; ans = float('inf') for x in sorted(columns): column = columns[x] column.sort() for j, y2 in enumerate(column): for i in xrange(j): y1 = column[i] if (y1, y2) in lastx: ans = min(ans, (x - lastx[y1, y2]) * (y2 - y1)) lastx[y1, y2] = x return ans if ans &lt; float('inf') else 0 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;number[][]&#125; points * @return &#123;number&#125; */var minAreaRect = function(points) &#123; const columns = &#123;&#125; for (let [x,y] of points) &#123; if (!columns.hasOwnProperty(x)) &#123; columns[x] = [] &#125; columns[x].push(y) &#125; const keys = Object.keys(columns).sort((x, y) =&gt; x - y) let ans = Number.MAX_VALUE let lastx = &#123;&#125; for (let x of keys) &#123; const column = columns[x] column.sort((x, y) =&gt; x-y) for (let i = 0; i &lt; column.length; i++) &#123; let y2 = column[i]; for (let j = 0; j &lt; i; j++) &#123; let y1 = column[j]; const pair = `$&#123;y1&#125;#$&#123;y2&#125;` if (lastx.hasOwnProperty(pair)) &#123; ans = Math.min(ans, (x - lastx[pair]) * (y2 - y1)) &#125; lastx[pair] = x &#125; &#125; &#125; return ans === Number.MAX_VALUE ? 0 : ans&#125;; Note: In javascript, if want to sort a number array, it must be array.sort((x, y) =&gt; x - y), it must have function Solution 2 Sort by diagonal if the points are (1, 1) and (5, 5), we check if we also have (1, 5) and (5, 1). If we do, we have a candidate rectangle.123456789101112131415class Solution(object): def minAreaRect(self, points): \"\"\" :type points: List[List[int]] :rtype: int \"\"\" S = set(map(tuple, points)) ans = float('inf') for j, p2 in enumerate(points): for i in xrange(j): p1 = points[i] if (p1[0] != p2[0] and p1[1] != p2[1] and (p1[0], p2[1]) in S and (p2[0], p1[1]) in S): ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1])) return ans if ans &lt; float('inf') else 0 1234567891011121314151617181920const minAreaRect = (points) =&gt; &#123; const map = new Map(); for (const [x, y] of points) &#123; if (!map.has(x)) map.set(x, new Set()); map.get(x).add(y); &#125; let min = Infinity; for (const [x1, y1] of points) &#123; for (const [x2, y2] of points) &#123; if (x1 === x2 || y1 === y2) continue; // Find other two diagonal points if (map.get(x1).has(y2) &amp;&amp; map.get(x2).has(y1)) &#123; min = Math.min(min, Math.abs(x1 - x2) * Math.abs(y1 - y2)); &#125; &#125; &#125; return min === Infinity ? 0 : min;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"288. Unique Word Abbreviation","slug":"288-Unique-Word-Abbreviation-exiyexit","date":"2020-08-19T23:43:36.000Z","updated":"2020-08-19T23:44:50.859Z","comments":true,"path":"2020/08/19/288-Unique-Word-Abbreviation-exiyexit/","link":"","permalink":"https://jojoyang666.github.io/2020/08/19/288-Unique-Word-Abbreviation-exiyexit/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;string[]&#125; dictionary */var ValidWordAbbr = function(dictionary) &#123; this.map = &#123;&#125; this.set = new Set(dictionary) for (let word of this.set) &#123; let abbr = toAbbr(word) this.map[abbr] = this.map[abbr] === undefined ? true : false &#125;&#125;;/** * @param &#123;string&#125; word * @return &#123;boolean&#125; */ValidWordAbbr.prototype.isUnique = function(word) &#123; let abbr = toAbbr(word) let hasAbbr = this.map[abbr] return hasAbbr === undefined || (hasAbbr &amp;&amp; this.set.has(word))&#125;;/** * Your ValidWordAbbr object will be instantiated and called as such: * var obj = new ValidWordAbbr(dictionary) * var param_1 = obj.isUnique(word) */const toAbbr = (s) =&gt; &#123; if ( !s || s.length &lt;= 2) &#123; return s; &#125; return s.charAt(0) + (s.length - 2) + s.charAt(s.length - 1);&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Difference Among Unicode, ASCII, and UTF-8","slug":"Difference-Among-Unicode-ASCII-and-UTF-8","date":"2020-08-19T17:24:06.000Z","updated":"2020-08-19T19:00:58.458Z","comments":true,"path":"2020/08/19/Difference-Among-Unicode-ASCII-and-UTF-8/","link":"","permalink":"https://jojoyang666.github.io/2020/08/19/Difference-Among-Unicode-ASCII-and-UTF-8/","excerpt":"","text":"ASCII ASCII码使用指定的7位或8位二进制数组合来表示128/256种可能的字符 ASCII是单字节编码（1 byte = 8 bits）， 无法用来表示中文（中文编码至少需要2个字节） Unicode ASCII编码 是1个字节， 而Unicode编码通常是2个字节 UTF8 把Unicode编码转化为可变长编码的UTF-8编码 UTF-8把一个Unicode字符根据不同的数字大小编码成1-6个字节， 常用的英文字母被编码成一个字节， 汉字通常是3个字节。 如果要传输的文本包含大量的英文字符， 用UTF-8就能节省空间 ASCII编码实际上可以被看作是UTF-8的一部分， 所以大量支持ASCII编码的历史遗留软件可以再UTF-8编码下继续工作 计算机中通用的字符编码的工作方式 在计算机内存中， 统一使用Unicode编码， 当需要保存到硬盘或者需要传输的时候， 就转换为UTF-8编码 在用记事本编辑的时候， 从文本读取的UTF-8字符被转换为Unicode字符的内存里，编辑完成后， 保存的时候再把Unicode转换为UTF-8保存带文件里 浏览网页的时候， 服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器","categories":[],"tags":[]},{"title":"271. Encode and Decode Strings","slug":"271-Encode-and-Decode-Strings","date":"2020-08-19T05:10:30.000Z","updated":"2020-08-19T22:11:38.613Z","comments":true,"path":"2020/08/18/271-Encode-and-Decode-Strings/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/271-Encode-and-Decode-Strings/","excerpt":"","text":"Solution 1123456789101112131415161718192021222324252627class Codec: def encode(self, strs): \"\"\"Encodes a list of strings to a single string. :type strs: List[str] :rtype: str \"\"\" if len(strs) == 0: return unichr(258) return unichr(257).join(x.encode('utf-8') for x in strs) def decode(self, s): \"\"\"Decodes a single string to a list of strings. :type s: str :rtype: List[str] \"\"\" if s == unichr(258): return [] return s.split(unichr(257)) # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(strs)) 123456789101112131415161718192021222324252627282930/** * Encodes a list of strings to a single string. * * @param &#123;string[]&#125; strs * @return &#123;string&#125; */var encode = function(strs) &#123; if (!strs || !strs.length) return String.fromCharCode(258) return strs.join(String.fromCharCode(257))&#125;;/** * Decodes a single string to a list of strings. * * @param &#123;string&#125; s * @return &#123;string[]&#125; */var decode = function(s) &#123; if (s === String.fromCharCode(258)) return [] return s.split(String.fromCharCode(257))&#125;;/** * Your functions will be called as such: * decode(encode(strs)); */ Solution 2 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Codec: def len_to_str(self, x): \"\"\" Encode length of string to bytes string \"\"\" x = len(x) bytes = [chr(x &gt;&gt; (i * 8) &amp; 0xff) for i in range(4)] bytes.reverse() bytes_str = ''.join(bytes) return bytes_str def encode(self, strs): \"\"\"Encodes a list of strings to a single string. :type strs: List[str] :rtype: str \"\"\" return ''.join(self.len_to_str(x) + x.encode('utf-8') for x in strs) def str_to_int(self, bytes_str): result = 0 for ch in bytes_str: result = result * 256 + ord(ch) return result def decode(self, s): \"\"\"Decodes a single string to a list of strings. :type s: str :rtype: List[str] \"\"\" i, n = 0, len(s) output = [] while i &lt; n: length = self.str_to_int(s[i: i + 4]) i += 4 output.append(s[i: i + length]) i += length return output# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.decode(codec.encode(strs)) TroubleShooting Understanding bytes = [chr(x &gt;&gt; (i * 8) &amp; 0xff) for i in range(4)] need to do is encode the length of x into 4 bytes(why 4 bytes - integer size - 4 bytes = [8bits, 8 bits, 8bits, 8bits]) if &amp; any number with 0xff, will give the right most 8 bits of the number example","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"298. Binary Tree Longest Consecutive Sequence","slug":"298-Binary-Tree-Longest-Consecutive-Sequence","date":"2020-08-18T23:11:47.000Z","updated":"2020-08-18T23:45:24.666Z","comments":true,"path":"2020/08/18/298-Binary-Tree-Longest-Consecutive-Sequence/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/298-Binary-Tree-Longest-Consecutive-Sequence/","excerpt":"","text":"Solution 1Recursion one 12345678910111213141516171819202122/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var longestConsecutive = function(root) &#123; return helper(root, null, 0)&#125;;const helper = (root, p, res) =&gt; &#123; if (!root) return res; res = (p &amp;&amp; root.val === p.val + 1) ? res + 1 : 1; return Math.max(res, Math.max(helper(root.left, root, res), helper(root.right, root, res)))&#125; Solution 2Iterative one 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var longestConsecutive = function(root) &#123; if (!root) return 0; let res = 0; const q = [] q.push(root) while (q.length) &#123; let len = 1; let node = q.shift(); while ((node.left &amp;&amp; node.left.val === node.val + 1) || (node.right &amp;&amp; node.right.val === node.val + 1)) &#123; if (node.left &amp;&amp; node.left.val === node.val + 1) &#123; if (node.right) &#123; q.push(node.right) &#125; node = node.left &#125; else if (node.right &amp;&amp; node.right.val === node.val + 1) &#123; if (node.left) &#123; q.push(node.left) &#125; node = node.right &#125; len++; &#125; if (node.left) q.push(node.left) if (node.right) q.push(node.right) res = Math.max(res, len) &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"281. Zigzag Iterator","slug":"281-Zigzag-Iterator","date":"2020-08-18T18:35:40.000Z","updated":"2020-08-18T23:12:59.751Z","comments":true,"path":"2020/08/18/281-Zigzag-Iterator/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/281-Zigzag-Iterator/","excerpt":"","text":"Solution1用i, j的大小关系来判断， 打印哪个数组， diff不能小于1， 到头的话赋最大值 12345678910111213141516171819202122232425262728293031323334353637/** * @constructor * @param &#123;Integer[]&#125; v1 * @param &#123;Integer[]&#125; v1 */var ZigzagIterator = function ZigzagIterator(v1, v2) &#123; this.v = [v1, v2] this.i = 0 this.j = 0&#125;;/** * @this ZigzagIterator * @returns &#123;boolean&#125; */ZigzagIterator.prototype.hasNext = function hasNext() &#123; if (this.i &gt;= this.v[0].length) this.i = Number.MAX_VALUE if (this.j &gt;= this.v[1].length) this.j = Number.MAX_VALUE return this.i &lt; this.v[0].length || this.j &lt; this.v[1].length&#125;;/** * @this ZigzagIterator * @returns &#123;integer&#125; */ZigzagIterator.prototype.next = function next() &#123; return this.i &lt;= this.j ? this.v[0][this.i++] : this.v[1][this.j++]&#125;;/** * Your ZigzagIterator will be called like this: * var i = new ZigzagIterator(v1, v2), a = []; * while (i.hasNext()) a.push(i.next());*/ Solution 2一开始就存入正确的zigzag顺序， 然后进行读取 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @constructor * @param &#123;Integer[]&#125; v1 * @param &#123;Integer[]&#125; v1 */var ZigzagIterator = function ZigzagIterator(v1, v2) &#123; this.v = [] this.n = Math.max(v1.length, v2.length) this.i = 0 for (let i = 0; i &lt; this.n; i++) &#123; if (i &lt; v1.length) this.v.push(v1[i]); if (i &lt; v2.length) this.v.push(v2[i]) &#125; this.n = v1.length + v2.length&#125;;/** * @this ZigzagIterator * @returns &#123;boolean&#125; */ZigzagIterator.prototype.hasNext = function hasNext() &#123; return this.i &lt; this.n&#125;;/** * @this ZigzagIterator * @returns &#123;integer&#125; */ZigzagIterator.prototype.next = function next() &#123; return this.v[this.i++]&#125;;/** * Your ZigzagIterator will be called like this: * var i = new ZigzagIterator(v1, v2), a = []; * while (i.hasNext()) a.push(i.next());*/ Solution 3Follow up using iterator 123456789101112131415161718class ZigzagIterator(object): def __init__(self, v1, v2): self.data = [(len(v), iter(v)) for v in (v1, v2) if v] def next(self): len, iter = self.data.pop(0) if len &gt; 1: self.data.append((len-1, iter)) return next(iter) def hasNext(self): return bool(self.data) # Your ZigzagIterator object will be instantiated and called as such:# i, v = ZigzagIterator(v1, v2), []# while i.hasNext(): v.append(i.next())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"163. Missing Ranges","slug":"163-Missing-Ranges","date":"2020-08-18T17:55:42.000Z","updated":"2020-08-18T17:58:52.480Z","comments":true,"path":"2020/08/18/163-Missing-Ranges/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/163-Missing-Ranges/","excerpt":"","text":"SolutionCornor Case:整形溢出， 当数组中有整形最大值时， 此时lower更新为num+1时就会溢出， 所以再更新前要判断一下， 若num已经时整形最大值了 直接返回结果 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; lower * @param &#123;number&#125; upper * @return &#123;string[]&#125; */var findMissingRanges = function(nums, lower, upper) &#123; const res = [] for (let num of nums) &#123; if (num &gt; lower) &#123; const suffix = (num-1) &gt; lower ? '-&gt;' + (num-1) : \"\" res.push(`$&#123;lower&#125;$&#123;suffix&#125;`) &#125; if (num === upper) return res; lower = num + 1 &#125; if (lower &lt;= upper) &#123; const suffix = upper &gt; lower ? `-&gt;$&#123;upper&#125;` : \"\" res.push(`$&#123;lower&#125;$&#123;suffix&#125;`) &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1057. Campus Bikes","slug":"1057-Campus-Bikes","date":"2020-08-18T02:55:33.000Z","updated":"2020-08-18T02:56:24.016Z","comments":true,"path":"2020/08/17/1057-Campus-Bikes/","link":"","permalink":"https://jojoyang666.github.io/2020/08/17/1057-Campus-Bikes/","excerpt":"","text":"Solution123456789101112131415161718192021222324class Solution(object): def assignBikes(self, workers, bikes): distances = [] # distances[worker] is tuple of (distance, worker, bike) for each bike for i, (x, y) in enumerate(workers): distances.append([]) for j, (x_b, y_b) in enumerate(bikes): distance = abs(x - x_b) + abs(y - y_b) distances[-1].append((distance, i, j)) distances[-1].sort(reverse = True) # reverse so we can pop the smallest distance result = [None] * len(workers) used_bikes = set() queue = [distances[i].pop() for i in range(len(workers))] # smallest distance for each worker heapq.heapify(queue) while len(used_bikes) &lt; len(workers): _, worker, bike = heapq.heappop(queue) if bike not in used_bikes: result[worker] = bike used_bikes.add(bike) else: heapq.heappush(queue, distances[worker].pop()) # bike used, add next closest bike return result","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Common Python Methods","slug":"Python","date":"2020-08-18T02:09:04.000Z","updated":"2020-11-07T04:55:52.319Z","comments":true,"path":"2020/08/17/Python/","link":"","permalink":"https://jojoyang666.github.io/2020/08/17/Python/","excerpt":"","text":"Base Data Type heapq heapq.heapify(x): transform list x into a heap, in-place, in linear time. heapq.heappop(heap): pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0] heapq.heappush(heap, item): Push the value item onto the heap, , maintaining the heap invariant Other Common Functions ord(c): Given a string representing one Unicode character, return an integer represeting the Unicode code point of that character. chr(i): return the string representing a character whose Unicode code point is the integer i. For example, chr(97) returns the string ‘a’ itertools count(start = 0, step = 1) make an interator that returns evenly spaced values starting with n. groupby(iterable, key) make an iterator that returns consecutive keys and gtroups from the iterable ifilter(predicate, iterable) make an iterator that filters elements from iterable returning only those for which the predicate is True. product Cartesian product of input iterables. Roughly equivalent to nested for-loops in a generator expression. For example, product(A, B) returns the same as ((x,y) for x in A for y in B). zip(): make an iterator that aggregates slements from each of the iterables. Returns an itrator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. izip make an iterator that aggregates elements from each of the iterables. Like zip() except that it returns an iterator instead of a list zip_longest make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. # zip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;) --&gt; Ax By C- D- permutations Return successive r length permutations of elements in the iterable next(): retrieve the next item from the iterator all(iterable): return True if all elements of the iterable are true (or if the iterable is empty) while, else *: unpack the arguments out of a list or tuple collections Counter: A counter is a dict subclass for counting hashable objects. it is an unordered collection wherer elements are stored as disctionary keys and their counts are stored as disctionary values most_common([n]): Return a list of the n most common elements and their counts from the most common to the least. Binary Search bisect.bisect/bisect_right(a, x, lo=0, hi=len(a)) returns an insertion point which comes after (to the right of) any existing entries of x in a The returned insertion point i partitions the array a into two halves so that all(val &lt;= x for val in a[lo:i]) for the left side and all(val &gt; x for val in a[i:hi]) for the right side. bisect.bisect_left(a, x, lo=0, hi=len(a)) returns an insertion point which comes before (to the left of) any existing entries of x in a The returned insertion point i partitions the array a into two halves so that all(val &lt; x for val in a[lo:i]) for the left side and all(val &gt;= x for val in a[i:hi]) for the right side. dict get(keyname, value) value to return if the specified key does not exist Random random.randrange(i, endrange) Common Problem What’s the difference between xrange and range? xrange: return an xrange object better to use when have a really gigantic range to generate a list for: dat one billion range: return a python list object better to use when iterate over the list multiple times there is no increment++ and decrement-- operators in python Common built in func ord(c) Given a string represeting one Unicode character, return an integer represeting the Unicode code point of the character. complex([real[, imag]]) Return a complex number with the value real + imag*1j getattr(object, name[, default]) Return the value of the named attribute of object. name must be a string. If the string is the name of one of the object’s attributes, the result is the value of that attribute. sorted(iterable, *, key=None) Return a new sorted list from the items in iterable key specifies a function of one argument that is used to extract a comparison key from each element in iterable **is the ^ in math string.lstrip(pchars) —-&gt; removes characters from the left based on the argument string.partition split the string at the first occurrence of sep, return a 3-tuple containing the part before the separator, the separator itself, and the part after the seperator map(func, iter) function returns a map obejct(which is an iterator) of the results after applying the given function to each item of a given iterable(list, tuple, etc) str.rfind(sub, start, end): returns the highest index of the substring if found in given string. If not found then it returns -1. Others there is a convention that is followed by most Python code: a name prefixed with an underscore string in python is immutable D1: counter D2: counter –&gt; D2 - D1: subtract (keeping only positive counts) from operator import truediv, mul, add, sub 1e-09, assures that the two values are the same within about 9 decimal digits.","categories":[{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"}],"tags":[]},{"title":"97. Interleaving String","slug":"97-Interleaving-String","date":"2020-08-13T05:06:10.000Z","updated":"2020-08-18T02:09:32.131Z","comments":true,"path":"2020/08/12/97-Interleaving-String/","link":"","permalink":"https://jojoyang666.github.io/2020/08/12/97-Interleaving-String/","excerpt":"","text":"Solution 1 只要是遇到字符串的子序列或是匹配问题， 直接上动态规划 Code –&gt; O(m*n)123456789101112131415161718192021222324class Solution(object): def isInterleave(self, s1, s2, s3): \"\"\" :type s1: str :type s2: str :type s3: str :rtype: bool \"\"\" r, c, l = len(s1), len(s2), len(s3) if r + c != l: return False dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)] for i in xrange(1, r+1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in xrange(1, c+1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): for j in xrange(1, c+1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or (dp[i][j-1] and s2[j-1] == s3[i-1+j]) return dp[-1][-1] 1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const len1 = s1.length, len2 = s2.length, len3 = s3.length; if (len1 + len2 !== len3) return false; const dp = [...new Array(len1+1)].map(item =&gt; new Array(len2+1).fill(true)) for (let i = 1; i &lt;= len1; i++) &#123; dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1] === s3[i-1] &#125; for (let i = 1; i &lt;= len2; i++) &#123; dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1] === s3[i-1] &#125; for (let i = 1; i &lt;= len1; i++) &#123; for (let j = 1; j &lt;= len2; j++) &#123; dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1] === s3[i+j-1]) || (dp[i][j-1] &amp;&amp; s2[j-1] === s3[i+j-1]) &#125; &#125; return dp[len1][len2]&#125;; Code –&gt; O(n) space123456789101112def isInterleave3(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [True for _ in xrange(c+1)] for j in xrange(1, c+1): dp[j] = dp[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): dp[0] = (dp[0] and s1[i-1] == s3[i-1]) for j in xrange(1, c+1): dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j]) return dp[-1] Solution DFS Code123456789101112131415class Solution(object): def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False stack, visited = [(0, 0)], set((0, 0)) while stack: x, y = stack.pop() if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: stack.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: stack.append((x, y+1)); visited.add((x, y+1)) return False 12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const l1 = s1.length, l2 = s2.length, l3 = s3.length if (l1 + l2 !== l3) return false; const stack = [[0, 0]], visited = new Set() while (stack.length &gt; 0) &#123; const [x, y] = stack.pop() if (x + y === l3) return true; if (x+1 &lt;= l1 &amp;&amp; s1[x] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x+1&#125;-$&#123;y&#125;`)) &#123; stack.push([x+1, y]); visited.add(`$&#123;x+1&#125;-$&#123;y&#125;`) &#125; if (y+1 &lt;= l2 &amp;&amp; s2[y] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x&#125;-$&#123;y+1&#125;`)) &#123; stack.push([x, y+1]); visited.add(`$&#123;x&#125;-$&#123;y+1&#125;`) &#125; &#125; return false&#125;; Solution BFS123456789101112131415class Solution(object): def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False queue, visited = [(0, 0)], set((0, 0)) while queue: x, y = queue.pop(0) if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: queue.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: queue.append((x, y+1)); visited.add((x, y+1)) return False 12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const l1 = s1.length, l2 = s2.length, l3 = s3.length if (l1 + l2 !== l3) return false; const stack = [[0, 0]], visited = new Set() while (stack.length &gt; 0) &#123; const [x, y] = stack.shift() if (x + y === l3) return true; if (x+1 &lt;= l1 &amp;&amp; s1[x] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x+1&#125;-$&#123;y&#125;`)) &#123; stack.push([x+1, y]); visited.add(`$&#123;x+1&#125;-$&#123;y&#125;`) &#125; if (y+1 &lt;= l2 &amp;&amp; s2[y] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x&#125;-$&#123;y+1&#125;`)) &#123; stack.push([x, y+1]); visited.add(`$&#123;x&#125;-$&#123;y+1&#125;`) &#125; &#125; return false&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"391. Perfect Rectangle","slug":"391-Perfect-Rectangle","date":"2020-08-11T18:12:17.000Z","updated":"2020-10-01T18:02:36.803Z","comments":true,"path":"2020/08/11/391-Perfect-Rectangle/","link":"","permalink":"https://jojoyang666.github.io/2020/08/11/391-Perfect-Rectangle/","excerpt":"","text":"Solution 1 所有矩形的4个顶点只会有蓝， 绿， 红三种情况 蓝表示该顶点周围没有其他矩形 绿点表示两个矩形并排相邻 红点表示四个矩形相邻 在一个完美矩形中， 蓝色的点只能有四个 矩形的四个顶点： 左下， 左上， 右上， 右下的顺序来给顶点标号为1， 2， 4， 8 —》 考虑二进制表示 当一个点是某一个矩形的左下顶点时，这个点就不能是其他矩形的左下顶点了, 这个条件对于这四种顶点都要成立，那么对于每一个点，如果它是某个矩形的四个顶点之一. 我们记录下来，如果在别的矩形中它又是相同的顶点，那么直接返回false即可 体现了我们标记为1，2，4，8的好处 如果每个点的属性没有冲突， 那么我们来验证每个点的mask是否合理 蓝点：mask的四位只有一个1， 分别就是1(0001), 2(0010), 4(0100), 8(1000) 绿点：mask的四位有两个1, 12(1100), 10(1010), 9(1001), 6(0110), 5(0101), 3(0011)； 红点：mask的四位都是1，只有一种情况15(1111) 判定条件 mask是1， 2， 4， 8的个数， 是否是4个 每个矩形的面积累加和要等于最后的大矩形的面积， 大矩形的面积就是通过计算最小左下点和最大右上点计算得出. 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def isRectangleCover(self, rectangles): def update_counts(x, y, bit): mask, nums = counts[x, y] if mask &amp; bit: return False //因为我们规定了四个左上是1， 右上是2， 左下是4， 右下是8。 所以如果有重叠的话一定返回false（4个角重叠）， 在可以重叠的地方digit 会给合适的值 counts[x, y] = [mask | bit, nums + 1] return True counts, area = collections.defaultdict(lambda: [0, 0]), 0 minx, maxx, miny, maxy = float('inf'), float('-inf'), float('inf'), float('-inf') for blx, bly, trx, _try in rectangles: tlx, tly = blx, _try brx, bry = trx, bly minx, miny, maxx, maxy = min(minx, blx), min(miny, bly), max(maxx, trx), max(maxy, _try) if not update_counts(tlx, tly, 1): return False if not update_counts(trx, _try, 2): return False if not update_counts(blx, bly, 4): return False if not update_counts(brx, bry, 8): return False area += (trx - blx) * (_try - bly) if area != (maxx - minx) * (maxy - miny): return False for x, y in counts: nums = counts[x, y][1] if (x == minx or x == maxx) and (y == miny or y == maxy): if nums != 1: return False else: if nums != 2 and nums != 4: return False return True Solution 2 Base Idea is same with above 所有矩形的4个顶点只会有蓝， 绿， 红三种情况 蓝表示该顶点周围没有其他矩形 绿点表示两个矩形并排相邻 红点表示四个矩形相邻 不用去判断每个点最多只能是一个矩形的左下，左上，右上，或右下顶点 我们直接用一个set，对于遍历到的任意一个顶点 如果set中已经存在了，则删去这个点，如果没有就加上，这样最后会把绿点和红点都滤去 剩下的都是蓝点，我们只要看蓝点的个数是否为四个，再加上检测每个矩形面积累加和要等于最后的大矩形的面积即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @param &#123;number[][]&#125; rectangles * @return &#123;boolean&#125; */var isRectangleCover = function(rectangles) &#123; let minx = Number.POSITIVE_INFINITY, maxx = Number.NEGATIVE_INFINITY, miny = Number.POSITIVE_INFINITY, maxy = Number.NEGATIVE_INFINITY const set = new Set() let area = 0 for (let rect of rectangles) &#123; minx = Math.min(minx, rect[0]) miny = Math.min(rect[1], miny) maxx = Math.max(maxx, rect[2]) maxy = Math.max(maxy, rect[3]) area += (rect[2] - rect[0]) * (rect[3] - rect[1]); let bl = coordinate(rect[0], rect[1]) let tl = coordinate(rect[0], rect[3]) let tr = coordinate(rect[2], rect[3]) let br = coordinate(rect[2], rect[1]) if(set.has(tl)) &#123; set.delete(tl) &#125; else &#123; set.add(tl) &#125; if(set.has(tr)) &#123; set.delete(tr) &#125; else &#123; set.add(tr) &#125; if(set.has(bl)) &#123; set.delete(bl) &#125; else &#123; set.add(bl) &#125; if(set.has(br)) &#123; set.delete(br) &#125; else &#123; set.add(br) &#125; &#125; let t1 = coordinate(minx, miny) let t2 = coordinate(maxx, maxy) let t3 = coordinate(minx, maxy) let t4 = coordinate(maxx, miny) if (!set.has(t1) || !set.has(t2) || !set.has(t3) || !set.has(t4) || set.size !== 4) return false return area === (maxx - minx) * (maxy - miny)&#125;;const coordinate = (x, y) =&gt; `$&#123;x&#125;-$&#123;y&#125;` Solution 3 We keep four sets that collectively act like a difference set – one for each type (direction) of corner.For every corner that we consider, we check to see if another corner has the same coordinates. If a same-position corner of the same type exists, there is an overlap, and we produce an error.If a same-position corner that shares exactly one face exists, we can delete the corner (rectangle merge).If a same-position corner shares the coordinates but neither face, we can add our corner, increasing the number of corners required to clear those coordinates to 2.If no corner is in the same position, we add the corner.After all corners have been considered, we have a rectangle cover if each set contains exactly one corner. 123456789101112131415161718192021222324252627282930let corner = (x, y) =&gt; `$&#123; x &#125; $&#123; y &#125;`let isRectangleCover = rectangles =&gt; &#123; let tls = new Set let trs = new Set let bls = new Set let brs = new Set for (let [l, b, r, t] of rectangles) &#123; let tl = corner(t, l) let tr = corner(t, r) let bl = corner(b, l) let br = corner(b, r) if (tls.has(tl) || trs.has(tr) || bls.has(bl) || brs.has(br)) return false if (!bls.delete(tl) &amp;&amp; !trs.delete(tl)) tls.add(tl) if (!brs.delete(tr) &amp;&amp; !tls.delete(tr)) trs.add(tr) if (!brs.delete(bl) &amp;&amp; !tls.delete(bl)) bls.add(bl) if (!bls.delete(br) &amp;&amp; !trs.delete(br)) brs.add(br) &#125; return tls.size === 1 &amp;&amp; trs.size === 1 &amp;&amp; bls.size === 1 &amp;&amp; brs.size === 1&#125;;if (!bls.delete(tl) &amp;&amp; !trs.delete(tl)) tls.add(tl) ===&gt; if (trs.has(tl)) trs.delete(tl);else if (bls.has(tl)) bls.delete(tl);else tls.add(tl);","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Binary Search","slug":"Binary-Search","date":"2020-08-11T04:26:32.000Z","updated":"2020-11-11T19:08:00.254Z","comments":true,"path":"2020/08/10/Binary-Search/","link":"","permalink":"https://jojoyang666.github.io/2020/08/10/Binary-Search/","excerpt":"","text":"需要找和目标值完全相等的数 code 1234567891011const find = (nums, target) =&gt; &#123; let left = 0, right = nums.length while (left &lt; right) &#123; let mid = left + (right - left)&gt;&gt;1 if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1 else right = mid; &#125; return -1;&#125; 二分查找法的写法并不惟一， 主要可以变动的地方有四处 right初始化， 可以写成nums.length/nums.length - 1 left和right关系， 可以写成left &lt; right / left &lt;= right 更新right的赋值，可以写成 right = mid / right = mid - 1 返回值可以返回left, right, right - 1 但是这些不同的写法并不能随机组合 如果right初始化为nums.length, 那么就必须用left &lt; right, 最后的right赋值必须用right = mid 如果right初始化为nums.length-1, 那么就必须用left &lt;= right, right的赋值写成right=mid-1 查找第一个不小于目标值的数， 可变形为查找最后一个小于目标值的数 Code -&gt; 查找第一个不小于目标的数 12345678910111213const find = (nums, target) =&gt; &#123; let left = 0, right = nums.lenth; while (left &lt; right) &#123; let mid = left + (right - left)&gt;&gt;1 if (nums[mid] &lt; target) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right;&#125; 可以变形为查找最后一个小于目标值的数， 如果已经找到了第一个不小于目标值的数， 那么再往前退一位， 返回right-1， 就是最后一个小于目标值的数 注意nums[mid] &lt; target, 没有等于 查找第一个大于目标值的数， 可变形为查找最后一个不大于目标值的数 code –&gt; 查找第一个大于目标值的数 1234567891011121314const find = (nums, target) =&gt; &#123; let left = 0, right = nums.length; while (left &lt; right) &#123; let mid = left + (right - left) &gt;&gt; 1 if (nums[mid] &lt;= target) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right;&#125; 可变形为查找最后一个不大于目标值的数， 如果已经找到了第一个大于目标值的数， 那么再往前退一位， 返回right - 1, 就是最后一个不大于目标值的数 用子函数当作判断关系因为这里在二分查找法重要的比较大小的地方使用到了子函数， 来确定下一步的搜索范围， 并不是之前三类的数字大小比较 其他（通常target值不固定）比如Find Peak ELement， 求的是数组的局部峰值， 由于求的是峰值， 需要跟相邻的数字比较， 那么target就不是一个固定的值， 而且这道题一定要注意的是right的初始化， 一定要是nums.legth -1. 这是由于算出了mid后， nums[mid]要和nums[mid+1]比较， 如果right初始化为nums.length的话, mid+1可能会越界， 从而不能找到正确的值， 同时while循环的终止条件必须是 left &lt; right， 不能有等号 类似的还有一道 H-Index II，这道题的 target 也不是一个固定值，而是 len-mid，这就很意思了，跟上面的 nums[mid+1] 有异曲同工之妙，target 值都随着 mid 值的变化而变化，这里的right的初始化，一定要是 nums.size() - 1，而 while 循环的终止条件必须是 left &lt;= right，这里又必须要有等号 第四类中虽然是用子函数来判断关系，但大部分时候 mid 也会作为一个参数带入子函数进行计算，这样实际上最终算出的值还是受 mid 的影响，但是 right 却可以初始化为数组长度，循环条件也可以不带等号 https://www.cnblogs.com/grandyang/p/6854825.html 其他适合知道答案的范围， 然后通过一些条件进行binary search 来排除一半又一半的结果，最终找到答案 Python Bisectexample:a = [0,1,2,3,4,5] bisect.bisect_left(a, 2) -&gt; return 2bisect.bisect_right(a, 2) -&gt; return 3 a = [0,2,4,6,8,10]bisect.bisect_left(a, 3) -&gt; return 2bisect.bisect_right(a, 3) -&gt; return 2","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1095. Find in Mountain Array","slug":"1095-Find-in-Mountain-Array","date":"2020-08-11T03:28:18.000Z","updated":"2020-08-11T17:01:21.898Z","comments":true,"path":"2020/08/10/1095-Find-in-Mountain-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/08/10/1095-Find-in-Mountain-Array/","excerpt":"","text":"SolutionBinary Search 的判定条件， 不一定还可以和mid附近的值比较 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# \"\"\"# This is MountainArray's API interface.# You should not implement it, or speculate about its implementation# \"\"\"#class MountainArray(object):# def get(self, index):# \"\"\"# :type index: int# :rtype int# \"\"\"## def length(self):# \"\"\"# :rtype int# \"\"\"class Solution(object): def findInMountainArray(self, target, mountain_arr): \"\"\" :type target: integer :type mountain_arr: MountainArray :rtype: integer \"\"\" A = mountain_arr n = A.length() # find index of peak l, r = 0, n - 1 while l &lt; r://不能有等号 m = (l + r)/2 if A.get(m) &lt; A.get(m + 1): l = peak = m + 1 else: r = m # find target in the left of peak l, r = 0, peak while l &lt;= r: m = (l + r) / 2 if A.get(m) &lt; target: l = m + 1 elif A.get(m) &gt; target: r = m - 1 else: return m # find target in the right of peak l, r = peak, n - 1 while l &lt;= r: m = (l + r) / 2 if A.get(m) &gt; target: l = m + 1 elif A.get(m) &lt; target: r = m - 1 else: return m return -1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * // This is the MountainArray's API interface. * // You should not implement it, or speculate about its implementation * function MountainArray() &#123; * @param &#123;number&#125; index * @return &#123;number&#125; * this.get = function(index) &#123; * ... * &#125;; * * @return &#123;number&#125; * this.length = function() &#123; * ... * &#125;; * &#125;; *//** * @param &#123;number&#125; target * @param &#123;MountainArray&#125; mountainArr * @return &#123;number&#125; */var findInMountainArray = function(target, mountainArr) &#123; const n = mountainArr.length() // Find the index of the peak let l = 0, r = n - 1 let peak = 0 while (l &lt; r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) &#123; l = mid + 1 peak = l &#125; else &#123; r = mid &#125; &#125; // Find the target in the left of peak l = 0, r = peak while (l &lt;= r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &lt; target) &#123; l = mid + 1 &#125; else if (mountainArr.get(mid) &gt; target) &#123; r = mid - 1 &#125; else &#123; return mid &#125; &#125; // Find the target in the right of peak l = peak, r = n - 1 while (l &lt;= r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &gt; target) &#123; l = mid + 1 &#125; else if (mountainArr.get(mid) &lt; target) &#123; r = mid -1 &#125; else &#123; return mid &#125; &#125; return -1&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"681. Next Closest Time","slug":"681-Next-Closest-Time","date":"2020-08-10T05:05:15.000Z","updated":"2020-08-11T03:05:48.114Z","comments":true,"path":"2020/08/09/681-Next-Closest-Time/","link":"","permalink":"https://jojoyang666.github.io/2020/08/09/681-Next-Closest-Time/","excerpt":"","text":"Solution 1 时间模拟， 以当下的0为时间起点， 递增模拟 Code1234567891011121314class Solution(object): def nextClosestTime(self, time): \"\"\" :type time: str :rtype: str \"\"\" cur = 60 * int(time[:2]) + int(time[3:]) allowed = &#123;int(x) for x in time if x != ':'&#125; while True: cur = (cur + 1) % (24*60) if all(digit in allowed for block in divmod(cur, 60) for digit in divmod(block, 10)): return \"&#123;:02d&#125;:&#123;:02d&#125;\".format(*divmod(cur, 60)) 12345678910111213141516171819202122232425/** * @param &#123;string&#125; time * @return &#123;string&#125; */var nextClosestTime = function(time) &#123; let timeBlock = time.split(\":\") cur = parseInt(timeBlock[0]) * 60 + parseInt(timeBlock[1]) allowed = new Set() time.split(\"\").forEach((x) =&gt; &#123; if (x !== ':') &#123; allowed.add(parseInt(x)) &#125; &#125;) while (true) &#123; cur = (cur + 1)%(24*60); const digits = [Math.floor(Math.floor(cur/60)/10), Math.floor(cur/60)%10, Math.floor((cur%60)/10), cur%60%10] const isInAllowed = (digit) =&gt; allowed.has(digit); if (digits.every(isInAllowed))&#123; digits.splice(2, 0, \":\") return digits.join(\"\") &#125; &#125;&#125;; Solution 2 找到所有组合， 转化为分钟， 找到interval最小的 python %n -&gt; 没有负数会自动加上n, 但是JavaScript不一样会有负数12345678910111213141516171819class Solution(object): def nextClosestTime(self, time): \"\"\" :type time: str :rtype: str \"\"\" ans = start = 60 * int(time[:2]) + int(time[3:]) elapsed = 24 * 60 allowed = &#123;int(x) for x in time if x != ':'&#125; for h1, h2, m1, m2 in itertools.product(allowed, repeat = 4): hours, mins = 10 * h1 + h2, 10 * m1 + m2 if hours &lt; 24 and mins &lt; 60: cur = hours * 60 + mins cand_elapsed = (cur - start)%(24 * 60) if 0 &lt; cand_elapsed &lt; elapsed: ans = cur elapsed = cand_elapsed return \"&#123;:02d&#125;:&#123;:02d&#125;\".format(*divmod(ans, 60)) 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;string&#125; time * @return &#123;string&#125; */var nextClosestTime = function(time) &#123; let timeBlock = time.split(\":\") let ans = parseInt(timeBlock[0]) * 60 + parseInt(timeBlock[1]) let elapsed = 24 * 60, start = ans let allowed = new Set() time.split(\"\").forEach((x) =&gt; &#123; if (x !== ':') &#123; allowed.add(parseInt(x)) &#125; &#125;) for (const h1 of allowed) &#123; for (const h2 of allowed) &#123; for (const m1 of allowed) &#123; for (const m2 of allowed) &#123; const hours = 10 * h1 + h2, mins = m1 * 10 + m2 if (hours &lt; 24 &amp;&amp; mins &lt; 60) &#123; let cur = hours * 60 + mins let cand_elapsed = (cur - start + 24 * 60)%(24*60) if (cand_elapsed &lt; elapsed &amp;&amp; cand_elapsed &gt; 0) &#123; elapsed = cand_elapsed ans = cur &#125; &#125; &#125; &#125; &#125; &#125; const hours = Math.floor(ans/60) &gt;= 10 ? Math.floor(ans/60) : `0$&#123;Math.floor(ans/60)&#125;` const mins = ans%60 &gt;= 10 ? ans%60 : `0$&#123;ans%60&#125;` return `$&#123;hours&#125;:$&#123;mins&#125;`&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"284. Peeking Iterator","slug":"284-Peeking-Iterator","date":"2020-08-09T00:05:40.000Z","updated":"2020-08-09T00:07:26.541Z","comments":true,"path":"2020/08/08/284-Peeking-Iterator/","link":"","permalink":"https://jojoyang666.github.io/2020/08/08/284-Peeking-Iterator/","excerpt":"","text":"Solution 设置flag， 这种情况每个section 都要进行检测 这个flag是否符合 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * // This is the Iterator's API interface. * // You should not implement it, or speculate about its implementation. * function Iterator() &#123; * @ return &#123;number&#125; * this.next = function() &#123; // return the next number of the iterator * ... * &#125;; * * @return &#123;boolean&#125; * this.hasNext = function() &#123; // return true if it still has numbers * ... * &#125;; * &#125;; *//** * @param &#123;Iterator&#125; iterator */var PeekingIterator = function(iterator) &#123; this.list = iterator&#125;;/** * @return &#123;number&#125; */PeekingIterator.prototype.peek = function() &#123; if (this.top) &#123; return this.top &#125; if (this.list.hasNext()) &#123; this.top = this.list.next() return this.top &#125; return false&#125;;/** * @return &#123;number&#125; */PeekingIterator.prototype.next = function() &#123; if (this.top) &#123; let v = this.top this.top = null return v; &#125; return this.list.next();&#125;;/** * @return &#123;boolean&#125; */PeekingIterator.prototype.hasNext = function() &#123; if (this.top) &#123; return true; &#125; return this.list.hasNext()&#125;;/** * Your PeekingIterator object will be instantiated and called as such: * var obj = new PeekingIterator(arr) * var param_1 = obj.peek() * var param_2 = obj.next() * var param_3 = obj.hasNext() */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"403. Frog Jump","slug":"403-Frog-Jump","date":"2020-08-08T21:15:00.000Z","updated":"2020-08-08T21:19:33.635Z","comments":true,"path":"2020/08/08/403-Frog-Jump/","link":"","permalink":"https://jojoyang666.github.io/2020/08/08/403-Frog-Jump/","excerpt":"","text":"Solution dp[i] 记录跳到stone i, possible steps code12345678910111213141516171819202122/** * @param &#123;number[]&#125; stones * @return &#123;boolean&#125; */var canCross = function(stones) &#123; const dp = [[0]] for (let i = 1; i &lt; stones.length; i++) &#123; dp[i] = [] for (let j = 0; j &gt; i; j++) &#123; for (let step of dp[j]) &#123; if (Math.abs(stones[j] + step - stones[i]) &lt;= 1) &#123; dp[i].push(stones[i] - stones[j]); break; &#125; &#125; &#125; &#125; return dp[stones.length-1].length &gt; 0;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1007. Minimum Domino Rotations For Equal Row `","slug":"1007-Minimum-Domino-Rotations-For-Equal-Row","date":"2020-08-04T18:29:23.000Z","updated":"2020-08-08T21:15:41.446Z","comments":true,"path":"2020/08/04/1007-Minimum-Domino-Rotations-For-Equal-Row/","link":"","permalink":"https://jojoyang666.github.io/2020/08/04/1007-Minimum-Domino-Rotations-For-Equal-Row/","excerpt":"","text":"Solution If we take only A[0], the answer wil be wrong for the remaining possible items? In the end, the whole A/B row should be equal to A[0]/B[0], so we could arbitrarily choose A[0]/B[0] as the final target number Code1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[]&#125; A * @param &#123;number[]&#125; B * @return &#123;number&#125; */var minDominoRotations = function(A, B) &#123; const n = A.length let rotations = check(A[0], A, B, n) // If one could make all elements in A or B equal to A[0] if (rotations !== -1 || A[0] === B[0]) return rotations; // If one could make all elements in A or B equal to B[0] else return check(B[0], A, B, n)&#125;;const check = (x, A, B, n) =&gt; &#123; // how many rotations should be done to have all elements in A equal to x and to have all elements in B equal to x let rotations_a = 0, rotations_b = 0 for (let i = 0; i &lt; n; i++) &#123; if (A[i] !== x &amp;&amp; B[i] !== x) &#123; return -1; &#125; else if (A[i] !== x) &#123; rotations_a++; &#125; else if (B[i] !== x) &#123; rotations_b++; &#125; &#125; return Math.min(rotations_b, rotations_a);&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"418. Sentence Screen Fitting","slug":"418-Sentence-Screen-Fitting","date":"2020-08-03T17:52:17.000Z","updated":"2020-08-03T18:54:08.063Z","comments":true,"path":"2020/08/03/418-Sentence-Screen-Fitting/","link":"","permalink":"https://jojoyang666.github.io/2020/08/03/418-Sentence-Screen-Fitting/","excerpt":"","text":"Solution 1 Thinking start is the counter for how many valid characters from _sentence have been put to our screen _sentence[start%length] === &#39; &#39; is the situation that we do not need an extra space for current row. THe current row could be successfully fitted. SO that we need to increase our counter by using start++ think about &quot;abc de f&quot;, when at the space between de and f, you are looking for the position of the first word in the next row, which f and so you move start forward by 1 如果是’ ‘,我们没有算空格那个字符， 因为start%length in _sentence is starting from 0, 所以要加加 Code1234567891011121314151617181920212223242526/** * @param &#123;string[]&#125; sentence * @param &#123;number&#125; rows * @param &#123;number&#125; cols * @return &#123;number&#125; */var wordsTyping = function(sentence, rows, cols) &#123; const _sentence = sentence.join(' ') + ' ' let start = 0; const length = _sentence.length for (let i = 0; i &lt; rows; i++) &#123; start += cols if (_sentence[start%length] === ' ') &#123; start++;//虽然剩余的位置刚好填满了单词， 后面不用再空格了。 但是我们再算有效空位个数的时候还是要加上这个空格的 &#125; else &#123; while (start &gt; 0 &amp;&amp; _sentence[(start-1)%length] !== ' ') &#123; start--; //removimh the extra word from the next word &#125; &#125; &#125; return Math.floor(start/_sentence.length)&#125;; Solution 2 Code123456789101112131415161718192021222324252627282930313233/** * @param &#123;string[]&#125; sentence * @param &#123;number&#125; rows * @param &#123;number&#125; cols * @return &#123;number&#125; */var wordsTyping = function(sentence, rows, cols) &#123; let all = sentence.join(' ') + ' '; let res = 0, idx = 0, n = sentence.length, len = all.length for (let i = 0; i &lt; rows; i++) &#123; let colsRemaining = cols while (colsRemaining &gt; 0) &#123; if (sentence[idx].length &lt;= colsRemaining) &#123; colsRemaining -= sentence[idx].length if (colsRemaining &gt; 0) &#123; colsRemaining -= 1 //miuns the length of space &#125; if (++idx &gt;= n) &#123; res += (1 + Math.floor(colsRemaining / len)) colsRemaining %= len idx = 0 &#125; &#125; else &#123; break; &#125; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"361. Bomb Enemy","slug":"361-Bomb-Enemy","date":"2020-07-31T16:04:07.000Z","updated":"2020-08-03T17:53:13.416Z","comments":true,"path":"2020/07/31/361-Bomb-Enemy/","link":"","permalink":"https://jojoyang666.github.io/2020/07/31/361-Bomb-Enemy/","excerpt":"","text":"Solution Thinking rowCnt: record the number of ememies before hiting the next wall colCnt[j]: in the jth col, the number of emeimis before hiting the wall why colCnt would be an array? For each row, we visit each column once. Once we visit second row(and other rows too), we do not want to recompute for colums because we are traversing row wise so value of rowCnt for a row is same throughout for ith row. it is not the case with colums because as we tranverse a particular row our columns keep on changing and also we need to make sure we do not exceed n*m, that is the reasosn for array Code 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;character[][]&#125; grid * @return &#123;number&#125; */var maxKilledEnemies = function(grid) &#123; let m = grid.length, n = m ? grid[0].length : 0 let res = 0, rowCnt = 0, colCnt = new Array(n).fill(0) for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (j === 0 || grid[i][j-1] === 'W') &#123; rowCnt = 0; for (let k = j; k &lt; n &amp;&amp; grid[i][k] != 'W'; k++) &#123; rowCnt += grid[i][k] === 'E' &#125; &#125; if (i === 0 || grid[i-1][j] === 'W') &#123; colCnt[j] = 0; for (let k = i; k &lt; m &amp;&amp; grid[k][j] != 'W'; k++) &#123; colCnt[j] += grid[k][j] === 'E' &#125; &#125; if (grid[i][j] === '0') &#123; res = Math.max(res, rowCnt + colCnt[j]) &#125; &#125; &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"489. Robot Room Cleaner","slug":"489-Robot-Room-Cleaner","date":"2020-07-29T21:48:02.000Z","updated":"2020-09-10T06:06:01.356Z","comments":true,"path":"2020/07/29/489-Robot-Room-Cleaner/","link":"","permalink":"https://jojoyang666.github.io/2020/07/29/489-Robot-Room-Cleaner/","excerpt":"","text":"Solution https://www.youtube.com/watch?v=y4izHfShEfU Backtrack algorithm we do not know where the robot is (the exactly location), thus we give the initial location is (0, 0) then [[-1, 0], [0, 1], [1, 0], [0, -1]] to 4 directions, we have all the point which is relative to the initial position This is the robot, it can only move to one direction(move forward), otherwise it need to turn right/left if the robot arrived a position where it is neighbors all have been vistied, it can not go back to the original position directly(like normal backtrack) Thus, we need to go back following the path how we get here exactly. This is the reason why we need goBack function why we turn the direction in the clock-wise? the robot just one move direction(move forward) –&gt; clock-wise way to guarantee 机器人要移动的方向和转向是一样的 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * // This is the robot's control interface. * // You should not implement it, or speculate about its implementation * function Robot() &#123; * // Returns true if the cell in front is open and robot moves into the cell. * // Returns false if the cell in front is blocked and robot stays in the current cell. * @return &#123;boolean&#125; * this.move = function() &#123; * ... * &#125;; * * // Robot will stay in the same cell after calling turnLeft/turnRight. * // Each turn will be 90 degrees. * @return &#123;void&#125; * this.turnLeft = function() &#123; * ... * &#125;; * * // Robot will stay in the same cell after calling turnLeft/turnRight. * // Each turn will be 90 degrees. * @return &#123;void&#125; * this.turnRight = function() &#123; * ... * &#125;; * * // Clean the current cell. * @return &#123;void&#125; * this.clean = function() &#123; * ... * &#125;; * &#125;; *//** * @param &#123;Robot&#125; robot * @return &#123;void&#125; */var cleanRoom = function(robot) &#123; const visited = new Set(); helper(robot, 0, 0, 0, visited)&#125;;const goback = (robot) =&gt; &#123; robot.turnRight(); robot.turnRight(); robot.move(); robot.turnLeft(); robot.turnLeft();&#125;const helper = (robot, x, y, dir, visited) =&gt; &#123; robot.clean(); visited.add(`$&#123;x&#125;-$&#123;y&#125;`); const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]] for (let i = 0; i &lt; 4; i++) &#123; let cur = (i + dir)%4, newX = x + dirs[cur][0], newY = y + dirs[cur][1]; if (!visited.has(`$&#123;newX&#125;-$&#123;newY&#125;`) &amp;&amp; robot.move()) &#123; helper(robot, newX, newY, cur, visited); goback(robot) &#125; robot.turnRight(); &#125;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"212. Word Search II","slug":"212-Word-Search-II","date":"2020-07-24T13:54:43.000Z","updated":"2020-07-24T14:19:01.029Z","comments":true,"path":"2020/07/24/212-Word-Search-II/","link":"","permalink":"https://jojoyang666.github.io/2020/07/24/212-Word-Search-II/","excerpt":"","text":"Solution Trie Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @param &#123;character[][]&#125; board * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(board, words) &#123; let res = [] const buildTrie = () =&gt; &#123; const root = &#123;&#125; for (let w of words) &#123; let node = root; for (let c of w) &#123; if (!node[c]) &#123; node[c] = &#123;&#125; &#125; node = node[c]; &#125; node.word = w; &#125; return root &#125; const search = (node, i, j) =&gt; &#123; if (node.word) &#123; res.push(node.word) node.word = null; &#125; if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length) return; if (!node[board[i][j]]) return; const c = board[i][j] board[i][j] = '#'; const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]] for (let dir of dirs) &#123; search(node[c], i + dir[0], j + dir[1]); &#125; board[i][j] = c; &#125; const root = buildTrie(); for (let i = 0; i &lt; board.length; i++) &#123; for (let j = 0; j &lt; board[0].length; j++) &#123; search(root, i, j) &#125; &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"295. Find Median from Data Stream","slug":"295-Find-Median-from-Data-Stream","date":"2020-07-23T00:21:33.000Z","updated":"2020-07-23T00:25:40.576Z","comments":true,"path":"2020/07/22/295-Find-Median-from-Data-Stream/","link":"","permalink":"https://jojoyang666.github.io/2020/07/22/295-Find-Median-from-Data-Stream/","excerpt":"","text":"Solution In python, heapq is the min heap, to do the max heap, there is a trick when push the the item, we can push -item, it will logically become the max heap Min Heap: put larger number part –&gt; largeMax Heap: put smaller number part –&gt; small the diff length of two heap must just be 1 code 1234567891011121314151617181920212223242526272829303132333435from heapq import *class MedianFinder(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.heaps = [], [] def addNum(self, num): \"\"\" :type num: int :rtype: None \"\"\" small, large = self.heaps heappush(small, -heappushpop(large, num)) if (len(large) &lt; len(small)): heappush(large, -heappop(small)) def findMedian(self): \"\"\" :rtype: float \"\"\" small, large = self.heaps if len(large) &gt; len(small): return float(large[0]) return (large[0] - small[0]) / 2.0# Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)# param_2 = obj.findMedian()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"123. Best Time to Buy and Sell Stock III","slug":"123-Best-Time-to-Buy-and-Sell-Stock-III","date":"2020-07-22T23:26:01.000Z","updated":"2020-07-22T23:52:03.701Z","comments":true,"path":"2020/07/22/123-Best-Time-to-Buy-and-Sell-Stock-III/","link":"","permalink":"https://jojoyang666.github.io/2020/07/22/123-Best-Time-to-Buy-and-Sell-Stock-III/","excerpt":"","text":"Solution 1 Ideas: two variables for the dp: global one and local one local[i][j]: means when we at the ith day, the maximum profit for having at most j transactions and the last one traction is the ith day global[i][j]: means when we at the ith day, the maximim profit for having at most j transactions local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff) why use max(diff, 0) –&gt; which means buy at ith day and sell at ith day global[i][j] = max(local[i][j], global[i - 1][j]) Code123456789101112131415161718192021/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; if (!prices || !prices.length) return 0; let n = prices.length, g = [...Array(n)].map(() =&gt; new Array(3).fill(0)), l = [...new Array(n)].map(() =&gt; new Array(3).fill(0)); // console.log('g ', g) for (let i = 1; i &lt; prices.length; i++) &#123; let diff = prices[i] - prices[i-1]; for (let j = 1; j &lt;= 2; j++) &#123; l[i][j] = Math.max(g[i-1][j-1] + Math.max(diff, 0), l[i-1][j] + diff); g[i][j] = Math.max(l[i][j], g[i-1][j]) &#125; &#125; return g[n-1][2]&#125;; Solution 2 use one dimensional array rather than two dimensional array, because of overriding problem, need to use j from 2 to 1 Code1234567891011121314151617181920/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; if (!prices || !prices.length) return 0; let g = new Array(3).fill(0), l = new Array(3).fill(0) for (let i = 0; i &lt; prices.length - 1; i++) &#123; let diff = prices[i + 1] - prices[i]; for (let j = 2; j &gt; 0; j--) &#123; l[j] = Math.max(g[j-1] + Math.max(diff, 0), l[j] + diff) g[j] = Math.max(l[j], g[j]) &#125; &#125; return g[2]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"4. Median of Two Sorted Arrays ","slug":"4-Median-of-Two-Sorted-Arrays","date":"2020-07-21T18:19:08.000Z","updated":"2020-07-21T21:58:04.654Z","comments":true,"path":"2020/07/21/4-Median-of-Two-Sorted-Arrays/","link":"","permalink":"https://jojoyang666.github.io/2020/07/21/4-Median-of-Two-Sorted-Arrays/","excerpt":"","text":"Solution 1 Trick: Find the median in an array, there are two cases – odd and even: number a: (m + 1)/2 number b: (m+2)/2. median is: a + b / 2 ==&gt; in this way: can handle even and odd case together in javascript: if /2, to aviod use Math.floor ==&gt; can use &gt;&gt;. Note: ‘&gt;&gt;’ is lower priority than +/- Idea: Find the kth element in the array Find k/2th in each array, by comparing, do drop some not possible values in the array Recursive function must be aware of the bottom case 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123; let m = nums1.length, n = nums2.length, left = (m + n + 1) &gt;&gt; 1, right = (m + n + 2) &gt;&gt; 1; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right))/2;&#125;;// Find the Kth number in nums1 and nums2const findKth = (nums1, i, nums2, j, k) =&gt; &#123; if (i &gt;= nums1.length) return nums2[j + k - 1]; if (j &gt;= nums2.length) return nums1[i + k - 1]; if (k == 1) return Math.min(nums1[i], nums2[j]); let minVal1 = (i + (k &gt;&gt; 1) - 1 &lt; nums1.length) ? nums1[i + (k &gt;&gt; 1) - 1] : Number.MAX_VALUE; let minVal2 = (j + (k &gt;&gt; 1) - 1 &lt; nums2.length) ? nums2[j + (k &gt;&gt; 1) - 1] : Number.MAX_VALUE; if (minVal1 &lt; minVal2) return findKth(nums1, i + (k &gt;&gt; 1), nums2, j, k - (k &gt;&gt; 1)); else return findKth(nums1, i, nums2, j + (k &gt;&gt; 1), k - (k &gt;&gt; 1)); &#125; Solution 2 Basic thinking: If cut the sorted array to two havles of equal length, then median is the average of max(lower_half) and min(upper_half). i.e. the two numbers immediately next to the cut L, R, N Meaning L: represent the number immediately left to the cut R: the right counterpart N: the length of the array N L = (n-1)/2, R=N/2 Be ready for the two array situation, let’s add imaginary positions(represented as ‘#’)`[6 9 13 18] -&gt; [# 6 # 9 # 13 # 18 #] (N = 4)position index 0 1 2 3 4 5 6 7 8 (N_Position = 9) [6 9 11 13 18]-&gt; [# 6 # 9 # 11 # 13 # 18 #] (N = 5)position index 0 1 2 3 4 5 6 7 8 9 10 (N_Position = 11)` there are always exactly 2*N+1 positions regardeless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2.4. To find the cut position: –&gt; using the binary search among two arrays * there are 2N1 + 2N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut * therefore, whem we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k * when the cuts are made, wh have two L’s and two R’s. They are * L1 = A1[(C1-1)/2]; R1 = A1[C1/2] * L2 = A2[(C2-1)/2]; R2 = A2[C2/2] * Need to make sure if the cut is what we want. Also ecause the A1, A2 are sorted. We can use binary search * we need to make sure * L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2 * because two arrays are sorted L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 * If we have L1 &gt; R2, it means there are too many large numbers on the left half of A1, then we must move C1 to the left(i,e. move the C2 to the right) * If L2 &gt; R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left. Otherwise, this cut is the right one. * After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2;5. https://www.youtube.com/watch?v=LPFhl65R7ww6. https://www.cnblogs.com/grandyang/p/4465932.html7. Code 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123; let m = nums1.length, n = nums2.length if (m &lt; n) return findMedianSortedArrays(nums2, nums1) // make sure the cut2 is the shorter one if (n == 0) return (nums1[(m-1)&gt;&gt;1] + nums1[(m&gt;&gt;1)])/2; let left = 0, right = n * 2; while (left &lt;= right) &#123; let mid2 = (left + right) &gt;&gt; 1 let mid1 = m + n - mid2; let L1 = mid1 === 0 ? Number.NEGATIVE_INFINITY : nums1[(mid1 - 1) &gt;&gt; 1]; let L2 = mid2 === 0 ? Number.NEGATIVE_INFINITY : nums2[(mid2 - 1) &gt;&gt; 1]; let R1 = mid1 === m * 2 ? Number.POSITIVE_INFINITY : nums1[mid1 &gt;&gt; 1]; let R2 = mid2 === n * 2 ? Number.POSITIVE_INFINITY : nums2[mid2 &gt;&gt; 1]; if (L1 &gt; R2) &#123; left = mid2 + 1; &#125; else if (L2 &gt; R1) &#123; right = mid2 - 1; &#125; else &#123; return (Math.max(L1, L2) + Math.min(R1, R2))/2; &#125; &#125; return -1;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"128. Longest Consecutive Sequence","slug":"128-Longest-Consecutive-Sequence","date":"2020-07-16T17:28:43.000Z","updated":"2020-07-16T18:12:42.169Z","comments":true,"path":"2020/07/16/128-Longest-Consecutive-Sequence/","link":"","permalink":"https://jojoyang666.github.io/2020/07/16/128-Longest-Consecutive-Sequence/","excerpt":"","text":"Solution 1 set and pointer Javascript code12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var longestConsecutive = function(nums) &#123; if (!nums || nums.length === 0) return 0; const set = new Set(nums); let res = 0; for (let num of nums) &#123; if (!set.has(num)) continue; set.delete(num); let prev = num - 1, next = num + 1; while (set.has(prev)) set.delete(prev--); while (set.has(next)) set.delete(next++); res = Math.max(res, next - prev - 1); &#125; return res;&#125;; python code1234567891011121314class Solution: def longestConsecutive(self, nums): nums = set(nums) maxlen = 0 while nums: first = last = nums.pop() while first - 1 in nums: first -= 1 nums.remove(first) while last + 1 in nums: last += 1 nums.remove(last) maxlen = max(maxlen, last - first + 1) return maxlen Solution 2 hashmap, only store the sequence length to the boundary points of the sequence code123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var longestConsecutive = function(nums) &#123; let max = 0 const lens = &#123;&#125; for (let n of nums) &#123; if (lens[n] !== undefined) continue; const l = lens[n-1] || 0; const r = lens[n+1] || 0; const len = l + r + 1; lens[n - l] = len; lens[n] = len; lens[n + r] = len; max = Math.max(max, len); &#125; return max;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"LinkedList","slug":"LinkedList","date":"2020-07-16T04:56:04.000Z","updated":"2020-07-16T05:10:29.038Z","comments":true,"path":"2020/07/15/LinkedList/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/LinkedList/","excerpt":"","text":"Conclusion dummy node is very common, especially head dummy Node Reverse LinkedList code:123456789101112// prev is the dummy head, next is nullconst reverseOneGroup = (pre, next) =&gt; &#123; let last = pre.next, cur = last.next; while (cur != next) &#123; last.next = cur.next cur.next = pre.next pre.next = cur cur = last.next &#125; return last&#125; 123456789101112// head is actual head, tail is null in initialconst reverse = (head, tail) =&gt; &#123; let pre = tail while (head != tail) &#123; let t = head.next head.next = pre pre = head head = t &#125; return pre&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"25. Reverse Nodes in k-Group","slug":"25-Reverse-Nodes-in-k-Group","date":"2020-07-16T04:53:59.000Z","updated":"2020-07-16T05:10:52.902Z","comments":true,"path":"2020/07/15/25-Reverse-Nodes-in-k-Group/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/25-Reverse-Nodes-in-k-Group/","excerpt":"","text":"Solution 1 code123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var reverseKGroup = function(head, k) &#123; if (!head || k == 1) return head let dummy = new ListNode(-1), pre = dummy, cur = head; dummy.next = head; for (let i = 1; cur; i++) &#123; if (i%k === 0) &#123; pre = reverseOneGroup(pre, cur.next) cur = pre.next &#125; else &#123; cur = cur.next &#125; &#125; return dummy.next&#125;;const reverseOneGroup = (pre, next) =&gt; &#123; let last = pre.next, cur = last.next; while (cur != next) &#123; last.next = cur.next cur.next = pre.next pre.next = cur cur = last.next &#125; return last&#125; Solution 2123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var reverseKGroup = function(head, k) &#123; let cur = head for (let i = 0; i &lt; k; i++) &#123; if (!cur) return head; cur = cur.next &#125; let new_head = reverse(head, cur) head.next = reverseKGroup(cur, k) return new_head&#125;;const reverse = (head, tail) =&gt; &#123; let pre = tail while (head != tail) &#123; let t = head.next head.next = pre pre = head head = t &#125; return pre&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"https://jojoyang666.github.io/tags/LinkedList/"}]},{"title":"381. Insert Delete GetRandom O(1) - Duplicates allowed","slug":"381-Insert-Delete-GetRandom-O-1-Duplicates-allowed","date":"2020-07-15T20:42:55.000Z","updated":"2020-07-16T05:11:56.276Z","comments":true,"path":"2020/07/15/381-Insert-Delete-GetRandom-O-1-Duplicates-allowed/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/381-Insert-Delete-GetRandom-O-1-Duplicates-allowed/","excerpt":"","text":"Solution 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Initialize your data structure here. */var RandomizedCollection = function() &#123; this.map = &#123;&#125; // val: [idx1, idx2] this.array = [] // [[val, 0], [val, 1]...], the seconde element in the array represents the idx of this value in the value of map&#125;;/** * Inserts a value to the collection. Returns true if the collection did not already contain the specified element. * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedCollection.prototype.insert = function(val) &#123; let res = true if (this.map[val] !== undefined) res = false this.map[val] = this.map[val] || [] this.map[val].push(this.array.length) this.array.push([val, this.map[val].length-1]); return res;&#125;;/** * Removes a value from the collection. Returns true if the collection contained the specified element. * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedCollection.prototype.remove = function(val) &#123; if (this.map[val] === undefined) return false; let valIdx = this.map[val].pop(); if (!this.map[val].length) delete this.map[val]; let lastIdx = this.array.length - 1 if (valIdx === lastIdx) &#123; this.array.pop(); &#125; else &#123; [this.array[valIdx], this.array[lastIdx]] = [this.array[lastIdx], this.array[valIdx]] this.array.pop(); let [key, idx] = this.array[valIdx] this.map[key][idx] = valIdx; &#125; return true;&#125;;/** * Get a random element from the collection. * @return &#123;number&#125; */RandomizedCollection.prototype.getRandom = function() &#123; return this.array[Math.floor(Math.random() * this.array.length)][0];&#125;;/** * Your RandomizedCollection object will be instantiated and called as such: * var obj = new RandomizedCollection() * var param_1 = obj.insert(val) * var param_2 = obj.remove(val) * var param_3 = obj.getRandom() */ Solution 2:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import randomclass RandomizedCollection(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.vals, self.idxs = [], collections.defaultdict(set) def insert(self, val): \"\"\" Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool \"\"\" self.vals.append(val) self.idxs[val].add(len(self.vals)-1) return len(self.idxs[val]) == 1 // check brillent def remove(self, val): \"\"\" Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool \"\"\" if self.idxs[val]: out, ins = self.idxs[val].pop(), self.vals[-1] self.vals[out] = ins self.idxs[ins].add(out) self.idxs[ins].discard(len(self.vals)-1) self.vals.pop() return True return False def getRandom(self): \"\"\" Get a random element from the collection. :rtype: int \"\"\" return random.choice(self.vals)# Your RandomizedCollection object will be instantiated and called as such:# obj = RandomizedCollection()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"432. All Oone Data Structure","slug":"432-All-Oone-Data-Structure","date":"2020-07-15T19:09:14.000Z","updated":"2020-07-16T05:12:07.709Z","comments":true,"path":"2020/07/15/432-All-Oone-Data-Structure/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/432-All-Oone-Data-Structure/","excerpt":"","text":"Solution class Node: key_set: is set of key. In current scenario, all key with the same frequency prev node next node class DoubleLinkedList head_node tail_node item is Node, this class is a link list of Node class AllOne dll is a DoubleLinkedList -&gt; node store set of key key_counter is a dict -&gt; key is key, value is how many times this key appear node_freq is a dict -&gt; key is how many times a key appear, value is the node Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132from collections import defaultdictclass Node(object): def __init__(self): self.key_set = set([]) self.prev, self.next = None, None def add_key(self, key): self.key_set.add(key) def remove_key(self, key): self.key_set.remove(key) def get_any_key(self): if self.key_set: result = self.key_set.pop() self.add_key(result) return result else: return None def count(self): return len(self.key_set) def is_empty(self): return self.count() == 0 class DoubleLinkedList(object): def __init__(self): self.head_node, self.tail_node = Node(), Node() self.head_node.next, self.tail_node.prev = self.tail_node, self.head_node def insert_after(self, x): node, temp = Node(), x.next x.next, node.prev = node, x node.next, temp.prev = temp, node return node def insert_before(self, x): return self.insert_after(x.prev) def remove(self, x): prev_node = x.prev prev_node.next, x.next.prev = x.next, prev_node def get_head(self): return self.head_node.next def get_tail(self): return self.tail_node.prev def get_sentinel_head(self): return self.head_node def get_sentinel_tail(self): return self.tail_node class AllOne(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int) self.node_freq = &#123;0: self.dll.get_sentinel_head()&#125; def _rmv_key_pf_node(self, pf, key): node = self.node_freq[pf] node.remove_key(key) if node.is_empty(): self.dll.remove(node) self.node_freq.pop(pf) return def inc(self, key): \"\"\" Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. :type key: str :rtype: None \"\"\" self.key_counter[key] += 1 cf, pf = self.key_counter[key], self.key_counter[key]-1 if cf not in self.node_freq: self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf]) self.node_freq[cf].add_key(key) if pf &gt; 0: self._rmv_key_pf_node(pf, key) def dec(self, key): \"\"\" Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. :type key: str :rtype: None \"\"\" if key in self.key_counter: self.key_counter[key] -= 1 cf, pf = self.key_counter[key], self.key_counter[key] + 1 if self.key_counter[key] == 0: self.key_counter.pop(key) if cf != 0: if cf not in self.node_freq: self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf]) self.node_freq[cf].add_key(key) self._rmv_key_pf_node(pf, key) def getMaxKey(self): \"\"\" Returns one of the keys with maximal value. :rtype: str \"\"\" return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() &gt; 0 else \"\" def getMinKey(self): \"\"\" Returns one of the keys with Minimal value. :rtype: str \"\"\" return self.dll.get_head().get_any_key() if self.dll.get_head().count() &gt; 0 else \"\" # Your AllOne object will be instantiated and called as such:# obj = AllOne()# obj.inc(key)# obj.dec(key)# param_3 = obj.getMaxKey()# param_4 = obj.getMinKey()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"python-basic-syntax","slug":"python-basic-syntax","date":"2020-07-02T19:07:39.000Z","updated":"2020-07-02T19:30:44.985Z","comments":true,"path":"2020/07/02/python-basic-syntax/","link":"","permalink":"https://jojoyang666.github.io/2020/07/02/python-basic-syntax/","excerpt":"","text":"from import and import Util.py 12345def lookNum(): print(\"I am number\") def lookStr(): print(\"I am string\") Teacher.py 1234567class Teacher: def check(self): return 'I am teacher'; class Order: def checkOrder(self): return 'I am order'; Student.py 123456789101112from Teacher import *import Utilclass Student: def login(self): str = Teacher.check(self) order = Order.checkOrder(self) Util.lookNum() Util.lookStr() print(str+'login success'+order) s = Student()s.login() Conclusion when we import a class, we must use from &lt;..&gt; import &lt;..&gt; if we write multiple classes in a file, we can use from Teacher import * import all if we just want to import one class from a file, we need to deicate the name of class. For example: from Teacher import Order If the file has some methods rather than a class file, can use import &lt;name of file&gt; directly, which means import all the methods from the file. For example: import Util, when want to use the specific method –&gt; Util.lookNum() if want to just import one method, from Util import lookNum, use it –&gt; lookNum()","categories":[{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"}],"tags":[]},{"title":"307. Range Sum Query - Mutable","slug":"307-Range-Sum-Query-Mutable","date":"2020-07-01T18:22:45.000Z","updated":"2020-07-16T05:11:38.034Z","comments":true,"path":"2020/07/01/307-Range-Sum-Query-Mutable/","link":"","permalink":"https://jojoyang666.github.io/2020/07/01/307-Range-Sum-Query-Mutable/","excerpt":"","text":"Solution1 Binary Indexed Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;number[]&#125; nums */var NumArray = function(nums) &#123; this.bitArray = new Array(nums.length + 1); this.nums = nums for (let i = 0; i &lt; nums.length; i++) &#123; this.bitArray[i+1] = nums[i] &#125; for (let i = 1; i &lt; this.bitArray.length; i++) &#123; let j = i + (i&amp;-i) if (j &lt; this.bitArray.length) &#123; this.bitArray[j] += this.bitArray[i] &#125; &#125;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; val * @return &#123;void&#125; */NumArray.prototype.update = function(i, val) &#123; let idx = i + 1 let delta = val - this.nums[i] while (idx &lt; this.bitArray.length) &#123; this.bitArray[idx] += delta idx = idx + (idx &amp; -idx) &#125; this.nums[i] = val;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; j * @return &#123;number&#125; */NumArray.prototype.sumRange = function(i, j) &#123; const prefixSum = (idx) =&gt; &#123; idx += 1 let result = 0; while (idx &gt; 0) &#123; result += this.bitArray[idx] idx = idx - (idx &amp; -idx) &#125; return result; &#125; return prefixSum(j) - prefixSum(i-1);&#125;;/** * Your NumArray object will be instantiated and called as such: * var obj = new NumArray(nums) * obj.update(i,val) * var param_2 = obj.sumRange(i,j) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","date":"2020-06-30T23:47:14.000Z","updated":"2020-07-01T18:26:03.531Z","comments":true,"path":"2020/06/30/Binary-Indexed-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/06/30/Binary-Indexed-Tree/","excerpt":"","text":"Definition A data structure that can efficiently update element and calculate prefix sums in a table of numbers It can solve the problems below efficiently update(idx, delta): add num at the number which at position idx prefixSum(idx): get the sum of numbers which start from position 1 to idx(include idx) rangeSum(from_idx, to_idx): get the sum of all the numbers which is from from_idx to to_idx Thoughts about Construction Binary Indexed Tree store the element in a logical way according to the binary of number Sum in the Binary Indexed Tree: Given the position i(we want to get the sum from position 1 to i), like 13 13 = 2^3 + 2^2 + 2^0 =&gt; prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13) Note: RANGE(x, y) represent the sum of array starting from postion x to postion y First level, fill from the first number in the array. length is the sum of 2^m(m is from 0 to infinite) numbersfor example 2^0, 2^1, 2^2, 2^3. stop here because 2^4 exceeds the length of array Second level. fill from 3(the first hole). length is the sum of 2^m(m is from 0 to infinite) numbers — always start from hole, to the end of array Third level is same as previous one contruct a binary indexed array, we call it BIT, for our coonvience, we index it starting from 1 prefixSum(13) = prefixSum(0b0001101) = BIT[13] + BIT[12] + BIT[8] This is how tree looks like: How to get prefix sum or range sumWay to find the parent node of current node Observation From BelowprefixSum(13) = prefixSum(0b0001101)= BIT[13] + BIT[12] + BIT[8]= BIT[0b00001101] + BIT[0b00001100] + BIT[0b00001000] Move from bottom to Up, actually is a process to flip last digit 1 to 0, for example x = 13 x = 13 = 0b00001101 -x = -13 = 0b11110011 x &amp; (-x) = 0b00000001 x - (x &amp; (-x)) = 0b00001100 Update elment in the array For example, update(5,2), we want to add 2 to the number at postion 5, the process of it would like: we can see that, the postition needed to update is the binary of original position plus 1 to the last 1 in the binary representation, for example x = 5 x = 5 = 0b00000101 -x = -5 = 0b11111011 x &amp; (-x) = 0b00000001 x + (x &amp; (-x)) = 0b00000110 Construction of Binary Indexed TreeMethod 1 Iinite an array with all 0, Do the update(i, delta) for every item –&gt; O(nlgn) Method 2Input is an array list with length n Initianize an array bit with length n+1 Put the numbers of list to bit array from position 1 to n for index i from 1 to n j = i + (i &amp; -i)，if j &lt; n + 1，then bit[j] = bit[j] + bit[i] Conclusion 如何确定某个位置到底是有几个数组成的呢 原来是根据坐标的最低位 Low Bit 来决定的，所谓的最低位，就是二进制数的最右边的一个1开始，加上后面的0(如果有的话)组成的数字 Notes (i &amp; -i): trick to extract the lowest set bit of i Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243public class BinaryIndexedTree &#123; private int[] bitArr; public BinaryIndexedTree(int[] list) &#123; // log(n) this.bitArr = new int[list.length + 1]; for (int i = 0; i &lt; list.length; i++) &#123; this.bitArr[i + 1] = list[i]; &#125; for (int i = 1; i &lt; this.bitArr.length; i++) &#123; let j = i + (i &amp; -i); if (j &lt; this.bitArr.length) &#123; this.bitArr[j] += this.bitArr[i] &#125; &#125; &#125; public void update(int idx, int delta) &#123; idx += 1 while (idx &lt; this.bitArr.length) &#123; this.bitArr[idx] += delta idx = idx + (idx &amp; -idx) &#125; &#125; public int prefixSum(int idx) &#123; idx += 1 int result = 0 while (idx &gt; 0) &#123; result += this.bitArr[idx] idx = idx - (idx &amp; -idx) &#125; return result &#125; public int rangeSum(int from_idx, int to_idx)&#123; return prefixSum(to_idx) - prefixSum(from_idx-1) &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://jojoyang666.github.io/tags/Binary-Indexed-Tree/"}]},{"title":"React LifeCycle","slug":"React-LifeCycle","date":"2020-06-25T16:51:13.000Z","updated":"2020-06-25T17:56:12.957Z","comments":true,"path":"2020/06/25/React-LifeCycle/","link":"","permalink":"https://jojoyang666.github.io/2020/06/25/React-LifeCycle/","excerpt":"","text":"Lifecycle Diagram UpdatingcomponentDidUpdate invoked immediately after updating occurs, is not called for the initial render A good place to do network requests as long as you compare the current props to previous props(e.g. a network request may not be necessary if the props have not changed) May call setState() immediately in componentDidUpdate(), but nore that it must be wrapped in a condition, otherwise will cause a infinite loop If try to “mirror” some state to a prop coming from above, consider using the prop directly instead shouldComponentUpdate Let react know if a component’s output is not affected by the current change in state or props Default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior Invoked before rendering when new props or state are being received. Defaults to true Exists as a performance optimization, do not rely on it to “prevent” a rendering, as this can lead bugs If want to prevent a rendering, can use PureComponent PureComponent performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped Noted that returning false does not prevent child components from rerendering when their states changes Not recommend doing deap equality checks or using JSON.stringify() in shouldComponentUpdate(), it is every inefficient and will harm the performanced React.PureComponent similar to React.Component. The difference between them is: React.Component does not implement shouldComponentUpdate() React.PureComponent implements it with a shallow prop and state comparison React.PureComponent’s shouldComponentUpdate only shallowly compares the object if contains complex data structer, may introduce false-negative for deeper diff React.PureComponent’s shouldComponentUpdate skips prop updates for the whole component subtree Make sure all the children components are also pure","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"}]},{"title":"308. Range Sum Query 2D - Mutable","slug":"308-Range-Sum-Query-2D-Mutable","date":"2020-06-24T18:27:47.000Z","updated":"2020-07-16T05:11:42.444Z","comments":true,"path":"2020/06/24/308-Range-Sum-Query-2D-Mutable/","link":"","permalink":"https://jojoyang666.github.io/2020/06/24/308-Range-Sum-Query-2D-Mutable/","excerpt":"","text":"Solution I 建立列之和的矩阵： 就是(i, j)就是(0, j) + (1, j) + … + (i, j) 之和 相当于把多个一维的区间之和拼到了一起， 所以在构造函数中需要建立起这样一个列之和的矩阵， 然后在更新某一个位置时， 我们只需要将该列中改变的位置下面的所有数字更新一下即可 求某个区间的和时， 只要将相差的各列中对应的起始和结束的行上的差值累加起来即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @param &#123;number[][]&#125; matrix */var NumMatrix = function(matrix) &#123; if (!matrix.length || !matrix[0].length) &#123; return; &#125; this.matrix = matrix this.colSum = [...new Array(matrix.length + 1)].map(item =&gt; new Array(matrix[0].length).fill(0)); for (let i = 1; i &lt; this.colSum.length; i++) &#123; for (let j = 0; j &lt; this.colSum[0].length; j++) &#123; this.colSum[i][j] = this.colSum[i-1][j] + this.matrix[i-1][j]; &#125; &#125;&#125;;/** * @param &#123;number&#125; row * @param &#123;number&#125; col * @param &#123;number&#125; val * @return &#123;void&#125; */NumMatrix.prototype.update = function(row, col, val) &#123; for (let i = row + 1; i &lt; this.colSum.length; i++) &#123; this.colSum[i][col] += val - this.matrix[row][col] &#125; this.matrix[row][col] = val&#125;;/** * @param &#123;number&#125; row1 * @param &#123;number&#125; col1 * @param &#123;number&#125; row2 * @param &#123;number&#125; col2 * @return &#123;number&#125; */NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) &#123; let res = 0; for (let j = col1; j &lt;= col2; j++) &#123; res += this.colSum[row2+1][j] - this.colSum[row1][j]; &#125; return res&#125;;/** * Your NumMatrix object will be instantiated and called as such: * var obj = new NumMatrix(matrix) * obj.update(row,col,val) * var param_2 = obj.sumRegion(row1,col1,row2,col2) */ Solution II","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Docker","slug":"Docker","date":"2020-06-23T18:09:23.000Z","updated":"2020-06-23T18:20:38.418Z","comments":true,"path":"2020/06/23/Docker/","link":"","permalink":"https://jojoyang666.github.io/2020/06/23/Docker/","excerpt":"","text":"Load docker load &lt; ***.tar.gz —&gt; load images from .tar.gz docker tag ** ***","categories":[{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"}],"tags":[]},{"title":"218. The Skyline Problem","slug":"218-The-Skyline-Problem","date":"2020-06-23T16:56:50.000Z","updated":"2020-07-16T05:11:09.755Z","comments":true,"path":"2020/06/23/218-The-Skyline-Problem/","link":"","permalink":"https://jojoyang666.github.io/2020/06/23/218-The-Skyline-Problem/","excerpt":"","text":"SolutionJSBasic Ideas for JS Treat all left, right positions as the candidate x-positions For each candidate x-position, find out it’s y-position by search for the highest height on top of that position Determine if it’s necessary to record the position by comparing the height with the previous height there is no heap in JS JS Code1234567891011121314151617181920212223242526272829303132var getSkyline = function(buildings) &#123; let cp = new Set(); for (let [l, r, h] of buildings) &#123; cp.add(l); cp.add(r); &#125; let cp1 = [...cp], n = buildings.length; cp1.sort((a, b) =&gt; Number.parseInt(a) - Number.parseInt(b)); let res = [[-1, 0]] for (let p of cp1) &#123; let i = 0, height = 0; while (i &lt; n &amp;&amp; buildings[i][0] &lt;= p) &#123; if (buildings[i][1] &gt; p) &#123; height = Math.max(height, buildings[i][2]); &#125; i++; &#125; if (res[res.length-1][1] === height) &#123; continue; &#125; res.push([p, height]); &#125; return res.slice(1);&#125;; PythonBasic Ideas for Python 对于一个building， 他由(l, r, h)三元组组成， 我们可以将其分解成两种事件 在 left position, 高度从0增加到h（并且这个高度将持续到right position） 在 right position, 高度从h降低到0 引入了一个event结构: 在某一个position p, 他引入了一个高度为h的skyline， 将一直持续到另一个end position 对于right position高度降为0的event， 它的持续长度是无效的 只保留一个right position event， 就可以同时触发不同的两个building， 在同一right position从各自的h降为0的event， 所以对right position events做集合操作会减少计算量 由于需要从左到右触发event， 所以按position对events排序，并且对于同一position， 我们需要先触发更高的h事件， 那么高的h相比于低的h会占据更高的skyline, 低h的 key point就一定不会产生； 相反， 可能会从低到高连续产生冗余的 key point, 所以event不仅需要按第一个元素position排序， 在position相同时， 第二个元素h也必须是有序的 hp记录了对于一条高为h的skyline，他将持续到什么position才结束: [h, endposition], 在同时有多条skyline的时候, h最高的那条skyline会掩盖掉h低的skyline， 因此在event出发时， 需要得到当前最高的skyline; 所以利用heap结构存储hp, 它的第一个值永远为列表中的最小值： 因此在event中记录的是-h, heap结构就会返回最高的skyline. 同时，h必须在endposition之前， 因为它按照第一个元素排序。 触发event时， 首先要做的就是清除已经到end position的skyline； hp: [h, endposition], 如果当前position大于等于hp中的endposition， 那么该skyline就会被清除掉； 由于在有high skyline的情况下， low skyline不会有影响， 因此， 只需要从高到低的方式清除skyline， 直到剩下一个最高的skyline并且它的end position大于前position 对于高度增加到 h 的时间(neg_h &lt; 0), 我们需要添加一个 skyline, 他将持续到 r 即 endposition 由于 res[-1][1] 记录了在当前事件触发之前一直保持的 skyline 如果当前事件触发后 skyline 发生了改变 来了一条新的高度大于 h 的 skyline res[-1] 中记录的 skyline 到达了 endposition 这两种事件都会导致刚才持续的 skyline 与现在最高的 skyline 不同; 同时, key point 产生了, 他将被记录在 res 中 there is no max heap’s push and pop method, so we can use a min heap hp storing -H as max heap Python Code12345678910111213141516171819class Solution(object): def getSkyline(self, buildings): \"\"\" :type buildings: List[List[int]] :rtype: List[List[int]] \"\"\" events = sorted([(l, -h, r) for l, r, h in buildings] + list(&#123;(r, 0, 0) for l, r, h in buildings&#125;)) res, hp = [[0, 0]], [(0, float('inf'))] for l, neg_h, r in events: while l &gt;= hp[0][1]: heapq.heappop(hp) if neg_h: heapq.heappush(hp, (neg_h, r)) if res[-1][1] != -hp[0][0]: res.append([l, -hp[0][0]]) return res[1:]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"305. Number of Islands II","slug":"305-Number-of-Islands-II","date":"2020-06-23T05:59:43.000Z","updated":"2020-07-16T05:11:27.195Z","comments":true,"path":"2020/06/22/305-Number-of-Islands-II/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/305-Number-of-Islands-II/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839var numIslands2 = function(m, n, positions) &#123; const res = [] const roots = new Array(m*n).fill(-1); const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let cnt = 0; for(let pos of positions) &#123; let id = pos[0] * n + pos[1]; if (roots[id] !== -1) &#123; res.push(cnt); continue; &#125; roots[id] = id; cnt++; for (let dir of dirs) &#123; let x = pos[0] + dir[0], y = pos[1] + dir[1], cur_id = n * x + y; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || roots[cur_id] === -1) continue; let p = findRoot(roots, cur_id), q = findRoot(roots, id) if (p !== q) &#123; roots[p] = q; cnt--; &#125; &#125; res.push(cnt); &#125; return res;&#125;;const findRoot = (roots, id) =&gt; &#123; return (id === roots[id]) ? id : findRoot(roots, roots[id]);&#125; TO speed up add one line to shorten the tree1234567const findRoot = (roots, id) =&gt; &#123; while (id !== roots[id]) &#123; roots[id] = roots[roots[id]] id = roots[id] &#125; return id;&#125; Conclusion For the problem about groups, Union Find is a possible solution Key point of UF: Find the rott Union parent node is the node whose parent is itself","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[{"name":"Union Find","slug":"Union-Find","permalink":"https://jojoyang666.github.io/tags/Union-Find/"}]},{"title":"GIT","slug":"GIT","date":"2020-06-22T22:29:47.000Z","updated":"2020-07-16T20:39:44.479Z","comments":true,"path":"2020/06/22/GIT/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/GIT/","excerpt":"","text":"Stash Git stash: Hide current work Git stash list: View current stash Git stash apply &amp; git stash drop Apply and delete Git stash pop Same as above Git stash apply stash@{0} Select stash Git stash show []: 展示存储单元和最新存储的结果 Git stash show -p []: stash detail Cherry-pick git cherry-pick -n Diff git diff –staged git diff –cached REWRITING GIT HISTORY git commit –amend: Replace the last commit with the staged changes and last commit combined. Use with nothing staged to edit the last commit’s message git commit –amend -m “New commit message”: what the command does is overwriting the most recent commit with the new one `-m’ option allows you to write the new message on the command line without opening an editor session git rebase -i —&gt; 前闭后开 Renamegit branch -m Create New Branchgit checkout -f -B local_TOT remotes/origin/TOT git checkout git checkout -- file git revoke the file in the working space, let it roll back to the latest status git commit/git add git checkout &lt;other branch&gt; -- &lt;file path1&gt; &lt;file path2&gt; copy the file from another branch to current one git log shows the current HEAD and its ancestry prints the commit HEAD points to, then its parent, its parent and so on it tranverse back through the repo’s ancestry, by revursively looking up each commit’s parent git log --oneline --graph --decorategit reflog an ordered list of the commits that HEAD has points to: it’s undo history for your repo Remove files from git commit git reset – soft HEAD^/HEAD~1 git reset HEAD git commit -c ORIG_HEAD Delete branch Delete local branchgit branch -d git branch -D =&gt; -D means force delete","categories":[{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"}],"tags":[{"name":"Source Control","slug":"Source-Control","permalink":"https://jojoyang666.github.io/tags/Source-Control/"}]},{"title":"Shortcut for Iterm2","slug":"Shortcut-for-Iterm2","date":"2020-06-22T21:41:31.000Z","updated":"2020-06-22T22:28:36.513Z","comments":true,"path":"2020/06/22/Shortcut-for-Iterm2/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/Shortcut-for-Iterm2/","excerpt":"","text":"Moving Faster Move to the start of line: Ctrl + A Move to the end of line: Ctrl + E Move forward a word: option + -&gt; Move back a word: option + -&gt; My Favorite Shell Key Combos Delete previous word (in shell): Ctrl + W","categories":[{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://jojoyang666.github.io/categories/cheatsheet/"}],"tags":[{"name":"iterm2","slug":"iterm2","permalink":"https://jojoyang666.github.io/tags/iterm2/"},{"name":"shortcut","slug":"shortcut","permalink":"https://jojoyang666.github.io/tags/shortcut/"}]},{"title":"Regular Expression","slug":"Regular-Expression","date":"2020-06-22T18:46:19.000Z","updated":"2020-06-25T16:51:55.414Z","comments":true,"path":"2020/06/22/Regular-Expression/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/Regular-Expression/","excerpt":"","text":"Character ClassesAssertions^ Matches the beginning of input if the multiline flas is set to true, also mathces immediately after a line break character Like: /^A/ does not match the “A” in “an A”, but does match the first “A” in “An A” Note: This character has a different meaning when it appears at the start of a group Groups and ranges(?:x) Matches “x” but does not remember the match The matched substring cannot be recalled from the resulting array’s element([1], …, [n]) or from the predefined RegExp object’s properties ($1, …, $2) x|y matches either “x” or “y” Quantifiersx? Matches the preceding item “x” 0 or 1 times If used immediately after any of the quantifiers *, +, ?, {} Unicode Property EscapesNote when create the regular expression, it will be global match or not? if it is global, it should add ‘g’; default is not global when create the regular expression, it will be case sensitive or not? it if is case insensitive, it should add ‘i’; defalut is case sensitive","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jojoyang666.github.io/categories/JavaScript/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"}]},{"title":"Flex Box","slug":"flex","date":"2020-06-19T22:39:00.000Z","updated":"2020-06-22T01:36:11.924Z","comments":true,"path":"2020/06/19/flex/","link":"","permalink":"https://jojoyang666.github.io/2020/06/19/flex/","excerpt":"","text":"Properties for the Parent(flex container)two axis cross axis main axis flex-direction the direction of the main axis, thus defining the direction flex items are placed in the flex container row（default）：main-axis is horizontal directions, start point is on the left row-reverse：main-axis is horizontal directions, start point is on the right column：main-axis is vertical directions, start point is on the top column-reverse：main-axis is vertical directions, start point is on the bottom flex-wrap nowrap(default): all flex items will be on the one line wrap: flex items will wrap onto multiple lines from top to bottom wrap-reverse: flex items will wrap onto multiple lines from bottom to top flex-flow flex-direction + flex wrap .containers { flex-flow: column wrap } justify-content define the alignment along the main axis flex-start(default): items are packed toward the start of the flex-direction flex-end: items are packed toward the end of the flex-direction center: items are centered along the line space-between: items are evenly distributed in the line, first item is on the start line, lastitem on the end line space-around: items are evenly distributed in the line with equal space around them, visuallythe spaces are not equal, since all the items have equal space on both side align-items how flex items are laid out along the cross axis on the current line stretch(default): stretch to fill the container(still respect min-width/max-width) flex-start/start/self-start items are placed start of the cross axis the difference between these is subtle, and is about respecting the flex-direction rulesor the writling-mode rules flex-end/end/self-end items are placed at the end of the cross axis the difference between thses is subtle, and is about respecting the flex-direction rulesor the writling-mode rules center items are centered in the cross-axis baseline itmes are aligned such as their baselines align align-content This aligns a flex container’s lines within when there is extra space in the cross-axis this property has no effect when there is only one line of flex items stretch(default): lines stretch to take up the remaining space flex-start/start: items packed to the start of the container flex-start: honors the flex direction start: honors the writing mode direction flex-end/end: items packed to the end of the container flex-end: honors the flex direction end: honors the writing mode direction center: items centered in the container space-around: items evenly distributed with equal space around each line space-between: items evenly distributed the first line is at the start of the container the last on is at the end the main diff between align-items and align-content is the exptra space, there is some extra space inthe align items, however there is no extra space in the align-content(except space-around and spacebetween) Properties for the Children(flex items)order control the order in which they appear in the flex container default is 0 the value is smaller, it will be in the front of the container flex-grow the ability for a flex item to grow if necessary Negative numbers are invalid defalut is 0, which means even there is extra space, it will not grow if all items have flex-glow set to 1, the remaining space in the container will be distributedequally to all children if one of the children has a value of 2, the remaining space would take up twice as much space as the others flex-shrink the ability for a flex item to shrink if necessary Negative numbers are invalid default is 1, if the space is not enough, it will shrink if an item is 0, others are 1, then if the space is not enough, the previous one will not shrink flex-basis: defines the default size of an element before the remaining space is distributed on the main-axis can set to width/height, then the item will have the fixed size default is auto, the original size of the item flex shorthand for flex-grow, flex-shrink and flex-basis, default value is 0 1 auto it is recommended that you use this shorthand property rather than set the individual properties.the shorthand sets the other values intelligiently align-self the default alignment to be overridden for individual flex items default is auto, inferit from the align-items of parent items, if there is no parent, it will be stretch","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"css","slug":"css","permalink":"https://jojoyang666.github.io/tags/css/"}]}],"categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"},{"name":"System Design","slug":"System-Design","permalink":"https://jojoyang666.github.io/categories/System-Design/"},{"name":"Work","slug":"Work","permalink":"https://jojoyang666.github.io/categories/Work/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"Redux","slug":"Front-End/Redux","permalink":"https://jojoyang666.github.io/categories/Front-End/Redux/"},{"name":"GraphQL","slug":"Front-End/GraphQL","permalink":"https://jojoyang666.github.io/categories/Front-End/GraphQL/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"},{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"},{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"},{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://jojoyang666.github.io/categories/cheatsheet/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jojoyang666.github.io/categories/JavaScript/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"Redux","slug":"Redux","permalink":"https://jojoyang666.github.io/tags/Redux/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://jojoyang666.github.io/tags/GraphQL/"},{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://jojoyang666.github.io/tags/LinkedList/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://jojoyang666.github.io/tags/Binary-Indexed-Tree/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://jojoyang666.github.io/tags/Union-Find/"},{"name":"Source Control","slug":"Source-Control","permalink":"https://jojoyang666.github.io/tags/Source-Control/"},{"name":"iterm2","slug":"iterm2","permalink":"https://jojoyang666.github.io/tags/iterm2/"},{"name":"shortcut","slug":"shortcut","permalink":"https://jojoyang666.github.io/tags/shortcut/"},{"name":"css","slug":"css","permalink":"https://jojoyang666.github.io/tags/css/"}]}