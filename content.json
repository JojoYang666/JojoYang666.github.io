{"meta":{"title":"Jojo's Blog","subtitle":"","description":"","author":"Jojo Yang","url":"https://jojoyang666.github.io","root":"/"},"pages":[{"title":"Algorithms","date":"2020-06-23T06:11:50.000Z","updated":"2020-06-23T06:11:50.975Z","comments":true,"path":"Algorithms/index.html","permalink":"https://jojoyang666.github.io/Algorithms/index.html","excerpt":"","text":""},{"title":"Binary Indexed Tree","date":"2020-07-01T18:27:22.000Z","updated":"2020-07-01T18:27:22.044Z","comments":true,"path":"Binary-Indexed-Tree/index.html","permalink":"https://jojoyang666.github.io/Binary-Indexed-Tree/index.html","excerpt":"","text":""},{"title":"JavaScript","date":"2020-06-22T18:47:05.000Z","updated":"2020-06-22T18:47:05.243Z","comments":true,"path":"JavaScript/index.html","permalink":"https://jojoyang666.github.io/JavaScript/index.html","excerpt":"","text":""},{"title":"Leetcode","date":"2020-07-16T05:13:59.000Z","updated":"2020-07-16T05:13:59.728Z","comments":true,"path":"Leetcode/index.html","permalink":"https://jojoyang666.github.io/Leetcode/index.html","excerpt":"","text":""},{"title":"React","date":"2020-06-25T16:52:57.000Z","updated":"2020-06-25T16:52:57.456Z","comments":true,"path":"React/index.html","permalink":"https://jojoyang666.github.io/React/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-22T01:51:07.000Z","updated":"2020-06-22T01:52:06.868Z","comments":true,"path":"categories/index.html","permalink":"https://jojoyang666.github.io/categories/index.html","excerpt":"","text":""},{"title":"python","date":"2020-07-02T19:07:50.000Z","updated":"2020-07-02T19:07:50.445Z","comments":true,"path":"python/index.html","permalink":"https://jojoyang666.github.io/python/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-22T01:50:56.000Z","updated":"2020-06-22T01:51:38.044Z","comments":true,"path":"tags/index.html","permalink":"https://jojoyang666.github.io/tags/index.html","excerpt":"","text":""},{"title":"tools","date":"2020-06-22T22:34:37.000Z","updated":"2020-06-22T22:34:37.999Z","comments":true,"path":"tools/index.html","permalink":"https://jojoyang666.github.io/tools/index.html","excerpt":"","text":""},{"title":"读书","date":"2020-07-20T00:59:21.000Z","updated":"2020-07-20T00:59:21.372Z","comments":true,"path":"读书/index.html","permalink":"https://jojoyang666.github.io/%E8%AF%BB%E4%B9%A6/index.html","excerpt":"","text":""}],"posts":[{"title":"298. Binary Tree Longest Consecutive Sequence","slug":"298-Binary-Tree-Longest-Consecutive-Sequence","date":"2020-08-18T23:11:47.000Z","updated":"2020-08-18T23:45:24.666Z","comments":true,"path":"2020/08/18/298-Binary-Tree-Longest-Consecutive-Sequence/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/298-Binary-Tree-Longest-Consecutive-Sequence/","excerpt":"","text":"Solution 1Recursion one 12345678910111213141516171819202122/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var longestConsecutive = function(root) &#123; return helper(root, null, 0)&#125;;const helper = (root, p, res) =&gt; &#123; if (!root) return res; res = (p &amp;&amp; root.val === p.val + 1) ? res + 1 : 1; return Math.max(res, Math.max(helper(root.left, root, res), helper(root.right, root, res)))&#125; Solution 2Iterative one 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var longestConsecutive = function(root) &#123; if (!root) return 0; let res = 0; const q = [] q.push(root) while (q.length) &#123; let len = 1; let node = q.shift(); while ((node.left &amp;&amp; node.left.val === node.val + 1) || (node.right &amp;&amp; node.right.val === node.val + 1)) &#123; if (node.left &amp;&amp; node.left.val === node.val + 1) &#123; if (node.right) &#123; q.push(node.right) &#125; node = node.left &#125; else if (node.right &amp;&amp; node.right.val === node.val + 1) &#123; if (node.left) &#123; q.push(node.left) &#125; node = node.right &#125; len++; &#125; if (node.left) q.push(node.left) if (node.right) q.push(node.right) res = Math.max(res, len) &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"281. Zigzag Iterator","slug":"281-Zigzag-Iterator","date":"2020-08-18T18:35:40.000Z","updated":"2020-08-18T23:12:59.751Z","comments":true,"path":"2020/08/18/281-Zigzag-Iterator/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/281-Zigzag-Iterator/","excerpt":"","text":"Solution1用i, j的大小关系来判断， 打印哪个数组， diff不能小于1， 到头的话赋最大值 12345678910111213141516171819202122232425262728293031323334353637/** * @constructor * @param &#123;Integer[]&#125; v1 * @param &#123;Integer[]&#125; v1 */var ZigzagIterator = function ZigzagIterator(v1, v2) &#123; this.v = [v1, v2] this.i = 0 this.j = 0&#125;;/** * @this ZigzagIterator * @returns &#123;boolean&#125; */ZigzagIterator.prototype.hasNext = function hasNext() &#123; if (this.i &gt;= this.v[0].length) this.i = Number.MAX_VALUE if (this.j &gt;= this.v[1].length) this.j = Number.MAX_VALUE return this.i &lt; this.v[0].length || this.j &lt; this.v[1].length&#125;;/** * @this ZigzagIterator * @returns &#123;integer&#125; */ZigzagIterator.prototype.next = function next() &#123; return this.i &lt;= this.j ? this.v[0][this.i++] : this.v[1][this.j++]&#125;;/** * Your ZigzagIterator will be called like this: * var i = new ZigzagIterator(v1, v2), a = []; * while (i.hasNext()) a.push(i.next());*/ Solution 2一开始就存入正确的zigzag顺序， 然后进行读取 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @constructor * @param &#123;Integer[]&#125; v1 * @param &#123;Integer[]&#125; v1 */var ZigzagIterator = function ZigzagIterator(v1, v2) &#123; this.v = [] this.n = Math.max(v1.length, v2.length) this.i = 0 for (let i = 0; i &lt; this.n; i++) &#123; if (i &lt; v1.length) this.v.push(v1[i]); if (i &lt; v2.length) this.v.push(v2[i]) &#125; this.n = v1.length + v2.length&#125;;/** * @this ZigzagIterator * @returns &#123;boolean&#125; */ZigzagIterator.prototype.hasNext = function hasNext() &#123; return this.i &lt; this.n&#125;;/** * @this ZigzagIterator * @returns &#123;integer&#125; */ZigzagIterator.prototype.next = function next() &#123; return this.v[this.i++]&#125;;/** * Your ZigzagIterator will be called like this: * var i = new ZigzagIterator(v1, v2), a = []; * while (i.hasNext()) a.push(i.next());*/ Solution 3Follow up using iterator 123456789101112131415161718class ZigzagIterator(object): def __init__(self, v1, v2): self.data = [(len(v), iter(v)) for v in (v1, v2) if v] def next(self): len, iter = self.data.pop(0) if len &gt; 1: self.data.append((len-1, iter)) return next(iter) def hasNext(self): return bool(self.data) # Your ZigzagIterator object will be instantiated and called as such:# i, v = ZigzagIterator(v1, v2), []# while i.hasNext(): v.append(i.next())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"163. Missing Ranges","slug":"163-Missing-Ranges","date":"2020-08-18T17:55:42.000Z","updated":"2020-08-18T17:58:52.480Z","comments":true,"path":"2020/08/18/163-Missing-Ranges/","link":"","permalink":"https://jojoyang666.github.io/2020/08/18/163-Missing-Ranges/","excerpt":"","text":"SolutionCornor Case:整形溢出， 当数组中有整形最大值时， 此时lower更新为num+1时就会溢出， 所以再更新前要判断一下， 若num已经时整形最大值了 直接返回结果 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; lower * @param &#123;number&#125; upper * @return &#123;string[]&#125; */var findMissingRanges = function(nums, lower, upper) &#123; const res = [] for (let num of nums) &#123; if (num &gt; lower) &#123; const suffix = (num-1) &gt; lower ? '-&gt;' + (num-1) : \"\" res.push(`$&#123;lower&#125;$&#123;suffix&#125;`) &#125; if (num === upper) return res; lower = num + 1 &#125; if (lower &lt;= upper) &#123; const suffix = upper &gt; lower ? `-&gt;$&#123;upper&#125;` : \"\" res.push(`$&#123;lower&#125;$&#123;suffix&#125;`) &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1057. Campus Bikes","slug":"1057-Campus-Bikes","date":"2020-08-18T02:55:33.000Z","updated":"2020-08-18T02:56:24.016Z","comments":true,"path":"2020/08/17/1057-Campus-Bikes/","link":"","permalink":"https://jojoyang666.github.io/2020/08/17/1057-Campus-Bikes/","excerpt":"","text":"Solution123456789101112131415161718192021222324class Solution(object): def assignBikes(self, workers, bikes): distances = [] # distances[worker] is tuple of (distance, worker, bike) for each bike for i, (x, y) in enumerate(workers): distances.append([]) for j, (x_b, y_b) in enumerate(bikes): distance = abs(x - x_b) + abs(y - y_b) distances[-1].append((distance, i, j)) distances[-1].sort(reverse = True) # reverse so we can pop the smallest distance result = [None] * len(workers) used_bikes = set() queue = [distances[i].pop() for i in range(len(workers))] # smallest distance for each worker heapq.heapify(queue) while len(used_bikes) &lt; len(workers): _, worker, bike = heapq.heappop(queue) if bike not in used_bikes: result[worker] = bike used_bikes.add(bike) else: heapq.heappush(queue, distances[worker].pop()) # bike used, add next closest bike return result","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Python","slug":"Python","date":"2020-08-18T02:09:04.000Z","updated":"2020-08-18T02:17:05.507Z","comments":true,"path":"2020/08/17/Python/","link":"","permalink":"https://jojoyang666.github.io/2020/08/17/Python/","excerpt":"","text":"Base Data Type heapq heapq.heapify(x): transform list x into a heap, in-place, in linear time. heapq.heappop(heap): pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0] heapq.heappush(heap, item): Push the value item onto the heap, , maintaining the heap invariant","categories":[],"tags":[]},{"title":"97. Interleaving String","slug":"97-Interleaving-String","date":"2020-08-13T05:06:10.000Z","updated":"2020-08-18T02:09:32.131Z","comments":true,"path":"2020/08/12/97-Interleaving-String/","link":"","permalink":"https://jojoyang666.github.io/2020/08/12/97-Interleaving-String/","excerpt":"","text":"Solution 1 只要是遇到字符串的子序列或是匹配问题， 直接上动态规划 Code –&gt; O(m*n)123456789101112131415161718192021222324class Solution(object): def isInterleave(self, s1, s2, s3): \"\"\" :type s1: str :type s2: str :type s3: str :rtype: bool \"\"\" r, c, l = len(s1), len(s2), len(s3) if r + c != l: return False dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)] for i in xrange(1, r+1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in xrange(1, c+1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): for j in xrange(1, c+1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or (dp[i][j-1] and s2[j-1] == s3[i-1+j]) return dp[-1][-1] 1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const len1 = s1.length, len2 = s2.length, len3 = s3.length; if (len1 + len2 !== len3) return false; const dp = [...new Array(len1+1)].map(item =&gt; new Array(len2+1).fill(true)) for (let i = 1; i &lt;= len1; i++) &#123; dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1] === s3[i-1] &#125; for (let i = 1; i &lt;= len2; i++) &#123; dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1] === s3[i-1] &#125; for (let i = 1; i &lt;= len1; i++) &#123; for (let j = 1; j &lt;= len2; j++) &#123; dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1] === s3[i+j-1]) || (dp[i][j-1] &amp;&amp; s2[j-1] === s3[i+j-1]) &#125; &#125; return dp[len1][len2]&#125;; Code –&gt; O(n) space123456789101112def isInterleave3(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [True for _ in xrange(c+1)] for j in xrange(1, c+1): dp[j] = dp[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): dp[0] = (dp[0] and s1[i-1] == s3[i-1]) for j in xrange(1, c+1): dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j]) return dp[-1] Solution DFS Code123456789101112131415class Solution(object): def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False stack, visited = [(0, 0)], set((0, 0)) while stack: x, y = stack.pop() if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: stack.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: stack.append((x, y+1)); visited.add((x, y+1)) return False 12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const l1 = s1.length, l2 = s2.length, l3 = s3.length if (l1 + l2 !== l3) return false; const stack = [[0, 0]], visited = new Set() while (stack.length &gt; 0) &#123; const [x, y] = stack.pop() if (x + y === l3) return true; if (x+1 &lt;= l1 &amp;&amp; s1[x] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x+1&#125;-$&#123;y&#125;`)) &#123; stack.push([x+1, y]); visited.add(`$&#123;x+1&#125;-$&#123;y&#125;`) &#125; if (y+1 &lt;= l2 &amp;&amp; s2[y] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x&#125;-$&#123;y+1&#125;`)) &#123; stack.push([x, y+1]); visited.add(`$&#123;x&#125;-$&#123;y+1&#125;`) &#125; &#125; return false&#125;; Solution BFS123456789101112131415class Solution(object): def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False queue, visited = [(0, 0)], set((0, 0)) while queue: x, y = queue.pop(0) if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: queue.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: queue.append((x, y+1)); visited.add((x, y+1)) return False 12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s1 * @param &#123;string&#125; s2 * @param &#123;string&#125; s3 * @return &#123;boolean&#125; */var isInterleave = function(s1, s2, s3) &#123; const l1 = s1.length, l2 = s2.length, l3 = s3.length if (l1 + l2 !== l3) return false; const stack = [[0, 0]], visited = new Set() while (stack.length &gt; 0) &#123; const [x, y] = stack.shift() if (x + y === l3) return true; if (x+1 &lt;= l1 &amp;&amp; s1[x] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x+1&#125;-$&#123;y&#125;`)) &#123; stack.push([x+1, y]); visited.add(`$&#123;x+1&#125;-$&#123;y&#125;`) &#125; if (y+1 &lt;= l2 &amp;&amp; s2[y] === s3[x+y] &amp;&amp; !visited.has(`$&#123;x&#125;-$&#123;y+1&#125;`)) &#123; stack.push([x, y+1]); visited.add(`$&#123;x&#125;-$&#123;y+1&#125;`) &#125; &#125; return false&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"391. Perfect Rectangle","slug":"391-Perfect-Rectangle","date":"2020-08-11T18:12:17.000Z","updated":"2020-08-13T01:13:24.097Z","comments":true,"path":"2020/08/11/391-Perfect-Rectangle/","link":"","permalink":"https://jojoyang666.github.io/2020/08/11/391-Perfect-Rectangle/","excerpt":"","text":"Solution 1 所有矩形的4个顶点只会有蓝， 绿， 红三种情况 蓝表示该顶点周围没有其他矩形 绿点表示两个矩形并排相邻 红点表示四个矩形相邻 在一个完美矩形中， 蓝色的点只能有四个 矩形的四个顶点： 左下， 左上， 右上， 右下的顺序来给顶点标号为1， 2， 4， 8 —》 考虑二进制表示 当一个点是某一个矩形的左下顶点时，这个点就不能是其他矩形的左下顶点了, 这个条件对于这四种顶点都要成立，那么对于每一个点，如果它是某个矩形的四个顶点之一. 我们记录下来，如果在别的矩形中它又是相同的顶点，那么直接返回false即可 体现了我们标记为1，2，4，8的好处 如果每个点的属性没有冲突， 那么我们来验证每个点的mask是否合理 蓝点：mask的四位只有一个1， 分别就是1(0001), 2(0010), 4(0100), 8(1000) 绿点：mask的四位有两个1, 12(1100), 10(1010), 9(1001), 6(0110), 5(0101), 3(0011)； 红点：mask的四位都是1，只有一种情况15(1111) 判定条件 mask是1， 2， 4， 8的个数， 是否是4个 每个矩形的面积累加和要等于最后的大矩形的面积， 大矩形的面积就是通过计算最小左下点和最大右上点计算得出. 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def isRectangleCover(self, rectangles): def update_counts(x, y, bit): mask, nums = counts[x, y] if mask &amp; bit: return False //因为我们规定了四个左上是1， 右上是2， 左下是4， 右下是8。 所以如果有重叠的话一定返回false（4个角重叠）， 在可以重叠的地方digit 会给合适的值 counts[x, y] = [mask | bit, nums + 1] return True counts, area = collections.defaultdict(lambda: [0, 0]), 0 minx, maxx, miny, maxy = float('inf'), float('-inf'), float('inf'), float('-inf') for blx, bly, trx, _try in rectangles: tlx, tly = blx, _try brx, bry = trx, bly minx, miny, maxx, maxy = min(minx, blx), min(miny, bly), max(maxx, trx), max(maxy, _try) if not update_counts(tlx, tly, 1): return False if not update_counts(trx, _try, 2): return False if not update_counts(blx, bly, 4): return False if not update_counts(brx, bry, 8): return False area += (trx - blx) * (_try - bly) if area != (maxx - minx) * (maxy - miny): return False for x, y in counts: nums = counts[x, y][1] if (x == minx or x == maxx) and (y == miny or y == maxy): if nums != 1: return False else: if nums != 2 and nums != 4: return False return True Solution 2 Base Idea is same with above 所有矩形的4个顶点只会有蓝， 绿， 红三种情况 蓝表示该顶点周围没有其他矩形 绿点表示两个矩形并排相邻 红点表示四个矩形相邻 不用去判断每个点最多只能是一个矩形的左下，左上，右上，或右下顶点 我们直接用一个set，对于遍历到的任意一个顶点 如果set中已经存在了，则删去这个点，如果没有就加上，这样最后会把绿点和红点都滤去 剩下的都是蓝点，我们只要看蓝点的个数是否为四个，再加上检测每个矩形面积累加和要等于最后的大矩形的面积即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @param &#123;number[][]&#125; rectangles * @return &#123;boolean&#125; */var isRectangleCover = function(rectangles) &#123; let minx = Number.POSITIVE_INFINITY, maxx = Number.NEGATIVE_INFINITY, miny = Number.POSITIVE_INFINITY, maxy = Number.NEGATIVE_INFINITY const set = new Set() let area = 0 for (let rect of rectangles) &#123; minx = Math.min(minx, rect[0]) miny = Math.min(rect[1], miny) maxx = Math.max(maxx, rect[2]) maxy = Math.max(maxy, rect[3]) area += (rect[2] - rect[0]) * (rect[3] - rect[1]); let bl = coordinate(rect[0], rect[1]) let tl = coordinate(rect[0], rect[3]) let tr = coordinate(rect[2], rect[3]) let br = coordinate(rect[2], rect[1]) if(set.has(tl)) &#123; set.delete(tl) &#125; else &#123; set.add(tl) &#125; if(set.has(tr)) &#123; set.delete(tr) &#125; else &#123; set.add(tr) &#125; if(set.has(bl)) &#123; set.delete(bl) &#125; else &#123; set.add(bl) &#125; if(set.has(br)) &#123; set.delete(br) &#125; else &#123; set.add(br) &#125; &#125; let t1 = coordinate(minx, miny) let t2 = coordinate(maxx, maxy) let t3 = coordinate(minx, maxy) let t4 = coordinate(maxx, miny) if (!set.has(t1) || !set.has(t2) || !set.has(t3) || !set.has(t4) || set.size !== 4) return false return area === (maxx - minx) * (maxy - miny)&#125;;const coordinate = (x, y) =&gt; `$&#123;x&#125;-$&#123;y&#125;` Solution 3 We keep four sets that collectively act like a difference set – one for each type (direction) of corner.For every corner that we consider, we check to see if another corner has the same coordinates. If a same-position corner of the same type exists, there is an overlap, and we produce an error.If a same-position corner that shares exactly one face exists, we can delete the corner (rectangle merge).If a same-position corner shares the coordinates but neither face, we can add our corner, increasing the number of corners required to clear those coordinates to 2.If no corner is in the same position, we add the corner.After all corners have been considered, we have a rectangle cover if each set contains exactly one corner. 123456789101112131415161718192021222324252627282930let corner = (x, y) =&gt; `$&#123; x &#125; $&#123; y &#125;`let isRectangleCover = rectangles =&gt; &#123; let tls = new Set let trs = new Set let bls = new Set let brs = new Set for (let [l, b, r, t] of rectangles) &#123; let tl = corner(t, l) let tr = corner(t, r) let bl = corner(b, l) let br = corner(b, r) if (tls.has(tl) || trs.has(tr) || bls.has(bl) || brs.has(br)) return false if (!bls.delete(tl) &amp;&amp; !trs.delete(tl)) tls.add(tl) if (!brs.delete(tr) &amp;&amp; !tls.delete(tr)) trs.add(tr) if (!brs.delete(bl) &amp;&amp; !tls.delete(bl)) bls.add(bl) if (!bls.delete(br) &amp;&amp; !trs.delete(br)) brs.add(br) &#125; return tls.size === 1 &amp;&amp; trs.size === 1 &amp;&amp; bls.size === 1 &amp;&amp; brs.size === 1&#125;;if (!bls.delete(tl) &amp;&amp; !trs.delete(tl)) tls.add(tl) ===&gt; if (trs.has(tl)) trs.delete(tl);else if (bls.has(tl)) bls.delete(tl);else tls.add(tl);","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Binary Search","slug":"Binary-Search","date":"2020-08-11T04:26:32.000Z","updated":"2020-08-11T17:01:18.263Z","comments":true,"path":"2020/08/10/Binary-Search/","link":"","permalink":"https://jojoyang666.github.io/2020/08/10/Binary-Search/","excerpt":"","text":"需要找和目标值完全相等的数 code 1234567891011const find = (nums, target) =&gt; &#123; let left = 0, right = nums.length while (left &lt; right) &#123; let mid = left + (right - left)&gt;&gt;1 if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1 else right = mid; &#125; return -1;&#125; 二分查找法的写法并不惟一， 主要可以变动的地方有四处 right初始化， 可以写成nums.length/nums.length - 1 left和right关系， 可以写成left &lt; right / left &lt;= right 更新right的赋值，可以写成 right = mid / right = mid - 1 返回值可以返回left, right, right - 1 但是这些不同的写法并不能随机组合 如果right初始化为nums.length, 那么就必须用left &lt; right, 最后的right赋值必须用right = mid 如果right初始化为nums.length-1, 那么就必须用left &lt;= right, right的赋值写成right=mid-1 查找第一个不小于目标值的数， 可变形为查找最后一个小于目标值的数 Code -&gt; 查找第一个不小于目标的数 12345678910111213const find = (nums, target) =&gt; &#123; let left = 0, right = nums.lenth; while (left &lt; right) &#123; let mid = left + (right - left)&gt;&gt;1 if (nums[mid] &lt; target) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right;&#125; 可以变形为查找最后一个小于目标值的数， 如果已经找到了第一个不小于目标值的数， 那么再往前退一位， 返回right-1， 就是最后一个小于目标值的数 注意nums[mid] &lt; target, 没有等于 查找第一个大于目标值的数， 可变形为查找最后一个不大于目标值的数 code –&gt; 查找第一个大于目标值的数 1234567891011121314const find = (nums, target) =&gt; &#123; let left = 0, right = nums.length; while (left &lt; right) &#123; let mid = left + (right - left) &gt;&gt; 1 if (nums[mid] &lt;= target) &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; return right;&#125; 可变形为查找最后一个不大于目标值的数， 如果已经找到了第一个大于目标值的数， 那么再往前退一位， 返回right - 1, 就是最后一个不大于目标值的数 用子函数当作判断关系因为这里在二分查找法重要的比较大小的地方使用到了子函数， 来确定下一步的搜索范围， 并不是之前三类的数字大小比较 其他（通常target值不固定）比如Find Peak ELement， 求的是数组的局部峰值， 由于求的是峰值， 需要跟相邻的数字比较， 那么target就不是一个固定的值， 而且这道题一定要注意的是right的初始化， 一定要是nums.legth -1. 这是由于算出了mid后， nums[mid]要和nums[mid+1]比较， 如果right初始化为nums.length的话, mid+1可能会越界， 从而不能找到正确的值， 同时while循环的终止条件必须是 left &lt; right， 不能有等号 类似的还有一道 H-Index II，这道题的 target 也不是一个固定值，而是 len-mid，这就很意思了，跟上面的 nums[mid+1] 有异曲同工之妙，target 值都随着 mid 值的变化而变化，这里的right的初始化，一定要是 nums.size() - 1，而 while 循环的终止条件必须是 left &lt;= right，这里又必须要有等号 第四类中虽然是用子函数来判断关系，但大部分时候 mid 也会作为一个参数带入子函数进行计算，这样实际上最终算出的值还是受 mid 的影响，但是 right 却可以初始化为数组长度，循环条件也可以不带等号 https://www.cnblogs.com/grandyang/p/6854825.html","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"1095. Find in Mountain Array","slug":"1095-Find-in-Mountain-Array","date":"2020-08-11T03:28:18.000Z","updated":"2020-08-11T17:01:21.898Z","comments":true,"path":"2020/08/10/1095-Find-in-Mountain-Array/","link":"","permalink":"https://jojoyang666.github.io/2020/08/10/1095-Find-in-Mountain-Array/","excerpt":"","text":"SolutionBinary Search 的判定条件， 不一定还可以和mid附近的值比较 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# \"\"\"# This is MountainArray's API interface.# You should not implement it, or speculate about its implementation# \"\"\"#class MountainArray(object):# def get(self, index):# \"\"\"# :type index: int# :rtype int# \"\"\"## def length(self):# \"\"\"# :rtype int# \"\"\"class Solution(object): def findInMountainArray(self, target, mountain_arr): \"\"\" :type target: integer :type mountain_arr: MountainArray :rtype: integer \"\"\" A = mountain_arr n = A.length() # find index of peak l, r = 0, n - 1 while l &lt; r://不能有等号 m = (l + r)/2 if A.get(m) &lt; A.get(m + 1): l = peak = m + 1 else: r = m # find target in the left of peak l, r = 0, peak while l &lt;= r: m = (l + r) / 2 if A.get(m) &lt; target: l = m + 1 elif A.get(m) &gt; target: r = m - 1 else: return m # find target in the right of peak l, r = peak, n - 1 while l &lt;= r: m = (l + r) / 2 if A.get(m) &gt; target: l = m + 1 elif A.get(m) &lt; target: r = m - 1 else: return m return -1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * // This is the MountainArray's API interface. * // You should not implement it, or speculate about its implementation * function MountainArray() &#123; * @param &#123;number&#125; index * @return &#123;number&#125; * this.get = function(index) &#123; * ... * &#125;; * * @return &#123;number&#125; * this.length = function() &#123; * ... * &#125;; * &#125;; *//** * @param &#123;number&#125; target * @param &#123;MountainArray&#125; mountainArr * @return &#123;number&#125; */var findInMountainArray = function(target, mountainArr) &#123; const n = mountainArr.length() // Find the index of the peak let l = 0, r = n - 1 let peak = 0 while (l &lt; r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) &#123; l = mid + 1 peak = l &#125; else &#123; r = mid &#125; &#125; // Find the target in the left of peak l = 0, r = peak while (l &lt;= r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &lt; target) &#123; l = mid + 1 &#125; else if (mountainArr.get(mid) &gt; target) &#123; r = mid - 1 &#125; else &#123; return mid &#125; &#125; // Find the target in the right of peak l = peak, r = n - 1 while (l &lt;= r) &#123; const mid = (l + r) &gt;&gt; 1 if (mountainArr.get(mid) &gt; target) &#123; l = mid + 1 &#125; else if (mountainArr.get(mid) &lt; target) &#123; r = mid -1 &#125; else &#123; return mid &#125; &#125; return -1&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"681. Next Closest Time","slug":"681-Next-Closest-Time","date":"2020-08-10T05:05:15.000Z","updated":"2020-08-11T03:05:48.114Z","comments":true,"path":"2020/08/09/681-Next-Closest-Time/","link":"","permalink":"https://jojoyang666.github.io/2020/08/09/681-Next-Closest-Time/","excerpt":"","text":"Solution 1 时间模拟， 以当下的0为时间起点， 递增模拟 Code1234567891011121314class Solution(object): def nextClosestTime(self, time): \"\"\" :type time: str :rtype: str \"\"\" cur = 60 * int(time[:2]) + int(time[3:]) allowed = &#123;int(x) for x in time if x != ':'&#125; while True: cur = (cur + 1) % (24*60) if all(digit in allowed for block in divmod(cur, 60) for digit in divmod(block, 10)): return \"&#123;:02d&#125;:&#123;:02d&#125;\".format(*divmod(cur, 60)) 12345678910111213141516171819202122232425/** * @param &#123;string&#125; time * @return &#123;string&#125; */var nextClosestTime = function(time) &#123; let timeBlock = time.split(\":\") cur = parseInt(timeBlock[0]) * 60 + parseInt(timeBlock[1]) allowed = new Set() time.split(\"\").forEach((x) =&gt; &#123; if (x !== ':') &#123; allowed.add(parseInt(x)) &#125; &#125;) while (true) &#123; cur = (cur + 1)%(24*60); const digits = [Math.floor(Math.floor(cur/60)/10), Math.floor(cur/60)%10, Math.floor((cur%60)/10), cur%60%10] const isInAllowed = (digit) =&gt; allowed.has(digit); if (digits.every(isInAllowed))&#123; digits.splice(2, 0, \":\") return digits.join(\"\") &#125; &#125;&#125;; Solution 2 找到所有组合， 转化为分钟， 找到interval最小的 python %n -&gt; 没有负数会自动加上n, 但是JavaScript不一样会有负数12345678910111213141516171819class Solution(object): def nextClosestTime(self, time): \"\"\" :type time: str :rtype: str \"\"\" ans = start = 60 * int(time[:2]) + int(time[3:]) elapsed = 24 * 60 allowed = &#123;int(x) for x in time if x != ':'&#125; for h1, h2, m1, m2 in itertools.product(allowed, repeat = 4): hours, mins = 10 * h1 + h2, 10 * m1 + m2 if hours &lt; 24 and mins &lt; 60: cur = hours * 60 + mins cand_elapsed = (cur - start)%(24 * 60) if 0 &lt; cand_elapsed &lt; elapsed: ans = cur elapsed = cand_elapsed return \"&#123;:02d&#125;:&#123;:02d&#125;\".format(*divmod(ans, 60)) 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;string&#125; time * @return &#123;string&#125; */var nextClosestTime = function(time) &#123; let timeBlock = time.split(\":\") let ans = parseInt(timeBlock[0]) * 60 + parseInt(timeBlock[1]) let elapsed = 24 * 60, start = ans let allowed = new Set() time.split(\"\").forEach((x) =&gt; &#123; if (x !== ':') &#123; allowed.add(parseInt(x)) &#125; &#125;) for (const h1 of allowed) &#123; for (const h2 of allowed) &#123; for (const m1 of allowed) &#123; for (const m2 of allowed) &#123; const hours = 10 * h1 + h2, mins = m1 * 10 + m2 if (hours &lt; 24 &amp;&amp; mins &lt; 60) &#123; let cur = hours * 60 + mins let cand_elapsed = (cur - start + 24 * 60)%(24*60) if (cand_elapsed &lt; elapsed &amp;&amp; cand_elapsed &gt; 0) &#123; elapsed = cand_elapsed ans = cur &#125; &#125; &#125; &#125; &#125; &#125; const hours = Math.floor(ans/60) &gt;= 10 ? Math.floor(ans/60) : `0$&#123;Math.floor(ans/60)&#125;` const mins = ans%60 &gt;= 10 ? ans%60 : `0$&#123;ans%60&#125;` return `$&#123;hours&#125;:$&#123;mins&#125;`&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"284. Peeking Iterator","slug":"284-Peeking-Iterator","date":"2020-08-09T00:05:40.000Z","updated":"2020-08-09T00:07:26.541Z","comments":true,"path":"2020/08/08/284-Peeking-Iterator/","link":"","permalink":"https://jojoyang666.github.io/2020/08/08/284-Peeking-Iterator/","excerpt":"","text":"Solution 设置flag， 这种情况每个section 都要进行检测 这个flag是否符合 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * // This is the Iterator's API interface. * // You should not implement it, or speculate about its implementation. * function Iterator() &#123; * @ return &#123;number&#125; * this.next = function() &#123; // return the next number of the iterator * ... * &#125;; * * @return &#123;boolean&#125; * this.hasNext = function() &#123; // return true if it still has numbers * ... * &#125;; * &#125;; *//** * @param &#123;Iterator&#125; iterator */var PeekingIterator = function(iterator) &#123; this.list = iterator&#125;;/** * @return &#123;number&#125; */PeekingIterator.prototype.peek = function() &#123; if (this.top) &#123; return this.top &#125; if (this.list.hasNext()) &#123; this.top = this.list.next() return this.top &#125; return false&#125;;/** * @return &#123;number&#125; */PeekingIterator.prototype.next = function() &#123; if (this.top) &#123; let v = this.top this.top = null return v; &#125; return this.list.next();&#125;;/** * @return &#123;boolean&#125; */PeekingIterator.prototype.hasNext = function() &#123; if (this.top) &#123; return true; &#125; return this.list.hasNext()&#125;;/** * Your PeekingIterator object will be instantiated and called as such: * var obj = new PeekingIterator(arr) * var param_1 = obj.peek() * var param_2 = obj.next() * var param_3 = obj.hasNext() */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"403. Frog Jump","slug":"403-Frog-Jump","date":"2020-08-08T21:15:00.000Z","updated":"2020-08-08T21:19:33.635Z","comments":true,"path":"2020/08/08/403-Frog-Jump/","link":"","permalink":"https://jojoyang666.github.io/2020/08/08/403-Frog-Jump/","excerpt":"","text":"Solution dp[i] 记录跳到stone i, possible steps code12345678910111213141516171819202122/** * @param &#123;number[]&#125; stones * @return &#123;boolean&#125; */var canCross = function(stones) &#123; const dp = [[0]] for (let i = 1; i &lt; stones.length; i++) &#123; dp[i] = [] for (let j = 0; j &gt; i; j++) &#123; for (let step of dp[j]) &#123; if (Math.abs(stones[j] + step - stones[i]) &lt;= 1) &#123; dp[i].push(stones[i] - stones[j]); break; &#125; &#125; &#125; &#125; return dp[stones.length-1].length &gt; 0;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"1007. Minimum Domino Rotations For Equal Row `","slug":"1007-Minimum-Domino-Rotations-For-Equal-Row","date":"2020-08-04T18:29:23.000Z","updated":"2020-08-08T21:15:41.446Z","comments":true,"path":"2020/08/04/1007-Minimum-Domino-Rotations-For-Equal-Row/","link":"","permalink":"https://jojoyang666.github.io/2020/08/04/1007-Minimum-Domino-Rotations-For-Equal-Row/","excerpt":"","text":"Solution If we take only A[0], the answer wil be wrong for the remaining possible items? In the end, the whole A/B row should be equal to A[0]/B[0], so we could arbitrarily choose A[0]/B[0] as the final target number Code1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[]&#125; A * @param &#123;number[]&#125; B * @return &#123;number&#125; */var minDominoRotations = function(A, B) &#123; const n = A.length let rotations = check(A[0], A, B, n) // If one could make all elements in A or B equal to A[0] if (rotations !== -1 || A[0] === B[0]) return rotations; // If one could make all elements in A or B equal to B[0] else return check(B[0], A, B, n)&#125;;const check = (x, A, B, n) =&gt; &#123; // how many rotations should be done to have all elements in A equal to x and to have all elements in B equal to x let rotations_a = 0, rotations_b = 0 for (let i = 0; i &lt; n; i++) &#123; if (A[i] !== x &amp;&amp; B[i] !== x) &#123; return -1; &#125; else if (A[i] !== x) &#123; rotations_a++; &#125; else if (B[i] !== x) &#123; rotations_b++; &#125; &#125; return Math.min(rotations_b, rotations_a);&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"418. Sentence Screen Fitting","slug":"418-Sentence-Screen-Fitting","date":"2020-08-03T17:52:17.000Z","updated":"2020-08-03T18:54:08.063Z","comments":true,"path":"2020/08/03/418-Sentence-Screen-Fitting/","link":"","permalink":"https://jojoyang666.github.io/2020/08/03/418-Sentence-Screen-Fitting/","excerpt":"","text":"Solution 1 Thinking start is the counter for how many valid characters from _sentence have been put to our screen _sentence[start%length] === &#39; &#39; is the situation that we do not need an extra space for current row. THe current row could be successfully fitted. SO that we need to increase our counter by using start++ think about &quot;abc de f&quot;, when at the space between de and f, you are looking for the position of the first word in the next row, which f and so you move start forward by 1 如果是’ ‘,我们没有算空格那个字符， 因为start%length in _sentence is starting from 0, 所以要加加 Code1234567891011121314151617181920212223242526/** * @param &#123;string[]&#125; sentence * @param &#123;number&#125; rows * @param &#123;number&#125; cols * @return &#123;number&#125; */var wordsTyping = function(sentence, rows, cols) &#123; const _sentence = sentence.join(' ') + ' ' let start = 0; const length = _sentence.length for (let i = 0; i &lt; rows; i++) &#123; start += cols if (_sentence[start%length] === ' ') &#123; start++;//虽然剩余的位置刚好填满了单词， 后面不用再空格了。 但是我们再算有效空位个数的时候还是要加上这个空格的 &#125; else &#123; while (start &gt; 0 &amp;&amp; _sentence[(start-1)%length] !== ' ') &#123; start--; //removimh the extra word from the next word &#125; &#125; &#125; return Math.floor(start/_sentence.length)&#125;; Solution 2 Code123456789101112131415161718192021222324252627282930313233/** * @param &#123;string[]&#125; sentence * @param &#123;number&#125; rows * @param &#123;number&#125; cols * @return &#123;number&#125; */var wordsTyping = function(sentence, rows, cols) &#123; let all = sentence.join(' ') + ' '; let res = 0, idx = 0, n = sentence.length, len = all.length for (let i = 0; i &lt; rows; i++) &#123; let colsRemaining = cols while (colsRemaining &gt; 0) &#123; if (sentence[idx].length &lt;= colsRemaining) &#123; colsRemaining -= sentence[idx].length if (colsRemaining &gt; 0) &#123; colsRemaining -= 1 //miuns the length of space &#125; if (++idx &gt;= n) &#123; res += (1 + Math.floor(colsRemaining / len)) colsRemaining %= len idx = 0 &#125; &#125; else &#123; break; &#125; &#125; &#125; return res&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"361. Bomb Enemy","slug":"361-Bomb-Enemy","date":"2020-07-31T16:04:07.000Z","updated":"2020-08-03T17:53:13.416Z","comments":true,"path":"2020/07/31/361-Bomb-Enemy/","link":"","permalink":"https://jojoyang666.github.io/2020/07/31/361-Bomb-Enemy/","excerpt":"","text":"Solution Thinking rowCnt: record the number of ememies before hiting the next wall colCnt[j]: in the jth col, the number of emeimis before hiting the wall why colCnt would be an array? For each row, we visit each column once. Once we visit second row(and other rows too), we do not want to recompute for colums because we are traversing row wise so value of rowCnt for a row is same throughout for ith row. it is not the case with colums because as we tranverse a particular row our columns keep on changing and also we need to make sure we do not exceed n*m, that is the reasosn for array Code 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;character[][]&#125; grid * @return &#123;number&#125; */var maxKilledEnemies = function(grid) &#123; let m = grid.length, n = m ? grid[0].length : 0 let res = 0, rowCnt = 0, colCnt = new Array(n).fill(0) for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (j === 0 || grid[i][j-1] === 'W') &#123; rowCnt = 0; for (let k = j; k &lt; n &amp;&amp; grid[i][k] != 'W'; k++) &#123; rowCnt += grid[i][k] === 'E' &#125; &#125; if (i === 0 || grid[i-1][j] === 'W') &#123; colCnt[j] = 0; for (let k = i; k &lt; m &amp;&amp; grid[k][j] != 'W'; k++) &#123; colCnt[j] += grid[k][j] === 'E' &#125; &#125; if (grid[i][j] === '0') &#123; res = Math.max(res, rowCnt + colCnt[j]) &#125; &#125; &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"489. Robot Room Cleaner","slug":"489-Robot-Room-Cleaner","date":"2020-07-29T21:48:02.000Z","updated":"2020-07-30T00:22:38.050Z","comments":true,"path":"2020/07/29/489-Robot-Room-Cleaner/","link":"","permalink":"https://jojoyang666.github.io/2020/07/29/489-Robot-Room-Cleaner/","excerpt":"","text":"Solution https://www.youtube.com/watch?v=y4izHfShEfU Backtrack algorithm we do not know where the robot is (the exactly location), thus we give the initial location is (0, 0) then [[-1, 0], [0, 1], [1, 0], [0, -1]] to 4 directions, we have all the point which is relative to the initial position This is the robot, it can only move to one direction(move forward), otherwise it need to turn right/left if the robot arrived a position where it is neighbors all have been vistied, it can not go back to the original position directly(like normal backtrack) Thus, we need to go back following the path how we get here exactly. This is the reason why we need goBack function why we turn the direction in the clock-wise? the robot just one move direction(move forward) –&gt; clock-wise way to guarantee 机器人要移动的方向和转向是一样的 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * // This is the robot's control interface. * // You should not implement it, or speculate about its implementation * function Robot() &#123; * // Returns true if the cell in front is open and robot moves into the cell. * // Returns false if the cell in front is blocked and robot stays in the current cell. * @return &#123;boolean&#125; * this.move = function() &#123; * ... * &#125;; * * // Robot will stay in the same cell after calling turnLeft/turnRight. * // Each turn will be 90 degrees. * @return &#123;void&#125; * this.turnLeft = function() &#123; * ... * &#125;; * * // Robot will stay in the same cell after calling turnLeft/turnRight. * // Each turn will be 90 degrees. * @return &#123;void&#125; * this.turnRight = function() &#123; * ... * &#125;; * * // Clean the current cell. * @return &#123;void&#125; * this.clean = function() &#123; * ... * &#125;; * &#125;; *//** * @param &#123;Robot&#125; robot * @return &#123;void&#125; */var cleanRoom = function(robot) &#123; const visited = new Set(); helper(robot, 0, 0, 0, visited)&#125;;const goback = (robot) =&gt; &#123; robot.turnRight(); robot.turnRight(); robot.move(); robot.turnLeft(); robot.turnLeft();&#125;const helper = (robot, x, y, dir, visited) =&gt; &#123; robot.clean(); visited.add(`$&#123;x&#125;-$&#123;y&#125;`); const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]] for (let i = 0; i &lt; 4; i++) &#123; let cur = (i + dir)%4, newX = x + dirs[cur][0], newY = y + dirs[cur][1]; if (!visited.has(`$&#123;newX&#125;-$&#123;newY&#125;`) &amp;&amp; robot.move()) &#123; helper(robot, newX, newY, cur, visited); goback(robot) &#125; robot.turnRight(); &#125;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"212. Word Search II","slug":"212-Word-Search-II","date":"2020-07-24T13:54:43.000Z","updated":"2020-07-24T14:19:01.029Z","comments":true,"path":"2020/07/24/212-Word-Search-II/","link":"","permalink":"https://jojoyang666.github.io/2020/07/24/212-Word-Search-II/","excerpt":"","text":"Solution Trie Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @param &#123;character[][]&#125; board * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(board, words) &#123; let res = [] const buildTrie = () =&gt; &#123; const root = &#123;&#125; for (let w of words) &#123; let node = root; for (let c of w) &#123; if (!node[c]) &#123; node[c] = &#123;&#125; &#125; node = node[c]; &#125; node.word = w; &#125; return root &#125; const search = (node, i, j) =&gt; &#123; if (node.word) &#123; res.push(node.word) node.word = null; &#125; if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length) return; if (!node[board[i][j]]) return; const c = board[i][j] board[i][j] = '#'; const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]] for (let dir of dirs) &#123; search(node[c], i + dir[0], j + dir[1]); &#125; board[i][j] = c; &#125; const root = buildTrie(); for (let i = 0; i &lt; board.length; i++) &#123; for (let j = 0; j &lt; board[0].length; j++) &#123; search(root, i, j) &#125; &#125; return res;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"295. Find Median from Data Stream","slug":"295-Find-Median-from-Data-Stream","date":"2020-07-23T00:21:33.000Z","updated":"2020-07-23T00:25:40.576Z","comments":true,"path":"2020/07/22/295-Find-Median-from-Data-Stream/","link":"","permalink":"https://jojoyang666.github.io/2020/07/22/295-Find-Median-from-Data-Stream/","excerpt":"","text":"Solution In python, heapq is the min heap, to do the max heap, there is a trick when push the the item, we can push -item, it will logically become the max heap Min Heap: put larger number part –&gt; largeMax Heap: put smaller number part –&gt; small the diff length of two heap must just be 1 code 1234567891011121314151617181920212223242526272829303132333435from heapq import *class MedianFinder(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.heaps = [], [] def addNum(self, num): \"\"\" :type num: int :rtype: None \"\"\" small, large = self.heaps heappush(small, -heappushpop(large, num)) if (len(large) &lt; len(small)): heappush(large, -heappop(small)) def findMedian(self): \"\"\" :rtype: float \"\"\" small, large = self.heaps if len(large) &gt; len(small): return float(large[0]) return (large[0] - small[0]) / 2.0# Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)# param_2 = obj.findMedian()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"123. Best Time to Buy and Sell Stock III","slug":"123-Best-Time-to-Buy-and-Sell-Stock-III","date":"2020-07-22T23:26:01.000Z","updated":"2020-07-22T23:52:03.701Z","comments":true,"path":"2020/07/22/123-Best-Time-to-Buy-and-Sell-Stock-III/","link":"","permalink":"https://jojoyang666.github.io/2020/07/22/123-Best-Time-to-Buy-and-Sell-Stock-III/","excerpt":"","text":"Solution 1 Ideas: two variables for the dp: global one and local one local[i][j]: means when we at the ith day, the maximum profit for having at most j transactions and the last one traction is the ith day global[i][j]: means when we at the ith day, the maximim profit for having at most j transactions local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff) why use max(diff, 0) –&gt; which means buy at ith day and sell at ith day global[i][j] = max(local[i][j], global[i - 1][j]) Code123456789101112131415161718192021/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; if (!prices || !prices.length) return 0; let n = prices.length, g = [...Array(n)].map(() =&gt; new Array(3).fill(0)), l = [...new Array(n)].map(() =&gt; new Array(3).fill(0)); // console.log('g ', g) for (let i = 1; i &lt; prices.length; i++) &#123; let diff = prices[i] - prices[i-1]; for (let j = 1; j &lt;= 2; j++) &#123; l[i][j] = Math.max(g[i-1][j-1] + Math.max(diff, 0), l[i-1][j] + diff); g[i][j] = Math.max(l[i][j], g[i-1][j]) &#125; &#125; return g[n-1][2]&#125;; Solution 2 use one dimensional array rather than two dimensional array, because of overriding problem, need to use j from 2 to 1 Code1234567891011121314151617181920/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; if (!prices || !prices.length) return 0; let g = new Array(3).fill(0), l = new Array(3).fill(0) for (let i = 0; i &lt; prices.length - 1; i++) &#123; let diff = prices[i + 1] - prices[i]; for (let j = 2; j &gt; 0; j--) &#123; l[j] = Math.max(g[j-1] + Math.max(diff, 0), l[j] + diff) g[j] = Math.max(l[j], g[j]) &#125; &#125; return g[2]&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"4. Median of Two Sorted Arrays ","slug":"4-Median-of-Two-Sorted-Arrays","date":"2020-07-21T18:19:08.000Z","updated":"2020-07-21T21:58:04.654Z","comments":true,"path":"2020/07/21/4-Median-of-Two-Sorted-Arrays/","link":"","permalink":"https://jojoyang666.github.io/2020/07/21/4-Median-of-Two-Sorted-Arrays/","excerpt":"","text":"Solution 1 Trick: Find the median in an array, there are two cases – odd and even: number a: (m + 1)/2 number b: (m+2)/2. median is: a + b / 2 ==&gt; in this way: can handle even and odd case together in javascript: if /2, to aviod use Math.floor ==&gt; can use &gt;&gt;. Note: ‘&gt;&gt;’ is lower priority than +/- Idea: Find the kth element in the array Find k/2th in each array, by comparing, do drop some not possible values in the array Recursive function must be aware of the bottom case 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123; let m = nums1.length, n = nums2.length, left = (m + n + 1) &gt;&gt; 1, right = (m + n + 2) &gt;&gt; 1; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right))/2;&#125;;// Find the Kth number in nums1 and nums2const findKth = (nums1, i, nums2, j, k) =&gt; &#123; if (i &gt;= nums1.length) return nums2[j + k - 1]; if (j &gt;= nums2.length) return nums1[i + k - 1]; if (k == 1) return Math.min(nums1[i], nums2[j]); let minVal1 = (i + (k &gt;&gt; 1) - 1 &lt; nums1.length) ? nums1[i + (k &gt;&gt; 1) - 1] : Number.MAX_VALUE; let minVal2 = (j + (k &gt;&gt; 1) - 1 &lt; nums2.length) ? nums2[j + (k &gt;&gt; 1) - 1] : Number.MAX_VALUE; if (minVal1 &lt; minVal2) return findKth(nums1, i + (k &gt;&gt; 1), nums2, j, k - (k &gt;&gt; 1)); else return findKth(nums1, i, nums2, j + (k &gt;&gt; 1), k - (k &gt;&gt; 1)); &#125; Solution 2 Basic thinking: If cut the sorted array to two havles of equal length, then median is the average of max(lower_half) and min(upper_half). i.e. the two numbers immediately next to the cut L, R, N Meaning L: represent the number immediately left to the cut R: the right counterpart N: the length of the array N L = (n-1)/2, R=N/2 Be ready for the two array situation, let’s add imaginary positions(represented as ‘#’)`[6 9 13 18] -&gt; [# 6 # 9 # 13 # 18 #] (N = 4)position index 0 1 2 3 4 5 6 7 8 (N_Position = 9) [6 9 11 13 18]-&gt; [# 6 # 9 # 11 # 13 # 18 #] (N = 5)position index 0 1 2 3 4 5 6 7 8 9 10 (N_Position = 11)` there are always exactly 2*N+1 positions regardeless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2.4. To find the cut position: –&gt; using the binary search among two arrays * there are 2N1 + 2N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut * therefore, whem we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k * when the cuts are made, wh have two L’s and two R’s. They are * L1 = A1[(C1-1)/2]; R1 = A1[C1/2] * L2 = A2[(C2-1)/2]; R2 = A2[C2/2] * Need to make sure if the cut is what we want. Also ecause the A1, A2 are sorted. We can use binary search * we need to make sure * L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2 * because two arrays are sorted L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 * If we have L1 &gt; R2, it means there are too many large numbers on the left half of A1, then we must move C1 to the left(i,e. move the C2 to the right) * If L2 &gt; R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left. Otherwise, this cut is the right one. * After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2;5. https://www.youtube.com/watch?v=LPFhl65R7ww6. https://www.cnblogs.com/grandyang/p/4465932.html7. Code 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123; let m = nums1.length, n = nums2.length if (m &lt; n) return findMedianSortedArrays(nums2, nums1) // make sure the cut2 is the shorter one if (n == 0) return (nums1[(m-1)&gt;&gt;1] + nums1[(m&gt;&gt;1)])/2; let left = 0, right = n * 2; while (left &lt;= right) &#123; let mid2 = (left + right) &gt;&gt; 1 let mid1 = m + n - mid2; let L1 = mid1 === 0 ? Number.NEGATIVE_INFINITY : nums1[(mid1 - 1) &gt;&gt; 1]; let L2 = mid2 === 0 ? Number.NEGATIVE_INFINITY : nums2[(mid2 - 1) &gt;&gt; 1]; let R1 = mid1 === m * 2 ? Number.POSITIVE_INFINITY : nums1[mid1 &gt;&gt; 1]; let R2 = mid2 === n * 2 ? Number.POSITIVE_INFINITY : nums2[mid2 &gt;&gt; 1]; if (L1 &gt; R2) &#123; left = mid2 + 1; &#125; else if (L2 &gt; R1) &#123; right = mid2 - 1; &#125; else &#123; return (Math.max(L1, L2) + Math.min(R1, R2))/2; &#125; &#125; return -1;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"128. Longest Consecutive Sequence","slug":"128-Longest-Consecutive-Sequence","date":"2020-07-16T17:28:43.000Z","updated":"2020-07-16T18:12:42.169Z","comments":true,"path":"2020/07/16/128-Longest-Consecutive-Sequence/","link":"","permalink":"https://jojoyang666.github.io/2020/07/16/128-Longest-Consecutive-Sequence/","excerpt":"","text":"Solution 1 set and pointer Javascript code12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var longestConsecutive = function(nums) &#123; if (!nums || nums.length === 0) return 0; const set = new Set(nums); let res = 0; for (let num of nums) &#123; if (!set.has(num)) continue; set.delete(num); let prev = num - 1, next = num + 1; while (set.has(prev)) set.delete(prev--); while (set.has(next)) set.delete(next++); res = Math.max(res, next - prev - 1); &#125; return res;&#125;; python code1234567891011121314class Solution: def longestConsecutive(self, nums): nums = set(nums) maxlen = 0 while nums: first = last = nums.pop() while first - 1 in nums: first -= 1 nums.remove(first) while last + 1 in nums: last += 1 nums.remove(last) maxlen = max(maxlen, last - first + 1) return maxlen Solution 2 hashmap, only store the sequence length to the boundary points of the sequence code123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var longestConsecutive = function(nums) &#123; let max = 0 const lens = &#123;&#125; for (let n of nums) &#123; if (lens[n] !== undefined) continue; const l = lens[n-1] || 0; const r = lens[n+1] || 0; const len = l + r + 1; lens[n - l] = len; lens[n] = len; lens[n + r] = len; max = Math.max(max, len); &#125; return max;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"LinkedList","slug":"LinkedList","date":"2020-07-16T04:56:04.000Z","updated":"2020-07-16T05:10:29.038Z","comments":true,"path":"2020/07/15/LinkedList/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/LinkedList/","excerpt":"","text":"Conclusion dummy node is very common, especially head dummy Node Reverse LinkedList code:123456789101112// prev is the dummy head, next is nullconst reverseOneGroup = (pre, next) =&gt; &#123; let last = pre.next, cur = last.next; while (cur != next) &#123; last.next = cur.next cur.next = pre.next pre.next = cur cur = last.next &#125; return last&#125; 123456789101112// head is actual head, tail is null in initialconst reverse = (head, tail) =&gt; &#123; let pre = tail while (head != tail) &#123; let t = head.next head.next = pre pre = head head = t &#125; return pre&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[]},{"title":"25. Reverse Nodes in k-Group","slug":"25-Reverse-Nodes-in-k-Group","date":"2020-07-16T04:53:59.000Z","updated":"2020-07-16T05:10:52.902Z","comments":true,"path":"2020/07/15/25-Reverse-Nodes-in-k-Group/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/25-Reverse-Nodes-in-k-Group/","excerpt":"","text":"Solution 1 code123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var reverseKGroup = function(head, k) &#123; if (!head || k == 1) return head let dummy = new ListNode(-1), pre = dummy, cur = head; dummy.next = head; for (let i = 1; cur; i++) &#123; if (i%k === 0) &#123; pre = reverseOneGroup(pre, cur.next) cur = pre.next &#125; else &#123; cur = cur.next &#125; &#125; return dummy.next&#125;;const reverseOneGroup = (pre, next) =&gt; &#123; let last = pre.next, cur = last.next; while (cur != next) &#123; last.next = cur.next cur.next = pre.next pre.next = cur cur = last.next &#125; return last&#125; Solution 2123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var reverseKGroup = function(head, k) &#123; let cur = head for (let i = 0; i &lt; k; i++) &#123; if (!cur) return head; cur = cur.next &#125; let new_head = reverse(head, cur) head.next = reverseKGroup(cur, k) return new_head&#125;;const reverse = (head, tail) =&gt; &#123; let pre = tail while (head != tail) &#123; let t = head.next head.next = pre pre = head head = t &#125; return pre&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"https://jojoyang666.github.io/tags/LinkedList/"}]},{"title":"381. Insert Delete GetRandom O(1) - Duplicates allowed","slug":"381-Insert-Delete-GetRandom-O-1-Duplicates-allowed","date":"2020-07-15T20:42:55.000Z","updated":"2020-07-16T05:11:56.276Z","comments":true,"path":"2020/07/15/381-Insert-Delete-GetRandom-O-1-Duplicates-allowed/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/381-Insert-Delete-GetRandom-O-1-Duplicates-allowed/","excerpt":"","text":"Solution 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Initialize your data structure here. */var RandomizedCollection = function() &#123; this.map = &#123;&#125; // val: [idx1, idx2] this.array = [] // [[val, 0], [val, 1]...], the seconde element in the array represents the idx of this value in the value of map&#125;;/** * Inserts a value to the collection. Returns true if the collection did not already contain the specified element. * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedCollection.prototype.insert = function(val) &#123; let res = true if (this.map[val] !== undefined) res = false this.map[val] = this.map[val] || [] this.map[val].push(this.array.length) this.array.push([val, this.map[val].length-1]); return res;&#125;;/** * Removes a value from the collection. Returns true if the collection contained the specified element. * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedCollection.prototype.remove = function(val) &#123; if (this.map[val] === undefined) return false; let valIdx = this.map[val].pop(); if (!this.map[val].length) delete this.map[val]; let lastIdx = this.array.length - 1 if (valIdx === lastIdx) &#123; this.array.pop(); &#125; else &#123; [this.array[valIdx], this.array[lastIdx]] = [this.array[lastIdx], this.array[valIdx]] this.array.pop(); let [key, idx] = this.array[valIdx] this.map[key][idx] = valIdx; &#125; return true;&#125;;/** * Get a random element from the collection. * @return &#123;number&#125; */RandomizedCollection.prototype.getRandom = function() &#123; return this.array[Math.floor(Math.random() * this.array.length)][0];&#125;;/** * Your RandomizedCollection object will be instantiated and called as such: * var obj = new RandomizedCollection() * var param_1 = obj.insert(val) * var param_2 = obj.remove(val) * var param_3 = obj.getRandom() */ Solution 2:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import randomclass RandomizedCollection(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.vals, self.idxs = [], collections.defaultdict(set) def insert(self, val): \"\"\" Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool \"\"\" self.vals.append(val) self.idxs[val].add(len(self.vals)-1) return len(self.idxs[val]) == 1 // check brillent def remove(self, val): \"\"\" Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool \"\"\" if self.idxs[val]: out, ins = self.idxs[val].pop(), self.vals[-1] self.vals[out] = ins self.idxs[ins].add(out) self.idxs[ins].discard(len(self.vals)-1) self.vals.pop() return True return False def getRandom(self): \"\"\" Get a random element from the collection. :rtype: int \"\"\" return random.choice(self.vals)# Your RandomizedCollection object will be instantiated and called as such:# obj = RandomizedCollection()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"432. All Oone Data Structure","slug":"432-All-Oone-Data-Structure","date":"2020-07-15T19:09:14.000Z","updated":"2020-07-16T05:12:07.709Z","comments":true,"path":"2020/07/15/432-All-Oone-Data-Structure/","link":"","permalink":"https://jojoyang666.github.io/2020/07/15/432-All-Oone-Data-Structure/","excerpt":"","text":"Solution class Node: key_set: is set of key. In current scenario, all key with the same frequency prev node next node class DoubleLinkedList head_node tail_node item is Node, this class is a link list of Node class AllOne dll is a DoubleLinkedList -&gt; node store set of key key_counter is a dict -&gt; key is key, value is how many times this key appear node_freq is a dict -&gt; key is how many times a key appear, value is the node Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132from collections import defaultdictclass Node(object): def __init__(self): self.key_set = set([]) self.prev, self.next = None, None def add_key(self, key): self.key_set.add(key) def remove_key(self, key): self.key_set.remove(key) def get_any_key(self): if self.key_set: result = self.key_set.pop() self.add_key(result) return result else: return None def count(self): return len(self.key_set) def is_empty(self): return self.count() == 0 class DoubleLinkedList(object): def __init__(self): self.head_node, self.tail_node = Node(), Node() self.head_node.next, self.tail_node.prev = self.tail_node, self.head_node def insert_after(self, x): node, temp = Node(), x.next x.next, node.prev = node, x node.next, temp.prev = temp, node return node def insert_before(self, x): return self.insert_after(x.prev) def remove(self, x): prev_node = x.prev prev_node.next, x.next.prev = x.next, prev_node def get_head(self): return self.head_node.next def get_tail(self): return self.tail_node.prev def get_sentinel_head(self): return self.head_node def get_sentinel_tail(self): return self.tail_node class AllOne(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int) self.node_freq = &#123;0: self.dll.get_sentinel_head()&#125; def _rmv_key_pf_node(self, pf, key): node = self.node_freq[pf] node.remove_key(key) if node.is_empty(): self.dll.remove(node) self.node_freq.pop(pf) return def inc(self, key): \"\"\" Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. :type key: str :rtype: None \"\"\" self.key_counter[key] += 1 cf, pf = self.key_counter[key], self.key_counter[key]-1 if cf not in self.node_freq: self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf]) self.node_freq[cf].add_key(key) if pf &gt; 0: self._rmv_key_pf_node(pf, key) def dec(self, key): \"\"\" Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. :type key: str :rtype: None \"\"\" if key in self.key_counter: self.key_counter[key] -= 1 cf, pf = self.key_counter[key], self.key_counter[key] + 1 if self.key_counter[key] == 0: self.key_counter.pop(key) if cf != 0: if cf not in self.node_freq: self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf]) self.node_freq[cf].add_key(key) self._rmv_key_pf_node(pf, key) def getMaxKey(self): \"\"\" Returns one of the keys with maximal value. :rtype: str \"\"\" return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() &gt; 0 else \"\" def getMinKey(self): \"\"\" Returns one of the keys with Minimal value. :rtype: str \"\"\" return self.dll.get_head().get_any_key() if self.dll.get_head().count() &gt; 0 else \"\" # Your AllOne object will be instantiated and called as such:# obj = AllOne()# obj.inc(key)# obj.dec(key)# param_3 = obj.getMaxKey()# param_4 = obj.getMinKey()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"python-basic-syntax","slug":"python-basic-syntax","date":"2020-07-02T19:07:39.000Z","updated":"2020-07-02T19:30:44.985Z","comments":true,"path":"2020/07/02/python-basic-syntax/","link":"","permalink":"https://jojoyang666.github.io/2020/07/02/python-basic-syntax/","excerpt":"","text":"from import and import Util.py 12345def lookNum(): print(\"I am number\") def lookStr(): print(\"I am string\") Teacher.py 1234567class Teacher: def check(self): return 'I am teacher'; class Order: def checkOrder(self): return 'I am order'; Student.py 123456789101112from Teacher import *import Utilclass Student: def login(self): str = Teacher.check(self) order = Order.checkOrder(self) Util.lookNum() Util.lookStr() print(str+'login success'+order) s = Student()s.login() Conclusion when we import a class, we must use from &lt;..&gt; import &lt;..&gt; if we write multiple classes in a file, we can use from Teacher import * import all if we just want to import one class from a file, we need to deicate the name of class. For example: from Teacher import Order If the file has some methods rather than a class file, can use import &lt;name of file&gt; directly, which means import all the methods from the file. For example: import Util, when want to use the specific method –&gt; Util.lookNum() if want to just import one method, from Util import lookNum, use it –&gt; lookNum()","categories":[{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"}],"tags":[]},{"title":"307. Range Sum Query - Mutable","slug":"307-Range-Sum-Query-Mutable","date":"2020-07-01T18:22:45.000Z","updated":"2020-07-16T05:11:38.034Z","comments":true,"path":"2020/07/01/307-Range-Sum-Query-Mutable/","link":"","permalink":"https://jojoyang666.github.io/2020/07/01/307-Range-Sum-Query-Mutable/","excerpt":"","text":"Solution1 Binary Indexed Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;number[]&#125; nums */var NumArray = function(nums) &#123; this.bitArray = new Array(nums.length + 1); this.nums = nums for (let i = 0; i &lt; nums.length; i++) &#123; this.bitArray[i+1] = nums[i] &#125; for (let i = 1; i &lt; this.bitArray.length; i++) &#123; let j = i + (i&amp;-i) if (j &lt; this.bitArray.length) &#123; this.bitArray[j] += this.bitArray[i] &#125; &#125;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; val * @return &#123;void&#125; */NumArray.prototype.update = function(i, val) &#123; let idx = i + 1 let delta = val - this.nums[i] while (idx &lt; this.bitArray.length) &#123; this.bitArray[idx] += delta idx = idx + (idx &amp; -idx) &#125; this.nums[i] = val;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; j * @return &#123;number&#125; */NumArray.prototype.sumRange = function(i, j) &#123; const prefixSum = (idx) =&gt; &#123; idx += 1 let result = 0; while (idx &gt; 0) &#123; result += this.bitArray[idx] idx = idx - (idx &amp; -idx) &#125; return result; &#125; return prefixSum(j) - prefixSum(i-1);&#125;;/** * Your NumArray object will be instantiated and called as such: * var obj = new NumArray(nums) * obj.update(i,val) * var param_2 = obj.sumRange(i,j) */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","date":"2020-06-30T23:47:14.000Z","updated":"2020-07-01T18:26:03.531Z","comments":true,"path":"2020/06/30/Binary-Indexed-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/06/30/Binary-Indexed-Tree/","excerpt":"","text":"Definition A data structure that can efficiently update element and calculate prefix sums in a table of numbers It can solve the problems below efficiently update(idx, delta): add num at the number which at position idx prefixSum(idx): get the sum of numbers which start from position 1 to idx(include idx) rangeSum(from_idx, to_idx): get the sum of all the numbers which is from from_idx to to_idx Thoughts about Construction Binary Indexed Tree store the element in a logical way according to the binary of number Sum in the Binary Indexed Tree: Given the position i(we want to get the sum from position 1 to i), like 13 13 = 2^3 + 2^2 + 2^0 =&gt; prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13) Note: RANGE(x, y) represent the sum of array starting from postion x to postion y First level, fill from the first number in the array. length is the sum of 2^m(m is from 0 to infinite) numbersfor example 2^0, 2^1, 2^2, 2^3. stop here because 2^4 exceeds the length of array Second level. fill from 3(the first hole). length is the sum of 2^m(m is from 0 to infinite) numbers — always start from hole, to the end of array Third level is same as previous one contruct a binary indexed array, we call it BIT, for our coonvience, we index it starting from 1 prefixSum(13) = prefixSum(0b0001101) = BIT[13] + BIT[12] + BIT[8] This is how tree looks like: How to get prefix sum or range sumWay to find the parent node of current node Observation From BelowprefixSum(13) = prefixSum(0b0001101)= BIT[13] + BIT[12] + BIT[8]= BIT[0b00001101] + BIT[0b00001100] + BIT[0b00001000] Move from bottom to Up, actually is a process to flip last digit 1 to 0, for example x = 13 x = 13 = 0b00001101 -x = -13 = 0b11110011 x &amp; (-x) = 0b00000001 x - (x &amp; (-x)) = 0b00001100 Update elment in the array For example, update(5,2), we want to add 2 to the number at postion 5, the process of it would like: we can see that, the postition needed to update is the binary of original position plus 1 to the last 1 in the binary representation, for example x = 5 x = 5 = 0b00000101 -x = -5 = 0b11111011 x &amp; (-x) = 0b00000001 x + (x &amp; (-x)) = 0b00000110 Construction of Binary Indexed TreeMethod 1 Iinite an array with all 0, Do the update(i, delta) for every item –&gt; O(nlgn) Method 2Input is an array list with length n Initianize an array bit with length n+1 Put the numbers of list to bit array from position 1 to n for index i from 1 to n j = i + (i &amp; -i)，if j &lt; n + 1，then bit[j] = bit[j] + bit[i] Conclusion 如何确定某个位置到底是有几个数组成的呢 原来是根据坐标的最低位 Low Bit 来决定的，所谓的最低位，就是二进制数的最右边的一个1开始，加上后面的0(如果有的话)组成的数字 Notes (i &amp; -i): trick to extract the lowest set bit of i Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243public class BinaryIndexedTree &#123; private int[] bitArr; public BinaryIndexedTree(int[] list) &#123; // log(n) this.bitArr = new int[list.length + 1]; for (int i = 0; i &lt; list.length; i++) &#123; this.bitArr[i + 1] = list[i]; &#125; for (int i = 1; i &lt; this.bitArr.length; i++) &#123; let j = i + (i &amp; -i); if (j &lt; this.bitArr.length) &#123; this.bitArr[j] += this.bitArr[i] &#125; &#125; &#125; public void update(int idx, int delta) &#123; idx += 1 while (idx &lt; this.bitArr.length) &#123; this.bitArr[idx] += delta idx = idx + (idx &amp; -idx) &#125; &#125; public int prefixSum(int idx) &#123; idx += 1 int result = 0 while (idx &gt; 0) &#123; result += this.bitArr[idx] idx = idx - (idx &amp; -idx) &#125; return result &#125; public int rangeSum(int from_idx, int to_idx)&#123; return prefixSum(to_idx) - prefixSum(from_idx-1) &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://jojoyang666.github.io/tags/Binary-Indexed-Tree/"}]},{"title":"React LifeCycle","slug":"React-LifeCycle","date":"2020-06-25T16:51:13.000Z","updated":"2020-06-25T17:56:12.957Z","comments":true,"path":"2020/06/25/React-LifeCycle/","link":"","permalink":"https://jojoyang666.github.io/2020/06/25/React-LifeCycle/","excerpt":"","text":"Lifecycle Diagram UpdatingcomponentDidUpdate invoked immediately after updating occurs, is not called for the initial render A good place to do network requests as long as you compare the current props to previous props(e.g. a network request may not be necessary if the props have not changed) May call setState() immediately in componentDidUpdate(), but nore that it must be wrapped in a condition, otherwise will cause a infinite loop If try to “mirror” some state to a prop coming from above, consider using the prop directly instead shouldComponentUpdate Let react know if a component’s output is not affected by the current change in state or props Default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior Invoked before rendering when new props or state are being received. Defaults to true Exists as a performance optimization, do not rely on it to “prevent” a rendering, as this can lead bugs If want to prevent a rendering, can use PureComponent PureComponent performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped Noted that returning false does not prevent child components from rerendering when their states changes Not recommend doing deap equality checks or using JSON.stringify() in shouldComponentUpdate(), it is every inefficient and will harm the performanced React.PureComponent similar to React.Component. The difference between them is: React.Component does not implement shouldComponentUpdate() React.PureComponent implements it with a shallow prop and state comparison React.PureComponent’s shouldComponentUpdate only shallowly compares the object if contains complex data structer, may introduce false-negative for deeper diff React.PureComponent’s shouldComponentUpdate skips prop updates for the whole component subtree Make sure all the children components are also pure","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"}]},{"title":"308. Range Sum Query 2D - Mutable","slug":"308-Range-Sum-Query-2D-Mutable","date":"2020-06-24T18:27:47.000Z","updated":"2020-07-16T05:11:42.444Z","comments":true,"path":"2020/06/24/308-Range-Sum-Query-2D-Mutable/","link":"","permalink":"https://jojoyang666.github.io/2020/06/24/308-Range-Sum-Query-2D-Mutable/","excerpt":"","text":"Solution I 建立列之和的矩阵： 就是(i, j)就是(0, j) + (1, j) + … + (i, j) 之和 相当于把多个一维的区间之和拼到了一起， 所以在构造函数中需要建立起这样一个列之和的矩阵， 然后在更新某一个位置时， 我们只需要将该列中改变的位置下面的所有数字更新一下即可 求某个区间的和时， 只要将相差的各列中对应的起始和结束的行上的差值累加起来即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @param &#123;number[][]&#125; matrix */var NumMatrix = function(matrix) &#123; if (!matrix.length || !matrix[0].length) &#123; return; &#125; this.matrix = matrix this.colSum = [...new Array(matrix.length + 1)].map(item =&gt; new Array(matrix[0].length).fill(0)); for (let i = 1; i &lt; this.colSum.length; i++) &#123; for (let j = 0; j &lt; this.colSum[0].length; j++) &#123; this.colSum[i][j] = this.colSum[i-1][j] + this.matrix[i-1][j]; &#125; &#125;&#125;;/** * @param &#123;number&#125; row * @param &#123;number&#125; col * @param &#123;number&#125; val * @return &#123;void&#125; */NumMatrix.prototype.update = function(row, col, val) &#123; for (let i = row + 1; i &lt; this.colSum.length; i++) &#123; this.colSum[i][col] += val - this.matrix[row][col] &#125; this.matrix[row][col] = val&#125;;/** * @param &#123;number&#125; row1 * @param &#123;number&#125; col1 * @param &#123;number&#125; row2 * @param &#123;number&#125; col2 * @return &#123;number&#125; */NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) &#123; let res = 0; for (let j = col1; j &lt;= col2; j++) &#123; res += this.colSum[row2+1][j] - this.colSum[row1][j]; &#125; return res&#125;;/** * Your NumMatrix object will be instantiated and called as such: * var obj = new NumMatrix(matrix) * obj.update(row,col,val) * var param_2 = obj.sumRegion(row1,col1,row2,col2) */ Solution II","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"Docker","slug":"Docker","date":"2020-06-23T18:09:23.000Z","updated":"2020-06-23T18:20:38.418Z","comments":true,"path":"2020/06/23/Docker/","link":"","permalink":"https://jojoyang666.github.io/2020/06/23/Docker/","excerpt":"","text":"Load docker load &lt; ***.tar.gz —&gt; load images from .tar.gz docker tag ** ***","categories":[{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"}],"tags":[]},{"title":"218. The Skyline Problem","slug":"218-The-Skyline-Problem","date":"2020-06-23T16:56:50.000Z","updated":"2020-07-16T05:11:09.755Z","comments":true,"path":"2020/06/23/218-The-Skyline-Problem/","link":"","permalink":"https://jojoyang666.github.io/2020/06/23/218-The-Skyline-Problem/","excerpt":"","text":"SolutionJSBasic Ideas for JS Treat all left, right positions as the candidate x-positions For each candidate x-position, find out it’s y-position by search for the highest height on top of that position Determine if it’s necessary to record the position by comparing the height with the previous height there is no heap in JS JS Code1234567891011121314151617181920212223242526272829303132var getSkyline = function(buildings) &#123; let cp = new Set(); for (let [l, r, h] of buildings) &#123; cp.add(l); cp.add(r); &#125; let cp1 = [...cp], n = buildings.length; cp1.sort((a, b) =&gt; Number.parseInt(a) - Number.parseInt(b)); let res = [[-1, 0]] for (let p of cp1) &#123; let i = 0, height = 0; while (i &lt; n &amp;&amp; buildings[i][0] &lt;= p) &#123; if (buildings[i][1] &gt; p) &#123; height = Math.max(height, buildings[i][2]); &#125; i++; &#125; if (res[res.length-1][1] === height) &#123; continue; &#125; res.push([p, height]); &#125; return res.slice(1);&#125;; PythonBasic Ideas for Python 对于一个building， 他由(l, r, h)三元组组成， 我们可以将其分解成两种事件 在 left position, 高度从0增加到h（并且这个高度将持续到right position） 在 right position, 高度从h降低到0 引入了一个event结构: 在某一个position p, 他引入了一个高度为h的skyline， 将一直持续到另一个end position 对于right position高度降为0的event， 它的持续长度是无效的 只保留一个right position event， 就可以同时触发不同的两个building， 在同一right position从各自的h降为0的event， 所以对right position events做集合操作会减少计算量 由于需要从左到右触发event， 所以按position对events排序，并且对于同一position， 我们需要先触发更高的h事件， 那么高的h相比于低的h会占据更高的skyline, 低h的 key point就一定不会产生； 相反， 可能会从低到高连续产生冗余的 key point, 所以event不仅需要按第一个元素position排序， 在position相同时， 第二个元素h也必须是有序的 hp记录了对于一条高为h的skyline，他将持续到什么position才结束: [h, endposition], 在同时有多条skyline的时候, h最高的那条skyline会掩盖掉h低的skyline， 因此在event出发时， 需要得到当前最高的skyline; 所以利用heap结构存储hp, 它的第一个值永远为列表中的最小值： 因此在event中记录的是-h, heap结构就会返回最高的skyline. 同时，h必须在endposition之前， 因为它按照第一个元素排序。 触发event时， 首先要做的就是清除已经到end position的skyline； hp: [h, endposition], 如果当前position大于等于hp中的endposition， 那么该skyline就会被清除掉； 由于在有high skyline的情况下， low skyline不会有影响， 因此， 只需要从高到低的方式清除skyline， 直到剩下一个最高的skyline并且它的end position大于前position 对于高度增加到 h 的时间(neg_h &lt; 0), 我们需要添加一个 skyline, 他将持续到 r 即 endposition 由于 res[-1][1] 记录了在当前事件触发之前一直保持的 skyline 如果当前事件触发后 skyline 发生了改变 来了一条新的高度大于 h 的 skyline res[-1] 中记录的 skyline 到达了 endposition 这两种事件都会导致刚才持续的 skyline 与现在最高的 skyline 不同; 同时, key point 产生了, 他将被记录在 res 中 there is no max heap’s push and pop method, so we can use a min heap hp storing -H as max heap Python Code12345678910111213141516171819class Solution(object): def getSkyline(self, buildings): \"\"\" :type buildings: List[List[int]] :rtype: List[List[int]] \"\"\" events = sorted([(l, -h, r) for l, r, h in buildings] + list(&#123;(r, 0, 0) for l, r, h in buildings&#125;)) res, hp = [[0, 0]], [(0, float('inf'))] for l, neg_h, r in events: while l &gt;= hp[0][1]: heapq.heappop(hp) if neg_h: heapq.heappush(hp, (neg_h, r)) if res[-1][1] != -hp[0][0]: res.append([l, -hp[0][0]]) return res[1:]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[]},{"title":"305. Number of Islands II","slug":"305-Number-of-Islands-II","date":"2020-06-23T05:59:43.000Z","updated":"2020-07-16T05:11:27.195Z","comments":true,"path":"2020/06/22/305-Number-of-Islands-II/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/305-Number-of-Islands-II/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839var numIslands2 = function(m, n, positions) &#123; const res = [] const roots = new Array(m*n).fill(-1); const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let cnt = 0; for(let pos of positions) &#123; let id = pos[0] * n + pos[1]; if (roots[id] !== -1) &#123; res.push(cnt); continue; &#125; roots[id] = id; cnt++; for (let dir of dirs) &#123; let x = pos[0] + dir[0], y = pos[1] + dir[1], cur_id = n * x + y; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || roots[cur_id] === -1) continue; let p = findRoot(roots, cur_id), q = findRoot(roots, id) if (p !== q) &#123; roots[p] = q; cnt--; &#125; &#125; res.push(cnt); &#125; return res;&#125;;const findRoot = (roots, id) =&gt; &#123; return (id === roots[id]) ? id : findRoot(roots, roots[id]);&#125; TO speed up add one line to shorten the tree1234567const findRoot = (roots, id) =&gt; &#123; while (id !== roots[id]) &#123; roots[id] = roots[roots[id]] id = roots[id] &#125; return id;&#125; Conclusion For the problem about groups, Union Find is a possible solution Key point of UF: Find the rott Union parent node is the node whose parent is itself","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"}],"tags":[{"name":"Union Find","slug":"Union-Find","permalink":"https://jojoyang666.github.io/tags/Union-Find/"}]},{"title":"GIT","slug":"GIT","date":"2020-06-22T22:29:47.000Z","updated":"2020-07-16T20:39:44.479Z","comments":true,"path":"2020/06/22/GIT/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/GIT/","excerpt":"","text":"Stash Git stash: Hide current work Git stash list: View current stash Git stash apply &amp; git stash drop Apply and delete Git stash pop Same as above Git stash apply stash@{0} Select stash Git stash show []: 展示存储单元和最新存储的结果 Git stash show -p []: stash detail Cherry-pick git cherry-pick -n Diff git diff –staged git diff –cached REWRITING GIT HISTORY git commit –amend: Replace the last commit with the staged changes and last commit combined. Use with nothing staged to edit the last commit’s message git commit –amend -m “New commit message”: what the command does is overwriting the most recent commit with the new one `-m’ option allows you to write the new message on the command line without opening an editor session git rebase -i —&gt; 前闭后开 Renamegit branch -m Create New Branchgit checkout -f -B local_TOT remotes/origin/TOT git checkout git checkout -- file git revoke the file in the working space, let it roll back to the latest status git commit/git add git checkout &lt;other branch&gt; -- &lt;file path1&gt; &lt;file path2&gt; copy the file from another branch to current one git log shows the current HEAD and its ancestry prints the commit HEAD points to, then its parent, its parent and so on it tranverse back through the repo’s ancestry, by revursively looking up each commit’s parent git log --oneline --graph --decorategit reflog an ordered list of the commits that HEAD has points to: it’s undo history for your repo Remove files from git commit git reset – soft HEAD^/HEAD~1 git reset HEAD git commit -c ORIG_HEAD Delete branch Delete local branchgit branch -d git branch -D =&gt; -D means force delete","categories":[{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"}],"tags":[{"name":"Source Control","slug":"Source-Control","permalink":"https://jojoyang666.github.io/tags/Source-Control/"}]},{"title":"Shortcut for Iterm2","slug":"Shortcut-for-Iterm2","date":"2020-06-22T21:41:31.000Z","updated":"2020-06-22T22:28:36.513Z","comments":true,"path":"2020/06/22/Shortcut-for-Iterm2/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/Shortcut-for-Iterm2/","excerpt":"","text":"Moving Faster Move to the start of line: Ctrl + A Move to the end of line: Ctrl + E Move forward a word: option + -&gt; Move back a word: option + -&gt; My Favorite Shell Key Combos Delete previous word (in shell): Ctrl + W","categories":[{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://jojoyang666.github.io/categories/cheatsheet/"}],"tags":[{"name":"iterm2","slug":"iterm2","permalink":"https://jojoyang666.github.io/tags/iterm2/"},{"name":"shortcut","slug":"shortcut","permalink":"https://jojoyang666.github.io/tags/shortcut/"}]},{"title":"Regular Expression","slug":"Regular-Expression","date":"2020-06-22T18:46:19.000Z","updated":"2020-06-25T16:51:55.414Z","comments":true,"path":"2020/06/22/Regular-Expression/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/Regular-Expression/","excerpt":"","text":"Character ClassesAssertions^ Matches the beginning of input if the multiline flas is set to true, also mathces immediately after a line break character Like: /^A/ does not match the “A” in “an A”, but does match the first “A” in “An A” Note: This character has a different meaning when it appears at the start of a group Groups and ranges(?:x) Matches “x” but does not remember the match The matched substring cannot be recalled from the resulting array’s element([1], …, [n]) or from the predefined RegExp object’s properties ($1, …, $2) x|y matches either “x” or “y” Quantifiersx? Matches the preceding item “x” 0 or 1 times If used immediately after any of the quantifiers *, +, ?, {} Unicode Property EscapesNote when create the regular expression, it will be global match or not? if it is global, it should add ‘g’; default is not global when create the regular expression, it will be case sensitive or not? it if is case insensitive, it should add ‘i’; defalut is case sensitive","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jojoyang666.github.io/categories/JavaScript/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"}]},{"title":"Flex Box","slug":"flex","date":"2020-06-19T22:39:00.000Z","updated":"2020-06-22T01:36:11.924Z","comments":true,"path":"2020/06/19/flex/","link":"","permalink":"https://jojoyang666.github.io/2020/06/19/flex/","excerpt":"","text":"Properties for the Parent(flex container)two axis cross axis main axis flex-direction the direction of the main axis, thus defining the direction flex items are placed in the flex container row（default）：main-axis is horizontal directions, start point is on the left row-reverse：main-axis is horizontal directions, start point is on the right column：main-axis is vertical directions, start point is on the top column-reverse：main-axis is vertical directions, start point is on the bottom flex-wrap nowrap(default): all flex items will be on the one line wrap: flex items will wrap onto multiple lines from top to bottom wrap-reverse: flex items will wrap onto multiple lines from bottom to top flex-flow flex-direction + flex wrap .containers { flex-flow: column wrap } justify-content define the alignment along the main axis flex-start(default): items are packed toward the start of the flex-direction flex-end: items are packed toward the end of the flex-direction center: items are centered along the line space-between: items are evenly distributed in the line, first item is on the start line, lastitem on the end line space-around: items are evenly distributed in the line with equal space around them, visuallythe spaces are not equal, since all the items have equal space on both side align-items how flex items are laid out along the cross axis on the current line stretch(default): stretch to fill the container(still respect min-width/max-width) flex-start/start/self-start items are placed start of the cross axis the difference between these is subtle, and is about respecting the flex-direction rulesor the writling-mode rules flex-end/end/self-end items are placed at the end of the cross axis the difference between thses is subtle, and is about respecting the flex-direction rulesor the writling-mode rules center items are centered in the cross-axis baseline itmes are aligned such as their baselines align align-content This aligns a flex container’s lines within when there is extra space in the cross-axis this property has no effect when there is only one line of flex items stretch(default): lines stretch to take up the remaining space flex-start/start: items packed to the start of the container flex-start: honors the flex direction start: honors the writing mode direction flex-end/end: items packed to the end of the container flex-end: honors the flex direction end: honors the writing mode direction center: items centered in the container space-around: items evenly distributed with equal space around each line space-between: items evenly distributed the first line is at the start of the container the last on is at the end the main diff between align-items and align-content is the exptra space, there is some extra space inthe align items, however there is no extra space in the align-content(except space-around and spacebetween) Properties for the Children(flex items)order control the order in which they appear in the flex container default is 0 the value is smaller, it will be in the front of the container flex-grow the ability for a flex item to grow if necessary Negative numbers are invalid defalut is 0, which means even there is extra space, it will not grow if all items have flex-glow set to 1, the remaining space in the container will be distributedequally to all children if one of the children has a value of 2, the remaining space would take up twice as much space as the others flex-shrink the ability for a flex item to shrink if necessary Negative numbers are invalid default is 1, if the space is not enough, it will shrink if an item is 0, others are 1, then if the space is not enough, the previous one will not shrink flex-basis: defines the default size of an element before the remaining space is distributed on the main-axis can set to width/height, then the item will have the fixed size default is auto, the original size of the item flex shorthand for flex-grow, flex-shrink and flex-basis, default value is 0 1 auto it is recommended that you use this shorthand property rather than set the individual properties.the shorthand sets the other values intelligiently align-self the default alignment to be overridden for individual flex items default is auto, inferit from the align-items of parent items, if there is no parent, it will be stretch","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"css","slug":"css","permalink":"https://jojoyang666.github.io/tags/css/"}]}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/categories/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"},{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"},{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"},{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://jojoyang666.github.io/categories/cheatsheet/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jojoyang666.github.io/categories/JavaScript/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"https://jojoyang666.github.io/tags/LinkedList/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://jojoyang666.github.io/tags/Binary-Indexed-Tree/"},{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://jojoyang666.github.io/tags/Union-Find/"},{"name":"Source Control","slug":"Source-Control","permalink":"https://jojoyang666.github.io/tags/Source-Control/"},{"name":"iterm2","slug":"iterm2","permalink":"https://jojoyang666.github.io/tags/iterm2/"},{"name":"shortcut","slug":"shortcut","permalink":"https://jojoyang666.github.io/tags/shortcut/"},{"name":"css","slug":"css","permalink":"https://jojoyang666.github.io/tags/css/"}]}