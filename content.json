{"meta":{"title":"Jojo's Blog","subtitle":"","description":"","author":"Jojo Yang","url":"https://jojoyang666.github.io","root":"/"},"pages":[{"title":"Algorithms","date":"2020-06-23T06:11:50.000Z","updated":"2020-06-23T06:11:50.975Z","comments":true,"path":"Algorithms/index.html","permalink":"https://jojoyang666.github.io/Algorithms/index.html","excerpt":"","text":""},{"title":"Binary Indexed Tree","date":"2020-07-01T18:27:22.000Z","updated":"2020-07-01T18:27:22.044Z","comments":true,"path":"Binary-Indexed-Tree/index.html","permalink":"https://jojoyang666.github.io/Binary-Indexed-Tree/index.html","excerpt":"","text":""},{"title":"JavaScript","date":"2020-06-22T18:47:05.000Z","updated":"2020-06-22T18:47:05.243Z","comments":true,"path":"JavaScript/index.html","permalink":"https://jojoyang666.github.io/JavaScript/index.html","excerpt":"","text":""},{"title":"React","date":"2020-06-25T16:52:57.000Z","updated":"2020-06-25T16:52:57.456Z","comments":true,"path":"React/index.html","permalink":"https://jojoyang666.github.io/React/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-22T01:51:07.000Z","updated":"2020-06-22T01:52:06.868Z","comments":true,"path":"categories/index.html","permalink":"https://jojoyang666.github.io/categories/index.html","excerpt":"","text":""},{"title":"python","date":"2020-07-02T19:07:50.000Z","updated":"2020-07-02T19:07:50.445Z","comments":true,"path":"python/index.html","permalink":"https://jojoyang666.github.io/python/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-22T01:50:56.000Z","updated":"2020-06-22T01:51:38.044Z","comments":true,"path":"tags/index.html","permalink":"https://jojoyang666.github.io/tags/index.html","excerpt":"","text":""},{"title":"tools","date":"2020-06-22T22:34:37.000Z","updated":"2020-06-22T22:34:37.999Z","comments":true,"path":"tools/index.html","permalink":"https://jojoyang666.github.io/tools/index.html","excerpt":"","text":""}],"posts":[{"title":"python-basic-syntax","slug":"python-basic-syntax","date":"2020-07-02T19:07:39.000Z","updated":"2020-07-02T19:30:44.985Z","comments":true,"path":"2020/07/02/python-basic-syntax/","link":"","permalink":"https://jojoyang666.github.io/2020/07/02/python-basic-syntax/","excerpt":"","text":"from import and import Util.py 12345def lookNum(): print(\"I am number\") def lookStr(): print(\"I am string\") Teacher.py 1234567class Teacher: def check(self): return 'I am teacher'; class Order: def checkOrder(self): return 'I am order'; Student.py 123456789101112from Teacher import *import Utilclass Student: def login(self): str = Teacher.check(self) order = Order.checkOrder(self) Util.lookNum() Util.lookStr() print(str+'login success'+order) s = Student()s.login() Conclusion when we import a class, we must use from &lt;..&gt; import &lt;..&gt; if we write multiple classes in a file, we can use from Teacher import * import all if we just want to import one class from a file, we need to deicate the name of class. For example: from Teacher import Order If the file has some methods rather than a class file, can use import &lt;name of file&gt; directly, which means import all the methods from the file. For example: import Util, when want to use the specific method –&gt; Util.lookNum() if want to just import one method, from Util import lookNum, use it –&gt; lookNum()","categories":[{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"}],"tags":[]},{"title":"307. Range Sum Query - Mutable","slug":"307-Range-Sum-Query-Mutable","date":"2020-07-01T18:22:45.000Z","updated":"2020-07-01T18:28:44.657Z","comments":true,"path":"2020/07/01/307-Range-Sum-Query-Mutable/","link":"","permalink":"https://jojoyang666.github.io/2020/07/01/307-Range-Sum-Query-Mutable/","excerpt":"","text":"Solution1 Binary Indexed Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;number[]&#125; nums */var NumArray = function(nums) &#123; this.bitArray = new Array(nums.length + 1); this.nums = nums for (let i = 0; i &lt; nums.length; i++) &#123; this.bitArray[i+1] = nums[i] &#125; for (let i = 1; i &lt; this.bitArray.length; i++) &#123; let j = i + (i&amp;-i) if (j &lt; this.bitArray.length) &#123; this.bitArray[j] += this.bitArray[i] &#125; &#125;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; val * @return &#123;void&#125; */NumArray.prototype.update = function(i, val) &#123; let idx = i + 1 let delta = val - this.nums[i] while (idx &lt; this.bitArray.length) &#123; this.bitArray[idx] += delta idx = idx + (idx &amp; -idx) &#125; this.nums[i] = val;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; j * @return &#123;number&#125; */NumArray.prototype.sumRange = function(i, j) &#123; const prefixSum = (idx) =&gt; &#123; idx += 1 let result = 0; while (idx &gt; 0) &#123; result += this.bitArray[idx] idx = idx - (idx &amp; -idx) &#125; return result; &#125; return prefixSum(j) - prefixSum(i-1);&#125;;/** * Your NumArray object will be instantiated and called as such: * var obj = new NumArray(nums) * obj.update(i,val) * var param_2 = obj.sumRange(i,j) */","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/tags/Leetcode/"}]},{"title":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","date":"2020-06-30T23:47:14.000Z","updated":"2020-07-01T18:26:03.531Z","comments":true,"path":"2020/06/30/Binary-Indexed-Tree/","link":"","permalink":"https://jojoyang666.github.io/2020/06/30/Binary-Indexed-Tree/","excerpt":"","text":"Definition A data structure that can efficiently update element and calculate prefix sums in a table of numbers It can solve the problems below efficiently update(idx, delta): add num at the number which at position idx prefixSum(idx): get the sum of numbers which start from position 1 to idx(include idx) rangeSum(from_idx, to_idx): get the sum of all the numbers which is from from_idx to to_idx Thoughts about Construction Binary Indexed Tree store the element in a logical way according to the binary of number Sum in the Binary Indexed Tree: Given the position i(we want to get the sum from position 1 to i), like 13 13 = 2^3 + 2^2 + 2^0 =&gt; prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13) Note: RANGE(x, y) represent the sum of array starting from postion x to postion y First level, fill from the first number in the array. length is the sum of 2^m(m is from 0 to infinite) numbersfor example 2^0, 2^1, 2^2, 2^3. stop here because 2^4 exceeds the length of array Second level. fill from 3(the first hole). length is the sum of 2^m(m is from 0 to infinite) numbers — always start from hole, to the end of array Third level is same as previous one contruct a binary indexed array, we call it BIT, for our coonvience, we index it starting from 1 prefixSum(13) = prefixSum(0b0001101) = BIT[13] + BIT[12] + BIT[8] This is how tree looks like: How to get prefix sum or range sumWay to find the parent node of current node Observation From BelowprefixSum(13) = prefixSum(0b0001101)= BIT[13] + BIT[12] + BIT[8]= BIT[0b00001101] + BIT[0b00001100] + BIT[0b00001000] Move from bottom to Up, actually is a process to flip last digit 1 to 0, for example x = 13 x = 13 = 0b00001101 -x = -13 = 0b11110011 x &amp; (-x) = 0b00000001 x - (x &amp; (-x)) = 0b00001100 Update elment in the array For example, update(5,2), we want to add 2 to the number at postion 5, the process of it would like: we can see that, the postition needed to update is the binary of original position plus 1 to the last 1 in the binary representation, for example x = 5 x = 5 = 0b00000101 -x = -5 = 0b11111011 x &amp; (-x) = 0b00000001 x + (x &amp; (-x)) = 0b00000110 Construction of Binary Indexed TreeMethod 1 Iinite an array with all 0, Do the update(i, delta) for every item –&gt; O(nlgn) Method 2Input is an array list with length n Initianize an array bit with length n+1 Put the numbers of list to bit array from position 1 to n for index i from 1 to n j = i + (i &amp; -i)，if j &lt; n + 1，then bit[j] = bit[j] + bit[i] Conclusion 如何确定某个位置到底是有几个数组成的呢 原来是根据坐标的最低位 Low Bit 来决定的，所谓的最低位，就是二进制数的最右边的一个1开始，加上后面的0(如果有的话)组成的数字 Notes (i &amp; -i): trick to extract the lowest set bit of i Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243public class BinaryIndexedTree &#123; private int[] bitArr; public BinaryIndexedTree(int[] list) &#123; // log(n) this.bitArr = new int[list.length + 1]; for (int i = 0; i &lt; list.length; i++) &#123; this.bitArr[i + 1] = list[i]; &#125; for (int i = 1; i &lt; this.bitArr.length; i++) &#123; let j = i + (i &amp; -i); if (j &lt; this.bitArr.length) &#123; this.bitArr[j] += this.bitArr[i] &#125; &#125; &#125; public void update(int idx, int delta) &#123; idx += 1 while (idx &lt; this.bitArr.length) &#123; this.bitArr[idx] += delta idx = idx + (idx &amp; -idx) &#125; &#125; public int prefixSum(int idx) &#123; idx += 1 int result = 0 while (idx &gt; 0) &#123; result += this.bitArr[idx] idx = idx - (idx &amp; -idx) &#125; return result &#125; public int rangeSum(int from_idx, int to_idx)&#123; return prefixSum(to_idx) - prefixSum(from_idx-1) &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://jojoyang666.github.io/tags/Binary-Indexed-Tree/"}]},{"title":"React LifeCycle","slug":"React-LifeCycle","date":"2020-06-25T16:51:13.000Z","updated":"2020-06-25T17:56:12.957Z","comments":true,"path":"2020/06/25/React-LifeCycle/","link":"","permalink":"https://jojoyang666.github.io/2020/06/25/React-LifeCycle/","excerpt":"","text":"Lifecycle Diagram UpdatingcomponentDidUpdate invoked immediately after updating occurs, is not called for the initial render A good place to do network requests as long as you compare the current props to previous props(e.g. a network request may not be necessary if the props have not changed) May call setState() immediately in componentDidUpdate(), but nore that it must be wrapped in a condition, otherwise will cause a infinite loop If try to “mirror” some state to a prop coming from above, consider using the prop directly instead shouldComponentUpdate Let react know if a component’s output is not affected by the current change in state or props Default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior Invoked before rendering when new props or state are being received. Defaults to true Exists as a performance optimization, do not rely on it to “prevent” a rendering, as this can lead bugs If want to prevent a rendering, can use PureComponent PureComponent performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped Noted that returning false does not prevent child components from rerendering when their states changes Not recommend doing deap equality checks or using JSON.stringify() in shouldComponentUpdate(), it is every inefficient and will harm the performanced React.PureComponent similar to React.Component. The difference between them is: React.Component does not implement shouldComponentUpdate() React.PureComponent implements it with a shallow prop and state comparison React.PureComponent’s shouldComponentUpdate only shallowly compares the object if contains complex data structer, may introduce false-negative for deeper diff React.PureComponent’s shouldComponentUpdate skips prop updates for the whole component subtree Make sure all the children components are also pure","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"}]},{"title":"308. Range Sum Query 2D - Mutable","slug":"308-Range-Sum-Query-2D-Mutable","date":"2020-06-24T18:27:47.000Z","updated":"2020-06-24T18:49:20.583Z","comments":true,"path":"2020/06/24/308-Range-Sum-Query-2D-Mutable/","link":"","permalink":"https://jojoyang666.github.io/2020/06/24/308-Range-Sum-Query-2D-Mutable/","excerpt":"","text":"Solution I 建立列之和的矩阵： 就是(i, j)就是(0, j) + (1, j) + … + (i, j) 之和 相当于把多个一维的区间之和拼到了一起， 所以在构造函数中需要建立起这样一个列之和的矩阵， 然后在更新某一个位置时， 我们只需要将该列中改变的位置下面的所有数字更新一下即可 求某个区间的和时， 只要将相差的各列中对应的起始和结束的行上的差值累加起来即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @param &#123;number[][]&#125; matrix */var NumMatrix = function(matrix) &#123; if (!matrix.length || !matrix[0].length) &#123; return; &#125; this.matrix = matrix this.colSum = [...new Array(matrix.length + 1)].map(item =&gt; new Array(matrix[0].length).fill(0)); for (let i = 1; i &lt; this.colSum.length; i++) &#123; for (let j = 0; j &lt; this.colSum[0].length; j++) &#123; this.colSum[i][j] = this.colSum[i-1][j] + this.matrix[i-1][j]; &#125; &#125;&#125;;/** * @param &#123;number&#125; row * @param &#123;number&#125; col * @param &#123;number&#125; val * @return &#123;void&#125; */NumMatrix.prototype.update = function(row, col, val) &#123; for (let i = row + 1; i &lt; this.colSum.length; i++) &#123; this.colSum[i][col] += val - this.matrix[row][col] &#125; this.matrix[row][col] = val&#125;;/** * @param &#123;number&#125; row1 * @param &#123;number&#125; col1 * @param &#123;number&#125; row2 * @param &#123;number&#125; col2 * @return &#123;number&#125; */NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) &#123; let res = 0; for (let j = col1; j &lt;= col2; j++) &#123; res += this.colSum[row2+1][j] - this.colSum[row1][j]; &#125; return res&#125;;/** * Your NumMatrix object will be instantiated and called as such: * var obj = new NumMatrix(matrix) * obj.update(row,col,val) * var param_2 = obj.sumRegion(row1,col1,row2,col2) */ Solution II","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/tags/Leetcode/"}]},{"title":"Docker","slug":"Docker","date":"2020-06-23T18:09:23.000Z","updated":"2020-06-23T18:20:38.418Z","comments":true,"path":"2020/06/23/Docker/","link":"","permalink":"https://jojoyang666.github.io/2020/06/23/Docker/","excerpt":"","text":"Load docker load &lt; ***.tar.gz —&gt; load images from .tar.gz docker tag ** ***","categories":[{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"}],"tags":[]},{"title":"218. The Skyline Problem","slug":"218-The-Skyline-Problem","date":"2020-06-23T16:56:50.000Z","updated":"2020-06-23T21:15:11.818Z","comments":true,"path":"2020/06/23/218-The-Skyline-Problem/","link":"","permalink":"https://jojoyang666.github.io/2020/06/23/218-The-Skyline-Problem/","excerpt":"","text":"SolutionJSBasic Ideas for JS Treat all left, right positions as the candidate x-positions For each candidate x-position, find out it’s y-position by search for the highest height on top of that position Determine if it’s necessary to record the position by comparing the height with the previous height there is no heap in JS JS Code1234567891011121314151617181920212223242526272829303132var getSkyline = function(buildings) &#123; let cp = new Set(); for (let [l, r, h] of buildings) &#123; cp.add(l); cp.add(r); &#125; let cp1 = [...cp], n = buildings.length; cp1.sort((a, b) =&gt; Number.parseInt(a) - Number.parseInt(b)); let res = [[-1, 0]] for (let p of cp1) &#123; let i = 0, height = 0; while (i &lt; n &amp;&amp; buildings[i][0] &lt;= p) &#123; if (buildings[i][1] &gt; p) &#123; height = Math.max(height, buildings[i][2]); &#125; i++; &#125; if (res[res.length-1][1] === height) &#123; continue; &#125; res.push([p, height]); &#125; return res.slice(1);&#125;; PythonBasic Ideas for Python 对于一个building， 他由(l, r, h)三元组组成， 我们可以将其分解成两种事件 在 left position, 高度从0增加到h（并且这个高度将持续到right position） 在 right position, 高度从h降低到0 引入了一个event结构: 在某一个position p, 他引入了一个高度为h的skyline， 将一直持续到另一个end position 对于right position高度降为0的event， 它的持续长度是无效的 只保留一个right position event， 就可以同时触发不同的两个building， 在同一right position从各自的h降为0的event， 所以对right position events做集合操作会减少计算量 由于需要从左到右触发event， 所以按position对events排序，并且对于同一position， 我们需要先触发更高的h事件， 那么高的h相比于低的h会占据更高的skyline, 低h的 key point就一定不会产生； 相反， 可能会从低到高连续产生冗余的 key point, 所以event不仅需要按第一个元素position排序， 在position相同时， 第二个元素h也必须是有序的 hp记录了对于一条高为h的skyline，他将持续到什么position才结束: [h, endposition], 在同时有多条skyline的时候, h最高的那条skyline会掩盖掉h低的skyline， 因此在event出发时， 需要得到当前最高的skyline; 所以利用heap结构存储hp, 它的第一个值永远为列表中的最小值： 因此在event中记录的是-h, heap结构就会返回最高的skyline. 同时，h必须在endposition之前， 因为它按照第一个元素排序。 触发event时， 首先要做的就是清除已经到end position的skyline； hp: [h, endposition], 如果当前position大于等于hp中的endposition， 那么该skyline就会被清除掉； 由于在有high skyline的情况下， low skyline不会有影响， 因此， 只需要从高到低的方式清除skyline， 直到剩下一个最高的skyline并且它的end position大于前position 对于高度增加到 h 的时间(neg_h &lt; 0), 我们需要添加一个 skyline, 他将持续到 r 即 endposition 由于 res[-1][1] 记录了在当前事件触发之前一直保持的 skyline 如果当前事件触发后 skyline 发生了改变 来了一条新的高度大于 h 的 skyline res[-1] 中记录的 skyline 到达了 endposition 这两种事件都会导致刚才持续的 skyline 与现在最高的 skyline 不同; 同时, key point 产生了, 他将被记录在 res 中 there is no max heap’s push and pop method, so we can use a min heap hp storing -H as max heap Python Code12345678910111213141516171819class Solution(object): def getSkyline(self, buildings): \"\"\" :type buildings: List[List[int]] :rtype: List[List[int]] \"\"\" events = sorted([(l, -h, r) for l, r, h in buildings] + list(&#123;(r, 0, 0) for l, r, h in buildings&#125;)) res, hp = [[0, 0]], [(0, float('inf'))] for l, neg_h, r in events: while l &gt;= hp[0][1]: heapq.heappop(hp) if neg_h: heapq.heappush(hp, (neg_h, r)) if res[-1][1] != -hp[0][0]: res.append([l, -hp[0][0]]) return res[1:]","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/tags/Leetcode/"}]},{"title":"305. Number of Islands II","slug":"305-Number-of-Islands-II","date":"2020-06-23T05:59:43.000Z","updated":"2020-06-23T06:13:19.440Z","comments":true,"path":"2020/06/22/305-Number-of-Islands-II/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/305-Number-of-Islands-II/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839var numIslands2 = function(m, n, positions) &#123; const res = [] const roots = new Array(m*n).fill(-1); const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let cnt = 0; for(let pos of positions) &#123; let id = pos[0] * n + pos[1]; if (roots[id] !== -1) &#123; res.push(cnt); continue; &#125; roots[id] = id; cnt++; for (let dir of dirs) &#123; let x = pos[0] + dir[0], y = pos[1] + dir[1], cur_id = n * x + y; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || roots[cur_id] === -1) continue; let p = findRoot(roots, cur_id), q = findRoot(roots, id) if (p !== q) &#123; roots[p] = q; cnt--; &#125; &#125; res.push(cnt); &#125; return res;&#125;;const findRoot = (roots, id) =&gt; &#123; return (id === roots[id]) ? id : findRoot(roots, roots[id]);&#125; TO speed up add one line to shorten the tree1234567const findRoot = (roots, id) =&gt; &#123; while (id !== roots[id]) &#123; roots[id] = roots[roots[id]] id = roots[id] &#125; return id;&#125; Conclusion For the problem about groups, Union Find is a possible solution Key point of UF: Find the rott Union parent node is the node whose parent is itself","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/tags/Leetcode/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://jojoyang666.github.io/tags/Union-Find/"}]},{"title":"GIT","slug":"GIT","date":"2020-06-22T22:29:47.000Z","updated":"2020-06-29T20:55:22.877Z","comments":true,"path":"2020/06/22/GIT/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/GIT/","excerpt":"","text":"Stash Git stash: Hide current work Git stash list: View current stash Git stash apply &amp; git stash drop Apply and delete Git stash pop Same as above Git stash apply stash@{0} Select stash Git stash show []: 展示存储单元和最新存储的结果 Git stash show -p []: stash detail Cherry-pick git cherry-pick -n Diff git diff –staged git diff –cached REWRITING GIT HISTORY git commit –amend: Replace the last commit with the staged changes and last commit combined. Use with nothing staged to edit the last commit’s message git commit –amend -m “New commit message”: what the command does is overwriting the most recent commit with the new one `-m’ option allows you to write the new message on the command line without opening an editor session git rebase -i —&gt; 前闭后开 Renamegit branch -m Create New Branchgit checkout -f -B local_TOT remotes/origin/TOT","categories":[{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"}],"tags":[{"name":"Source Control","slug":"Source-Control","permalink":"https://jojoyang666.github.io/tags/Source-Control/"}]},{"title":"Shortcut for Iterm2","slug":"Shortcut-for-Iterm2","date":"2020-06-22T21:41:31.000Z","updated":"2020-06-22T22:28:36.513Z","comments":true,"path":"2020/06/22/Shortcut-for-Iterm2/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/Shortcut-for-Iterm2/","excerpt":"","text":"Moving Faster Move to the start of line: Ctrl + A Move to the end of line: Ctrl + E Move forward a word: option + -&gt; Move back a word: option + -&gt; My Favorite Shell Key Combos Delete previous word (in shell): Ctrl + W","categories":[{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://jojoyang666.github.io/categories/cheatsheet/"}],"tags":[{"name":"iterm2","slug":"iterm2","permalink":"https://jojoyang666.github.io/tags/iterm2/"},{"name":"shortcut","slug":"shortcut","permalink":"https://jojoyang666.github.io/tags/shortcut/"}]},{"title":"Regular Expression","slug":"Regular-Expression","date":"2020-06-22T18:46:19.000Z","updated":"2020-06-25T16:51:55.414Z","comments":true,"path":"2020/06/22/Regular-Expression/","link":"","permalink":"https://jojoyang666.github.io/2020/06/22/Regular-Expression/","excerpt":"","text":"Character ClassesAssertions^ Matches the beginning of input if the multiline flas is set to true, also mathces immediately after a line break character Like: /^A/ does not match the “A” in “an A”, but does match the first “A” in “An A” Note: This character has a different meaning when it appears at the start of a group Groups and ranges(?:x) Matches “x” but does not remember the match The matched substring cannot be recalled from the resulting array’s element([1], …, [n]) or from the predefined RegExp object’s properties ($1, …, $2) x|y matches either “x” or “y” Quantifiersx? Matches the preceding item “x” 0 or 1 times If used immediately after any of the quantifiers *, +, ?, {} Unicode Property EscapesNote when create the regular expression, it will be global match or not? if it is global, it should add ‘g’; default is not global when create the regular expression, it will be case sensitive or not? it if is case insensitive, it should add ‘i’; defalut is case sensitive","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jojoyang666.github.io/categories/JavaScript/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"}]},{"title":"Flex Box","slug":"flex","date":"2020-06-19T22:39:00.000Z","updated":"2020-06-22T01:36:11.924Z","comments":true,"path":"2020/06/19/flex/","link":"","permalink":"https://jojoyang666.github.io/2020/06/19/flex/","excerpt":"","text":"Properties for the Parent(flex container)two axis cross axis main axis flex-direction the direction of the main axis, thus defining the direction flex items are placed in the flex container row（default）：main-axis is horizontal directions, start point is on the left row-reverse：main-axis is horizontal directions, start point is on the right column：main-axis is vertical directions, start point is on the top column-reverse：main-axis is vertical directions, start point is on the bottom flex-wrap nowrap(default): all flex items will be on the one line wrap: flex items will wrap onto multiple lines from top to bottom wrap-reverse: flex items will wrap onto multiple lines from bottom to top flex-flow flex-direction + flex wrap .containers { flex-flow: column wrap } justify-content define the alignment along the main axis flex-start(default): items are packed toward the start of the flex-direction flex-end: items are packed toward the end of the flex-direction center: items are centered along the line space-between: items are evenly distributed in the line, first item is on the start line, lastitem on the end line space-around: items are evenly distributed in the line with equal space around them, visuallythe spaces are not equal, since all the items have equal space on both side align-items how flex items are laid out along the cross axis on the current line stretch(default): stretch to fill the container(still respect min-width/max-width) flex-start/start/self-start items are placed start of the cross axis the difference between these is subtle, and is about respecting the flex-direction rulesor the writling-mode rules flex-end/end/self-end items are placed at the end of the cross axis the difference between thses is subtle, and is about respecting the flex-direction rulesor the writling-mode rules center items are centered in the cross-axis baseline itmes are aligned such as their baselines align align-content This aligns a flex container’s lines within when there is extra space in the cross-axis this property has no effect when there is only one line of flex items stretch(default): lines stretch to take up the remaining space flex-start/start: items packed to the start of the container flex-start: honors the flex direction start: honors the writing mode direction flex-end/end: items packed to the end of the container flex-end: honors the flex direction end: honors the writing mode direction center: items centered in the container space-around: items evenly distributed with equal space around each line space-between: items evenly distributed the first line is at the start of the container the last on is at the end the main diff between align-items and align-content is the exptra space, there is some extra space inthe align items, however there is no extra space in the align-content(except space-around and spacebetween) Properties for the Children(flex items)order control the order in which they appear in the flex container default is 0 the value is smaller, it will be in the front of the container flex-grow the ability for a flex item to grow if necessary Negative numbers are invalid defalut is 0, which means even there is extra space, it will not grow if all items have flex-glow set to 1, the remaining space in the container will be distributedequally to all children if one of the children has a value of 2, the remaining space would take up twice as much space as the others flex-shrink the ability for a flex item to shrink if necessary Negative numbers are invalid default is 1, if the space is not enough, it will shrink if an item is 0, others are 1, then if the space is not enough, the previous one will not shrink flex-basis: defines the default size of an element before the remaining space is distributed on the main-axis can set to width/height, then the item will have the fixed size default is auto, the original size of the item flex shorthand for flex-grow, flex-shrink and flex-basis, default value is 0 1 auto it is recommended that you use this shorthand property rather than set the individual properties.the shorthand sets the other values intelligiently align-self the default alignment to be overridden for individual flex items default is auto, inferit from the align-items of parent items, if there is no parent, it will be stretch","categories":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"}],"tags":[{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"css","slug":"css","permalink":"https://jojoyang666.github.io/tags/css/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://jojoyang666.github.io/categories/python/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://jojoyang666.github.io/categories/Algorithms/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/categories/Front-End/"},{"name":"React","slug":"Front-End/React","permalink":"https://jojoyang666.github.io/categories/Front-End/React/"},{"name":"Tools","slug":"Tools","permalink":"https://jojoyang666.github.io/categories/Tools/"},{"name":"cheatsheet","slug":"Tools/cheatsheet","permalink":"https://jojoyang666.github.io/categories/Tools/cheatsheet/"},{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://jojoyang666.github.io/categories/cheatsheet/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jojoyang666.github.io/categories/JavaScript/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jojoyang666.github.io/tags/Leetcode/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://jojoyang666.github.io/tags/Binary-Indexed-Tree/"},{"name":"React","slug":"React","permalink":"https://jojoyang666.github.io/tags/React/"},{"name":"Front End","slug":"Front-End","permalink":"https://jojoyang666.github.io/tags/Front-End/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://jojoyang666.github.io/tags/Union-Find/"},{"name":"Source Control","slug":"Source-Control","permalink":"https://jojoyang666.github.io/tags/Source-Control/"},{"name":"iterm2","slug":"iterm2","permalink":"https://jojoyang666.github.io/tags/iterm2/"},{"name":"shortcut","slug":"shortcut","permalink":"https://jojoyang666.github.io/tags/shortcut/"},{"name":"css","slug":"css","permalink":"https://jojoyang666.github.io/tags/css/"}]}